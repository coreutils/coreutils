#!/usr/bin/perl -w
# Generate an announcement message.
use strict;

use Getopt::Long;
use Digest::MD5;
use Digest::SHA1;

(my $VERSION = '$Revision: 1.10 $ ') =~ tr/[0-9].//cd;
(my $ME = $0) =~ s|.*/||;

my %valid_release_types = map {$_ => 1} qw (alpha beta major);

END
{
  # Nobody ever checks the status of print()s.  That's okay, because
  # if any do fail, we're guaranteed to get an indicator when we close()
  # the filehandle.
  #
  # Close stdout now, and if there were no errors, return happy status.
  # If stdout has already been closed by the script, though, do nothing.
  defined fileno STDOUT
    or return;
  close STDOUT
    and return;

  # Errors closing stdout.  Indicate that, and hope stderr is OK.
  warn "$ME: closing standard output: $!\n";

  # Don't be so arrogant as to assume that we're the first END handler
  # defined, and thus the last one invoked.  There may be others yet
  # to come.  $? will be passed on to them, and to the final _exit().
  #
  # If it isn't already an error, make it one (and if it _is_ an error,
  # preserve the value: it might be important).
  $? ||= 1;
}

sub usage ($)
{
  my ($exit_code) = @_;
  my $STREAM = ($exit_code == 0 ? *STDOUT : *STDERR);
  if ($exit_code != 0)
    {
      print $STREAM "Try `$ME --help' for more information.\n";
    }
  else
    {
      print $STREAM <<EOF;
Usage: $ME [OPTIONS]

OPTIONS:

  Generate an announcement message.

  FIXME: describe the following

   --release-type=TYPE
   --package-name=PACKAGE_NAME
   --previous-version=VER
   --current-version=VER
   --release-archive-directory=DIR
   --url-directory=URL_DIR
   --news=NEWS_FILE

   --help             display this help and exit
   --version          output version information and exit

EOF
    }
  exit $exit_code;
}

{
  my $release_type;
  my $package_name;
  my $prev_version;
  my $curr_version;
  my $release_archive_dir;
  my @url_dir_list;
  my $news_file;

  GetOptions
    (
     'release-type=s' => \$release_type,
     'package-name=s' => \$package_name,
     'previous-version=s' => \$prev_version,
     'current-version=s' => \$curr_version,
     'release-archive-directory=s' => \$release_archive_dir,
     'url-directory=s@' => \@url_dir_list,
     'news=s@' => \$news_file,

     help => sub { usage 0 },
     version => sub { print "$ME version $VERSION\n"; exit },
    ) or usage 1;

  my $fail = 0;
  # Ensure that sure each required option is specified.
  $release_type
    or (warn "$ME: release type not specified\n"), $fail = 1;
  $package_name
    or (warn "$ME: package name not specified\n"), $fail = 1;
  $prev_version
    or (warn "$ME: previous version string not specified\n"), $fail = 1;
  $curr_version
    or (warn "$ME: current version string not specified\n"), $fail = 1;
  $release_archive_dir
    or (warn "$ME: release directory name not specified\n"), $fail = 1;
  @url_dir_list
    or (warn "$ME: URL directory name(s) not specified\n"), $fail = 1;

  exists $valid_release_types{$release_type}
    or (warn "$ME: `$release_type': invalid release type\n"), $fail = 1;

  @ARGV
    and (warn "$ME: too many arguments\n"), $fail = 1;
  $fail
    and usage 1;

  my $my_distdir = "$package_name-$curr_version";
  my $tgz = "$my_distdir.tar.gz";
  my $tbz = "$my_distdir.tar.bz2";
  my $xd = "$package_name-$prev_version-$curr_version.xdelta";

  my %size;

  foreach my $f (($tgz, $tbz, $xd))
    {
      my $cmd = "du --human $f";
      my $t = `$cmd`;
      # FIXME-someday: give a better diagnostic, a la $PROCESS_STATUS
      $@
	and (warn "$ME: command failed: `$cmd'\n"), $fail = 1;
      chomp $t;
      $t =~ s/^([\d.]+[MkK]).*/${1}B/;
      $size{$f} = $t;
    }

  $fail
    and exit 1;

  print <<EOF;

Subject: $my_distdir released

<#secure method=pgpmime mode=sign>

FIXME: put comments here

EOF

  foreach my $url (@url_dir_list)
    {
      print "  $url/$tgz   ($size{$tgz})\n";
      print "  $url/$tbz  ($size{$tbz})\n";
    }

  print "\nAnd here are xdelta-style diffs:\n";
  foreach my $url (@url_dir_list)
    {
      print "  $url/$xd   ($size{$xd})\n";
    }

  print "\nHere are GPG detached signatures:\n";
  foreach my $url (@url_dir_list)
    {
      print "  $url/$tgz.sig\n";
      print "  $url/$tbz.sig\n";
    }

  # FIXME: clean up upon interrupt or die
  my $tmpdir = $ENV{TMPDIR} || '/tmp';
  my $tmp = "$tmpdir/$ME-$$";
  unlink $tmp;  # ignore failure

  print "\nHere are the MD5 and SHA1 signatures:\n";
  print "\n";
  print "<#part type=text/plain filename=\"$tmp\" disposition=inline>\n"
    . "<#/part>\n";

  open OUT, '>', $tmp
    or die "$ME: $tmp: cannot open for writing: $!\n";

  foreach my $meth (qw (md5 sha1))
    {
      foreach my $f (($tgz, $tbz, $xd))
	{
	  open IN, '<', $f
	    or die "$ME: $f: cannot open for reading: $!\n";
	  binmode IN;
	  my $dig =
	    ($meth eq 'md5'
	     ? Digest::MD5->new->addfile(*IN)->hexdigest
	     : Digest::SHA1->new->addfile(*IN)->hexdigest);
	  close IN;
	  print OUT "$dig  $f\n";
	}
    }

  close OUT
    or die "$ME: $tmp: while writing: $!\n";
  chmod 0400, $tmp;  # ignore failure

  if ($news_file)
    {
      print "\nNEWS\n\n";

      # Print all lines from $news_file, starting with the first one
      # that mentions $curr_version up to but not including
      # the first occurrence of $prev_version.
      my $in_items;
      open NEWS, '<', $news_file
	or die "$ME: $news_file: cannot open for reading: $!\n";
      while (defined (my $line = <NEWS>))
	{
	  if ( ! $in_items)
	    {
	      $line =~ /^[^ *].*\Q$curr_version\E/o
		or next;
	      $in_items = 1;
	      print $line;
	    }
	  else
	    {
	      # Be careful that this regexp cannot match version numbers
	      # in NEWS items -- they might well say `introduced in 4.5.5',
	      # and we don't want that to match.
	      $line =~ /^[^ *].*\Q$prev_version\E/o
		and last;
	      print $line;
	    }
	}
      close NEWS;

      $in_items
	or die "$ME: $news_file: no matching lines\n";
    }

  # FIXME: Print ChangeLog entries only for test releases
  # echo ChangeLog entries:;
  # find . -name ChangeLog -maxdepth 2
  #   | xargs $(CVS) diff -up -r$(prev-cvs-tag) -rHEAD
  #   | sed -n 's/^+//p'
  #   | perl -ne 'm!^\+\+ (\./)?! or print,next;'
  #     -e 'print "\n"."*"x70 ."\n"; s///; print; print "*"x70 ."\n"';
}
