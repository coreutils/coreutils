# Messages français pour GNU concernant textutils.
# Copyright © 1996 Free Software Foundation, Inc.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, traducteur depuis/since 1996.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU coreutils 4.5.11\n"
"POT-Creation-Date: 2003-03-31 10:45+0200\n"
"PO-Revision-Date: 2003-03-27 08:00-0500\n"
"Last-Translator: Michel Robitaille <robitail@IRO.UMontreal.CA>\n"
"Language-Team: French <traduc@traduc.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: lib/argmatch.c:135
#, c-format
msgid "invalid argument %s for %s"
msgstr "argument %s invalide pour %s"

#: lib/argmatch.c:136
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argument %s ambigu pour %s"

#: lib/argmatch.c:155
msgid "Valid arguments are:"
msgstr "Arguments valides sont:"

#: lib/closeout.c:103 src/cat.c:189 src/cat.c:272 src/cat.c:326
#: src/cksum.c:269 src/head.c:152 src/head.c:196 src/tail.c:323
#: src/tail.c:1659 src/tr.c:1666 src/tr.c:1912 src/tr.c:2020
msgid "write error"
msgstr "Erreur d'écriture."

#: lib/error.c:133 lib/error.c:161
msgid "Unknown system error"
msgstr "Erreur système inconnue"

#: lib/file-type.c:42
msgid "regular empty file"
msgstr "fichier régulier vide"

#: lib/file-type.c:42
msgid "regular file"
msgstr "fichier régulier"

#: lib/file-type.c:45
msgid "directory"
msgstr "répertoire"

#: lib/file-type.c:48
msgid "block special file"
msgstr "fichier spécial de bloc"

#: lib/file-type.c:51
msgid "character special file"
msgstr "fichier spécial de caractères"

#: lib/file-type.c:54
msgid "fifo"
msgstr "PEPS (FIFO)"

#: lib/file-type.c:57
msgid "symbolic link"
msgstr "lien symbolique"

#: lib/file-type.c:60
msgid "socket"
msgstr "socket"

#: lib/file-type.c:63
msgid "message queue"
msgstr "queue de messages"

#: lib/file-type.c:66
msgid "semaphore"
msgstr "sémaphore"

#: lib/file-type.c:69
msgid "shared memory object"
msgstr "objet de mémoire partagée"

#: lib/file-type.c:71
msgid "weird file"
msgstr "fichier bizarre"

#: lib/getopt.c:688 lib/getopt.c:700
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: l'option « %s » est ambiguë\n"

#: lib/getopt.c:733 lib/getopt.c:737
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: l'option « --%s » ne requiert pas un argument.\n"

#: lib/getopt.c:746 lib/getopt.c:751
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: l'option « %c%s » ne requiert pas un argument.\n"

#: lib/getopt.c:787 lib/getopt.c:800 lib/getopt.c:1089 lib/getopt.c:1102
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: l'option « %s » requiert un argument.\n"

#: lib/getopt.c:838 lib/getopt.c:841
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: option non reconnue « --%s »\n"

#: lib/getopt.c:849 lib/getopt.c:852
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: option non reconnue « %c%s »\n"

#: lib/getopt.c:899 lib/getopt.c:902
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: option illégale --%c\n"

#: lib/getopt.c:908 lib/getopt.c:911
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: option invalide --%c\n"

#: lib/getopt.c:958 lib/getopt.c:969 lib/getopt.c:1155 lib/getopt.c:1168
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: l'option requiert un argument --%c\n"

#: lib/getopt.c:1021 lib/getopt.c:1032
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: l'option « -W %s » est ambiguë\n"

#: lib/getopt.c:1056 lib/getopt.c:1068
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: l'option « -W %s » ne requiert pas un argument.\n"

#: lib/human.c:519
msgid "block size"
msgstr "taille de bloc"

#: lib/makepath.c:124 src/df.c:497 src/remove.c:402
msgid "failed to return to initial working directory"
msgstr "échec de retour au répertoire initial de travail"

#: lib/makepath.c:173 src/copy.c:1288 src/mkdir.c:170
#, c-format
msgid "cannot create directory %s"
msgstr "Ne peut créer le répertoire %s"

#: lib/makepath.c:179 lib/makepath.c:421 src/cp.c:446 src/cp.c:468
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s existe mais n'est pas un répertoire"

#: lib/makepath.c:316 lib/makepath.c:378 lib/makepath.c:440
#, c-format
msgid "cannot change owner and/or group of %s"
msgstr "ne peut modifier le propriétraire et/ou le groupe de %s"

#: lib/makepath.c:338
#, c-format
msgid "cannot chdir to directory %s"
msgstr "ne peut aller vers le répertoire %s"

#: lib/makepath.c:392 lib/makepath.c:446
#, c-format
msgid "cannot change permissions of %s"
msgstr "Ne peut changer les permissions de %s"

#: lib/obstack.c:487 lib/obstack.c:490 lib/xmalloc.c:63
msgid "memory exhausted"
msgstr "Mémoire épuisée"

#: lib/quotearg.c:236
msgid "`"
msgstr "`"

#: lib/quotearg.c:237
msgid "'"
msgstr "'"

#: lib/rpmatch.c:78
msgid "^[yY]"
msgstr "^[yY]"

#: lib/rpmatch.c:81
msgid "^[nN]"
msgstr "^[nN]"

#: lib/unicodeio.c:155
msgid "iconv function not usable"
msgstr "fonction iconv n'est pas utilisable"

#: lib/unicodeio.c:157
msgid "iconv function not available"
msgstr "fonction iconv n'est pas disponible"

#: lib/unicodeio.c:164
msgid "character out of range"
msgstr "caractère hors plage"

#: lib/unicodeio.c:227
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "ne peut convertir U+%04X à un jeu local de caractères"

#: lib/unicodeio.c:229
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "ne peut convertir U+%04X au jeu local de caractères: %s"

#: lib/userspec.c:174
msgid "invalid user"
msgstr "usager invalide"

#: lib/userspec.c:175
msgid "invalid group"
msgstr "groupe invalide"

#: lib/userspec.c:177
msgid "cannot get the login group of a numeric UID"
msgstr ""
"ne peut obtenir le groupe d'établissement de session à partir du UID "
"numérique"

#: lib/userspec.c:179
msgid "cannot omit both user and group"
msgstr "ne peut omettre ensemble l'usager et le groupe"

#: lib/version-etc.c:57
#, c-format
msgid "Written by %s.\n"
msgstr "Écrit par %s.\n"

#: lib/version-etc.c:63
msgid ""
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"Ce logiciel est libre; voir les sources pour les conditions de\n"
"reproduction. AUCUNE garantie n'est donnée; tant pour des raisons\n"
"COMMERCIALES que pour RÉPONDRE À UN BESOIN PARTICULIER.\n"

#: lib/xmemcoll.c:57
msgid "string comparison failed"
msgstr "échec de comparaison de chaîne"

#: lib/xmemcoll.c:58
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Définir LC_ALL=« C » pour contourner le problème."

#: lib/xmemcoll.c:60
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Les chaînes comparées étaient %s et %s."

#: src/basename.c:50 src/cat.c:88 src/chgrp.c:122 src/chmod.c:238
#: src/chown.c:95 src/chroot.c:41 src/cksum.c:278 src/comm.c:69 src/cp.c:160
#: src/csplit.c:1492 src/cut.c:170 src/date.c:113 src/dd.c:284 src/df.c:707
#: src/dircolors.c:99 src/dirname.c:42 src/du.c:170 src/echo.c:73
#: src/env.c:115 src/expand.c:106 src/expr.c:86 src/factor.c:70 src/fmt.c:267
#: src/fold.c:63 src/head.c:84 src/hostid.c:44 src/hostname.c:63 src/id.c:83
#: src/install.c:593 src/join.c:140 src/kill.c:89 src/link.c:47 src/ln.c:335
#: src/logname.c:44 src/ls.c:3757 src/md5sum.c:121 src/mkdir.c:57
#: src/mkfifo.c:51 src/mknod.c:51 src/mv.c:307 src/nice.c:63 src/nl.c:172
#: src/od.c:283 src/paste.c:399 src/pathchk.c:142 src/pinky.c:465
#: src/pr.c:2750 src/printenv.c:59 src/printf.c:96 src/ptx.c:1855 src/pwd.c:42
#: src/readlink.c:65 src/rm.c:95 src/rmdir.c:142 src/seq.c:78 src/shred.c:156
#: src/sleep.c:48 src/sort.c:272 src/split.c:92 src/stat.c:680 src/stty.c:494
#: src/su.c:433 src/sum.c:56 src/sync.c:40 src/tac.c:123 src/tail.c:230
#: src/tee.c:59 src/test.c:975 src/touch.c:240 src/tr.c:323 src/tsort.c:93
#: src/tty.c:58 src/uname.c:106 src/unexpand.c:371 src/uniq.c:135
#: src/unlink.c:47 src/uptime.c:187 src/users.c:114 src/wc.c:121 src/who.c:570
#: src/whoami.c:48 src/yes.c:45
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pour en savoir davantage, faites: « %s --help ».\n"

#: src/basename.c:54
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s NOM [SUFFIXE]...\n"
"  or:  %s [OPTION]\n"

#: src/basename.c:59
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
"\n"
msgstr ""
"Afficher le NOM sans être précédé des composants des noms de répertoires\n"
"Si spécifié enlever aussi le SUFFIXE.\n"
"\n"

#: src/basename.c:66 src/cat.c:124 src/chgrp.c:152 src/chmod.c:264
#: src/chown.c:139 src/chroot.c:59 src/cksum.c:293 src/comm.c:86 src/cp.c:257
#: src/csplit.c:1534 src/cut.c:215 src/date.c:215 src/dd.c:331 src/df.c:746
#: src/dircolors.c:120 src/dirname.c:58 src/du.c:219 src/echo.c:105
#: src/env.c:134 src/expand.c:131 src/expr.c:149 src/factor.c:90
#: src/false.c:45 src/fmt.c:297 src/fold.c:86 src/head.c:115 src/hostid.c:57
#: src/hostname.c:76 src/id.c:104 src/install.c:648 src/join.c:181
#: src/kill.c:119 src/link.c:59 src/ln.c:390 src/logname.c:55 src/ls.c:3891
#: src/md5sum.c:157 src/mkdir.c:76 src/mkfifo.c:68 src/mknod.c:82 src/mv.c:361
#: src/nice.c:77 src/nl.c:227 src/od.c:370 src/paste.c:423 src/pathchk.c:154
#: src/pinky.c:492 src/pr.c:2862 src/printenv.c:72 src/printf.c:144
#: src/pwd.c:53 src/readlink.c:82 src/rm.c:127 src/rmdir.c:162 src/seq.c:104
#: src/shred.c:220 src/sleep.c:64 src/sort.c:343 src/split.c:124
#: src/stat.c:751 src/stty.c:708 src/su.c:454 src/sum.c:76 src/sync.c:51
#: src/tac.c:146 src/tail.c:300 src/tee.c:72 src/test.c:1057 src/touch.c:271
#: src/tr.c:396 src/true.c:45 src/tsort.c:105 src/tty.c:70 src/uname.c:128
#: src/unexpand.c:395 src/uniq.c:174 src/unlink.c:58 src/uptime.c:202
#: src/users.c:127 src/wc.c:143 src/who.c:613 src/whoami.c:60 src/yes.c:61
#, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Rapporter toutes anomalies à <%s>.\n"

#: src/basename.c:114 src/chgrp.c:210 src/chmod.c:352 src/chown.c:211
#: src/chroot.c:78 src/csplit.c:1464 src/dirname.c:89 src/expr.c:178
#: src/install.c:284 src/link.c:87 src/mkdir.c:124 src/mkfifo.c:113
#: src/mknod.c:137 src/pathchk.c:194 src/readlink.c:101 src/readlink.c:133
#: src/rm.c:199 src/rmdir.c:206 src/seq.c:411 src/sleep.c:139 src/stat.c:802
#: src/unlink.c:88
msgid "too few arguments"
msgstr "Trop peu de arguments."

#: src/basename.c:115 src/dircolors.c:482 src/dirname.c:90 src/hostid.c:79
#: src/hostname.c:122 src/link.c:93 src/mknod.c:139 src/readlink.c:141
#: src/seq.c:417 src/split.c:498 src/tr.c:1848 src/unlink.c:94
#: src/uptime.c:244 src/users.c:169 src/who.c:764
msgid "too many arguments"
msgstr "Trop de arguments."

#: src/cat.c:42 src/split.c:43
msgid "Torbjorn Granlund and Richard M. Stallman"
msgstr "Torbjorn Granlund et Richard M. Stallman"

#: src/cat.c:92
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Usage: %s [OPTION] [FICHIER]...\n"

#: src/cat.c:96
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
msgstr ""
"Concaténer le(s) FICHIER(s), ou de l'ENTRÉE standard, vers la sortie "
"standard.\n"
"\n"
"  -A, --show-all           équivalent à -vET\n"
"  -b, --number-nonblank    numéroter que les lignes non vides\n"
"  -e                       équivalent à -vE\n"
"  -E, --show-ends          afficher $ à la fin de chaque ligne\n"
"  -n, --number             numéroter toutes les lignes\n"
"  -s, --squeeze-blank      afficher jamais plus qu'une seule ligne vide\n"

#: src/cat.c:106
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       équivalent à -vT\n"
"  -T, --show-tabs          afficher les caractères TAB comme ^I\n"
"  -u                       (ignoré)\n"
"  -v, --show-nonprinting   utiliser la notation ^ et M- ,\n"
"                            excepté pour LFD et TAB\n"

#: src/cat.c:114 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/cat.c:119
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             écrire en binaire sur la console.\n"
"\n"

#: src/cat.c:314
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "Ne peut exécuter « ioctl » sur « %s »"

#: src/cat.c:669 src/dd.c:1222 src/od.c:1013 src/tee.c:181
msgid "standard output"
msgstr "sortie standard"

#: src/cat.c:800
#, c-format
msgid "%s: input file is output file"
msgstr "%s: le fichier à l'entrée est le même qu'à la sortie."

#: src/cat.c:858
msgid "closing standard input"
msgstr "fermeture de l'entrée standard"

#: src/cat.c:861
msgid "closing standard output"
msgstr "fermeture de la sortie standard"

#: src/chgrp.c:93
msgid "cannot change to null group"
msgstr "ne peut modifier pour le groupe nul"

#: src/chgrp.c:102
#, c-format
msgid "invalid group name %s"
msgstr "nom de groupe invalide %s"

#: src/chgrp.c:106
msgid "group number"
msgstr "numéro de groupe"

#: src/chgrp.c:109
#, c-format
msgid "invalid group number %s"
msgstr "numéro de groupe invalide %s"

#: src/chgrp.c:126
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... GROUPE FICHIER...\n"
"  ou:  %s [OPTION]... --reference=FICHIER-R FICHIER...\n"

#: src/chgrp.c:131
msgid ""
"Change the group membership of each FILE to GROUP.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link, rather\n"
"                         than the symbolic link itself\n"
msgstr ""
"Changer le groupe d'appartenance de chaque FICHIER au GROUPE.\n"
"\n"
"  -c, --changes             utiliser le mode bavard mais rapporter "
"seulement\n"
"                            les modifications lorsqu'elles surviennent\n"
"      --dereference         affecter le référent de chaque lien symbolique,\n"
"                            plutôt que le lien symbolique lui-même\n"

#: src/chgrp.c:138 src/chown.c:112
msgid ""
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
"                         (available only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"  -h, --no-dereference      modifier les liens symboliques au lieu des\n"
"                            fichiers référencés (disponible seulement\n"
"                            sur les systèmes offrant l'appel système "
"lchown)\n"

#: src/chgrp.c:143
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's group rather than the specified\n"
"                         GROUP value\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -f, --silent, --quiet     supprimer la plupart des messages d'erreur\n"
"      --reference=FICHIER   utiliser le groupe de référence du FICHIER\n"
"                            au lieu d'une valeur de groupe\n"
"  -R, --recursive           modifier récursivement fichiers et répertoires\n"
"  -v, --verbose             produire un diagnostic pour chaque fichier "
"traité\n"

#: src/chgrp.c:218 src/chmod.c:157 src/chmod.c:365 src/chown-core.c:235
#: src/chown-core.c:247 src/chown.c:220 src/cp.c:303 src/touch.c:169
#: src/touch.c:363
#, c-format
msgid "failed to get attributes of %s"
msgstr "échec d'obtention des attributs de %s"

#: src/chmod.c:102
#, c-format
msgid "getting new attributes of %s"
msgstr "obtention des nouveaux attributs de %s"

#: src/chmod.c:124
#, c-format
msgid "mode of %s changed to %04lo (%s)\n"
msgstr "Le mode d'accès de %s a été modifié à %04lo (%s).\n"

#: src/chmod.c:127
#, c-format
msgid "failed to change mode of %s to %04lo (%s)\n"
msgstr "Échec du changement de mode de %s à %04lo (%s).\n"

#: src/chmod.c:130
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "Le mode d'accès de %s qui a été conservé est: %04lo (%s).\n"

#: src/chmod.c:179
#, c-format
msgid "changing permissions of %s"
msgstr "modification des permissions de %s"

#: src/chmod.c:242
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... MODE[,MODE]... FICHIER...\n"
"  ou:  %s [OPTION]... MODE-OCTAL FICHIER\n"
"  ou:  %s [OPTION]... --reference=FICHIER-R FICHIER\n"

#: src/chmod.c:248
msgid ""
"Change the mode of each FILE to MODE.\n"
"\n"
"  -c, --changes           like verbose but report only when a change is "
"made\n"
"  -f, --silent, --quiet   suppress most error messages\n"
"  -v, --verbose           output a diagnostic for every file processed\n"
"      --reference=RFILE   use RFILE's mode instead of MODE values\n"
"  -R, --recursive         change files and directories recursively\n"
msgstr ""
"Changer le MODE d'accès de chaque FICHIER.\n"
"\n"
"  -c, --changes           utiliser le mode bavard mais rapporter seulement\n"
"                          les modifications lorsqu'elles surviennent\n"
"  -f, --silent, --quiet   supprimer la plupart des messages d'erreur\n"
"  -v, --verbose           produire un diagnostic pour chaque fichier traité\n"
"      --reference=FICHIER utiliser les modes d'accès du FICHIER de "
"référence\n"
"                          au lieu de valeurs\n"
"  -R, --recursive         modifier récursivement fichiers et répertoires\n"

#: src/chmod.c:259
msgid ""
"\n"
"Each MODE is one or more of the letters ugoa, one of the symbols +-= and\n"
"one or more of the letters rwxXstugo.\n"
msgstr ""
"\n"
"Chaque MODE se compose d'un ou plusieurs lettres de ugoa, un des symbols +-= "
"et\n"
"d'une ou plusieurs lettres rwxXstugo.\n"

#: src/chmod.c:320
#, c-format
msgid "invalid character %s in mode string %s"
msgstr "caractère invalide %s dans la chaîne du mode %s"

#: src/chmod.c:361
#, c-format
msgid "invalid mode string: %s"
msgstr "chaîne de mode invalide: %s"

#: src/chown-core.c:116
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "Ni le lien symbolique %s ni la référence n'ont changé.\n"

#: src/chown-core.c:143
#, c-format
msgid "changed ownership of %s to %s\n"
msgstr "Changement de propriétaire de %s vers %s\n"

#: src/chown-core.c:144
#, c-format
msgid "changed group of %s to %s\n"
msgstr "Changement de groupe de %s vers %s\n"

#: src/chown-core.c:148
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "échec de changement de propriétaire de %s vers %s\n"

#: src/chown-core.c:149
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "Échec de changement de groupe de %s vers %s\n"

#: src/chown-core.c:153
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "L'appartenance de %s qui a été retenue est %s\n"

#: src/chown-core.c:154
#, c-format
msgid "group of %s retained as %s\n"
msgstr "Le groupe d'appartenance de %s qui a été retenu est %s.\n"

#: src/chown-core.c:326
#, c-format
msgid "changing ownership of %s"
msgstr "changement de propriétaire pour %s"

#: src/chown-core.c:327
#, c-format
msgid "changing group of %s"
msgstr "modification du groupe de %s"

#: src/chown-core.c:345
#, c-format
msgid "unable to restore permissions of %s"
msgstr "incapable de restaurer es permissions de %s"

#: src/chown.c:99
#, c-format
msgid ""
"Usage: %s [OPTION]... OWNER[:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... :GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... PROPRIÉTAIRE[:[GROUPE]] FICHIER...\n"
"  ou:  %s [OPTION]... :GROUPE FICHIER...\n"
"  ou:  %s [OPTION]... --reference=FICHIER-R FICHIER\n"

#: src/chown.c:105
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link, rather\n"
"                         than the symbolic link itself\n"
msgstr ""
"Changer le propriétaire et/ou le groupe de chaque FICHIER.\n"
"\n"
"  -c, --changes             utiliser le mode bavard mais rapporter "
"seulement\n"
"                            les modifications lorsqu'elles surviennent\n"
"      --dereference         affecter le référent de chaque lien symbolique,\n"
"                            plutôt que le lien symbolique lui-même\n"

#: src/chown.c:117
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute.\n"
msgstr ""
"      --from=PROPRIÉTAIRE_COURANT:GROUPE_COURANT\n"
"                            changer le propriétaire et/ou le groupe de "
"chaque fichier\n"
"                            seulement s'il y a concordance avec le "
"propriétaire\n"
"                            et/ou groupe courant spécifié. Les deux peuvent "
"être\n"
"                            omis, auquel cas la concordance n'est pas "
"requise pour\n"
"                            l'argument non spécifié.\n"

#: src/chown.c:124
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         the specified OWNER:GROUP values\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -f, --silent, --quiet     supprimer la plupart des messages d'erreur\n"
"      --reference=FICHIER   utiliser l'appartenance du propriétaire et du\n"
"                            groupe du FICHIER de référence au lieu\n"
"                            de valeurs explicites PROPRIÉTAIRE:GROUPE\n"
"  -R, --recursive           modifier récursivement fichiers et répertoires\n"
"  -v, --verbose             indiquer ce qui a été fait\n"

#: src/chown.c:133
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a `:'.  OWNER and GROUP may be numeric as well\n"
"as symbolic.\n"
msgstr ""
"\n"
"Le propriétaire n'est pas modifié si manquant.  Le groupe n'est pas modifié "
"si manquant,\n"
"mais modifié au groupe de login implicite si « : » est spécifié.\n"
"Le propriétaire et le groupe peuvent être numérique ou symbolique.\n"

#: src/chroot.c:45
#, c-format
msgid ""
"Usage: %s NEWROOT [COMMAND...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s RACINE [COMMANDE...\n"
"  or:  %s OPTION\n"

#: src/chroot.c:49
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Exécuter la COMMANDE avec le répertoire root initialisé à NOUVEAU-ROOT.\n"
"\n"

#: src/chroot.c:55
msgid ""
"\n"
"If no command is given, run ``${SHELL} -i'' (default: /bin/sh).\n"
msgstr ""
"\n"
"Si aucune commande n'est fournie, exécuter ``${SHELL} -i'' (par défaut: /bin/"
"sh).\n"

#: src/chroot.c:84
#, c-format
msgid "cannot change root directory to %s"
msgstr "ne changer le répertoire racine vers %s"

#: src/chroot.c:87
msgid "cannot chdir to root directory"
msgstr "ne peut aller vers le répertoire root"

#: src/cksum.c:234
#, c-format
msgid "%s: file too long"
msgstr "%s: fichier trop long"

#: src/cksum.c:282
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Usage: %s [FICHIER]...\n"
"  or:  %s [OPTION]\n"

#: src/cksum.c:287
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
"FICHIER.\n"
"\n"

#: src/comm.c:35 src/ls.c:131 src/uniq.c:40
msgid "Richard Stallman and David MacKenzie"
msgstr "Richard Stallman et David MacKenzie"

#: src/comm.c:73
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "Usage: %s [OPTION]... FICHIER_GAUCHE  FICHIER_DROIT\n"

#: src/comm.c:77
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines that appear in both files\n"
msgstr ""
"Comparer les fichiers triés GAUCHE et DROITE ligne par ligne.\n"
"\n"
"  -1              supprimer les lignes uniques du fichier de gauche\n"
"  -2              supprimer les lignes uniques du fichier de droite\n"
"  -3              supprimer les lignes uniques des 2 fichiers\n"

#: src/copy.c:162 src/du.c:332
#, c-format
msgid "cannot access %s"
msgstr "ne peut accéder %s"

#: src/copy.c:226
#, c-format
msgid "cannot open %s for reading"
msgstr "Ne peut ouvrir %s en lecture"

#: src/copy.c:232 src/copy.c:286 src/copy.c:301 src/dd.c:1199
#, c-format
msgid "cannot fstat %s"
msgstr "ne peut évaluer par fstat() %s"

#: src/copy.c:242
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "escamotage du fichier %s, parce qu<il a /t/ remplac/ durant la copie"

#: src/copy.c:262 src/copy.c:1034 src/copy.c:1124 src/ln.c:291
#: src/remove.c:727 src/remove.c:781 src/remove.c:893 src/remove.c:997
#, c-format
msgid "cannot remove %s"
msgstr "ne peut enlever %s"

#: src/copy.c:277
#, c-format
msgid "cannot create regular file %s"
msgstr "ne peut créer le fichier régulier %s"

#: src/copy.c:328 src/dd.c:816 src/dd.c:1010
#, c-format
msgid "reading %s"
msgstr "lecture de %s"

#: src/copy.c:362
#, c-format
msgid "cannot lseek %s"
msgstr "ne peut repérer par lseek() %s"

#: src/copy.c:377 src/copy.c:401 src/dd.c:1054 src/dd.c:1115
#, c-format
msgid "writing %s"
msgstr "écriture de %s"

#: src/copy.c:409 src/copy.c:415
#, c-format
msgid "closing %s"
msgstr "fermeture de %s"

#: src/copy.c:610
#, c-format
msgid "%s: overwrite %s, overriding mode %04lo? "
msgstr "%s: écraser %s, en outrepassant le mode %04lo? "

#: src/copy.c:616
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: écraser %s?"

#: src/copy.c:810 src/copy.c:848 src/stat.c:638
#, c-format
msgid "cannot stat %s"
msgstr "ne peut évaluer %s"

#: src/copy.c:820
#, c-format
msgid "omitting directory %s"
msgstr "omission du répertoire %s"

#: src/copy.c:834
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "AVERTISSEMENT: fichier source %s spécifié plus d'une fois"

#: src/copy.c:866 src/ln.c:237
#, c-format
msgid "%s and %s are the same file"
msgstr "%s et %s identifient le même fichier."

#: src/copy.c:876
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "ne peut écraser le non-répertoire %s par le répertoire %s"

#: src/copy.c:893
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "n'écrasera pas %s qui vient d'être créé par %s"

#: src/copy.c:904
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "ne peut écraser le répertoire %s par un non-répertoire"

#: src/copy.c:965
#, c-format
msgid "cannot overwrite directory %s"
msgstr "ne peut écraser le répertoire %s"

#: src/copy.c:974
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "ne peut déplacer le répertoire dans un non-répertoire: %s -> %s"

#: src/copy.c:997
#, c-format
msgid "backing up %s would destroy source;  %s not moved"
msgstr "L'archivage de %s pourrait détruire la source: %s n'a pas été déplacé."

#: src/copy.c:998
#, c-format
msgid "backing up %s would destroy source;  %s not copied"
msgstr ""
"L'archivage de %s pourrait détruire le fichier SOURCE:\n"
"%s n'a pas été copié."

#: src/copy.c:1013 src/ln.c:273
#, c-format
msgid "cannot backup %s"
msgstr "ne peut archiver %s"

#: src/copy.c:1049 src/ln.c:308
#, c-format
msgid " (backup: %s)"
msgstr " (archiver: %s)"

#: src/copy.c:1099
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "ne peut copier un répertoire %s dans lui-même %s"

#: src/copy.c:1106
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "ne peut créer un lien direct %s vers le répertoire %s"

#: src/copy.c:1132
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "ne peut créer un lien direct %s vers %s"

#: src/copy.c:1186
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "ne peut déplacer %s vers un sous-répertoire de lui-même %s"

#: src/copy.c:1229
#, c-format
msgid "cannot move %s to %s"
msgstr "ne peut déplacer %s vers %s"

#: src/copy.c:1241
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"échec de déplacement inter-périphérique: %s vers %s; incapable de détruire "
"la cible"

#: src/copy.c:1269
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "ne peut copier des liens symboliques cycliques %s."

#: src/copy.c:1346
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: peut créer des liens symboliques relatifs\n"
"seulement que dans le répertoire courant."

#: src/copy.c:1353
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "ne peut créer un lien symbolique %s vers %s"

#: src/copy.c:1364
#, c-format
msgid "cannot create link %s"
msgstr "ne peut créer le lien %s"

#: src/copy.c:1389 src/mkfifo.c:133
#, c-format
msgid "cannot create fifo %s"
msgstr "ne peut créer le fifo %s"

#: src/copy.c:1403
#, c-format
msgid "cannot create special file %s"
msgstr "ne peut créer le fichier spécial %s"

#: src/copy.c:1415 src/ls.c:2493 src/stat.c:426
#, c-format
msgid "cannot read symbolic link %s"
msgstr "ne peut lire le lien symbolique %s"

#: src/copy.c:1440
#, c-format
msgid "cannot create symbolic link %s"
msgstr "ne peut créer le lien symbolique %s"

#: src/copy.c:1456 src/copy.c:1519 src/cp.c:339
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "échec de préservation du propriétaire pour %s"

#: src/copy.c:1471
#, c-format
msgid "%s has unknown file type"
msgstr "%s possède un type de fichier inconnu."

#: src/copy.c:1506
#, c-format
msgid "preserving times for %s"
msgstr "préservation des dates pour %s"

#: src/copy.c:1531
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "échec de préservation du propriétaire pour %s"

#: src/copy.c:1549
#, c-format
msgid "setting permissions for %s"
msgstr "initialisation des permissions de %s"

#: src/copy.c:1571 src/ln.c:326
#, c-format
msgid "cannot un-backup %s"
msgstr "ne peut désarchiver %s"

#: src/copy.c:1575
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (désarchivage)\n"

#: src/cp.c:53
msgid "Torbjorn Granlund, David MacKenzie, and Jim Meyering"
msgstr "Torbjorn Granlund, David MacKenzie et Jim Meyering"

#: src/cp.c:164 src/mv.c:311
#, c-format
msgid ""
"Usage: %s [OPTION]... SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... --target-directory=DIRECTORY SOURCE...\n"
msgstr ""
"Usage: %s [OPTION]... SOURCE CIBLE\n"
"  ou:  %s [OPTION]... SOURCE... RÉPERTOIRE\n"
"  ou:  %s [OPTION]... --target-directory=RÉPERTOIRE SOURCE...\n"

#: src/cp.c:170
msgid ""
"Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"Copier la SOURCE vers la DESTINATION, ou de multiples SOURCES vers un "
"RÉPERTOIRE.\n"
"\n"

#: src/cp.c:174 src/csplit.c:1505 src/cut.c:182 src/df.c:717 src/du.c:179
#: src/expand.c:119 src/fmt.c:277 src/fold.c:76 src/head.c:98
#: src/install.c:609 src/kill.c:103 src/ln.c:354 src/ls.c:3767 src/mkdir.c:66
#: src/mkfifo.c:60 src/mknod.c:61 src/mv.c:321 src/nl.c:185 src/paste.c:413
#: src/pr.c:2763 src/ptx.c:1867 src/shred.c:166 src/sort.c:286 src/split.c:105
#: src/tac.c:136 src/tail.c:244 src/touch.c:249 src/unexpand.c:384
#: src/uniq.c:148
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Les arguments obligatoires pour les options de formes longues le sont aussi\n"
"pour les options de formes courtes.\n"

#: src/cp.c:177
msgid ""
"  -a, --archive                same as -dpR\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=link\n"
msgstr ""
"  -a, --archive                identique à -dpR\n"
"      --backup[=CONTRÔLE]      archiver chaque fichier de destination\n"
"  -b                           identique à --backup mais sans argument\n"
"      --copy-contents          copier le contenu des fichier spéciaux en "
"mode récursif\n"
"  -d                           identique à --no-dereference --preserve=link\n"

#: src/cp.c:184
msgid ""
"      --no-dereference         never follow symbolic links\n"
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again\n"
"  -i, --interactive            prompt before overwrite\n"
"  -H                           follow command-line symbolic links\n"
msgstr ""
"      --no-dereference         ne pas suivre les liens symboliques\n"
"  -f, --force                  si un fichier de destination existe et \n"
"                               ne peut être ouvert alors le détruire et\n"
"                               essayer à nouveau\n"
"  -i, --interactive            demander confirmation avant d'écraser\n"
"  -H                           suivre les liens symboliques de la ligne de "
"commande\n"

#: src/cp.c:191
msgid ""
"  -l, --link                   link files instead of copying\n"
"  -L, --dereference            always follow symbolic links\n"
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: links, all\n"
msgstr ""
"  -l, --link                   faire des liens sur les fichiers au lieu de "
"les copier\n"
"  -L, --dereference            toujours suivres les liens symboliques\n"
"  -p                           identique à --preserve=mode,ownership,"
"timestamps\n"
"      --preserve[=ATTR_LIST]   préserver les attributts spécifiques (par "
"défaut:\n"
"                                 mode,ownership,timestamps), et si "
"posssible\n"
"                                 les attributs additionels: links, all\n"

#: src/cp.c:199
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                append source path to DIRECTORY\n"
"  -P                           same as `--no-dereference'\n"
msgstr ""
"      --no-preserve=LISTE_ATTR ne pas préserver les attributs spécifiques\n"
"      --parents                accoler le chemin source au répertoire\n"
"  -P                           identique à « --no-dereference »\n"

#: src/cp.c:204
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -r, -r, --recursive          copier récursivement les répertoires\n"
"      --remove-destination     enlever chaque fichier de destination "
"existant\n"
"                               avant de l'ouvrir (par contraste avec --"
"force)\n"

#: src/cp.c:209
msgid ""
"      --reply={yes,no,query}   specify how to handle the prompt about an\n"
"                                 existing destination file\n"
"      --sparse=WHEN            control creation of sparse files\n"
"      --strip-trailing-slashes remove any trailing slashes from each SOURCE\n"
"                                 argument\n"
msgstr ""
"      --reply={yes,no,query}   spécifier comment traiter les requêtes à "
"propos\n"
"                               d'un fichier de destination existant\n"
"      --sparse=DATE            contrôler la DATE de création des fichiers\n"
"                               dispersés\n"
"      --strip-trailing-slashes enlever les « / » en suffixe de chacun\n"
"                               des arguments SOURCE\n"

#: src/cp.c:216
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"      --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
msgstr ""
"  -s, --symbolic-link        créer des liens symboliques au lieu de copier\n"
"  -S, --suffix=SUFFIXE       écraser le suffixe usuel d'archivage\n"
"                             par le SUFFIXE\n"
"      --target-directory=RÉPERTOIRE\n"
"                             déplacer tous les fichiers SOURCE en arguments\n"
"                             vers le RÉPERTOIRE\n"

#: src/cp.c:221
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 déplacer seulement les vieux ou\n"
"                               les tout nouveaux fichiers\n"
"  -v, --verbose                expliquer ce qui a été fait\n"
"  -x, --one-file-system        demeurer sur ce système de fichiers\n"

#: src/cp.c:230
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
"\n"
msgstr ""
"\n"
"Par défaut, les fichiers SOURCES dispersés sont détectés par le biais\n"
"d'une heuristique grossière et le fichier CIBLE correspondant est aussi\n"
"construit de façon dispersé.  Il s'agit d'un comportement sélectionné\n"
"par l'option --sparse=auto.  Spécifiez --sparse=always pour créer un "
"fichier\n"
"CIBLE dispersé lorsque le fichier SOURCE contient de longues séquences de\n"
"d'octets de valeur zéro.\n"
"Utilisez --sparse=never pour inhiber la création de fichiers dispersés.\n"
"\n"

#: src/cp.c:239
msgid ""
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"Le suffixe d'archive est « ~ », initialisé autrement avec --suffix ou\n"
"SIMPLE_BACKUP_SUFFIX.  La méthode du contrôle de version peut être "
"sélectionné\n"
"par l'option --backup ou par VERSION_CONTROL par le bias des variables\n"
"d'environnement selon les valeurs suivantes:\n"
"\n"

#: src/cp.c:245 src/install.c:642 src/ln.c:384 src/mv.c:355
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       ne jamais archiver (même si --backup est utilisé)\n"
"  numbered, t     faire des archives numérotées\n"
"  existing, nil   numéroter si des archives  numérotées existent déjà,\n"
"                  ne pas numéroter autrement\n"
"  simple, never   toujours faire des archives de type simple\n"

#: src/cp.c:251
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"Un cas spécial où « cp » archive la SOURCE lorsque les options « force » et\n"
"« backup » sont utilisées et que la SOURCE et la DESTINATION portent le\n"
"même nom qu'un fichier régulier existant.\n"

#: src/cp.c:325
#, c-format
msgid "failed to preserve times for %s"
msgstr "échec de préservation des dates pour %s"

#: src/cp.c:349
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "échec de préservation des permissions de %s"

#: src/cp.c:434
#, c-format
msgid "cannot make directory %s"
msgstr "ne peut créer le répertoire %s"

#: src/cp.c:493 src/ln.c:490 src/mv.c:459 src/shred.c:1601
msgid "missing file argument"
msgstr "argument fichier manquant"

#: src/cp.c:498
msgid "missing destination file"
msgstr "fichier cible manquant"

#: src/cp.c:523 src/ln.c:161 src/ln.c:183 src/ln.c:210 src/ln.c:297
#, c-format
msgid "accessing %s"
msgstr "accès de %s"

#: src/cp.c:546
#, c-format
msgid "%s: specified target is not a directory"
msgstr "%s: cible spécifiée mais n'est pas un répertoire"

#: src/cp.c:554
#, c-format
msgid "copying multiple files, but last argument %s is not a directory"
msgstr ""
"Lors de la copie de plusieurs fichiers:\n"
"le dernier argument %s n'est pas un répertoire."

#: src/cp.c:652
msgid "when preserving paths, the destination must be a directory"
msgstr ""
"Lors de la préservation des chemins: \n"
"la destination doit être un répertoire."

#: src/cp.c:878 src/install.c:219 src/ln.c:434 src/mv.c:405
#, c-format
msgid ""
"warning: --version-control (-V) is obsolete;  support for it\n"
"will be removed in some future release.  Use --backup=%s instead."
msgstr ""
"AVERTISSEMENT: --version-control (-V) est obsolète; son soutien\n"
"sera retiré dans une prochaine version. Utiliser --backup=%s à la place."

#: src/cp.c:972 src/ln.c:464
msgid "symbolic links are not supported on this system"
msgstr "les liens symboliques ne sont supportés sur ce système"

#: src/cp.c:1008
msgid "cannot make both hard and symbolic links"
msgstr "Ne peut créer à la fois un lien symbolique et direct."

#: src/cp.c:1016 src/install.c:275 src/ln.c:530 src/mv.c:483
msgid "backup type"
msgstr "type d'archive"

#: src/csplit.c:41
msgid "Stuart Kemp and David MacKenzie"
msgstr "Stuart Kemp et David MacKenzie"

#: src/csplit.c:289 src/csplit.c:1481 src/tac-pipe.c:57 src/tee.c:220
#: src/tr.c:1609 src/tr.c:1711 src/tr.c:1754
msgid "read error"
msgstr "Erreur de lecture."

#: src/csplit.c:583
msgid "input disappeared"
msgstr "L'entrée est disparue."

#: src/csplit.c:705 src/csplit.c:716
#, c-format
msgid "%s: line number out of range"
msgstr "%s: numéro de ligne hors plage."

#: src/csplit.c:743
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: « %s »: numéro de ligne hors plage."

#: src/csplit.c:746 src/csplit.c:792
#, c-format
msgid " on repetition %d\n"
msgstr " par répétition %d\n"

#: src/csplit.c:788
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: « %s »: concordance non trouvée."

#: src/csplit.c:849 src/csplit.c:889 src/tac.c:262
msgid "error in regular expression search"
msgstr "Erreur dans l'expression régulière recherchée."

#: src/csplit.c:992
#, c-format
msgid "write error for `%s'"
msgstr "Erreur d'écriture sur « %s »"

#: src/csplit.c:1064
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: « + » ou « - » attendu après le délimiteur."

#: src/csplit.c:1068
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: entier attendu après « %c »"

#: src/csplit.c:1088
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: « } » est requis pour un compteur de répétition."

#: src/csplit.c:1098
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: entier requis entre « { » et « } »"

#: src/csplit.c:1125
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: délimiteur de fermeture « %c » manquant."

#: src/csplit.c:1141
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: expression régulière invalide: %s"

#: src/csplit.c:1174
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: patron invalide."

#: src/csplit.c:1177
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: le numéro de ligne doit être plus grand que zéro."

#: src/csplit.c:1183
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "le numéro de ligne « %s » est plus petit que le numéro précédent %s"

#: src/csplit.c:1189
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "AVERTISSEMENT: le numéro de ligne « %s » est le même que le précédent."

#: src/csplit.c:1314
msgid "missing conversion specifier in suffix"
msgstr "Symbole de conversion manquant dans le suffixe."

#: src/csplit.c:1320
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "Le symbole de conversion %c est invalide dans le suffixe."

#: src/csplit.c:1323
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "Le symbole de conversion \\%.3o est invalide dans le suffixe."

#: src/csplit.c:1355
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "La spéfication de conversion %% est manquante dans le suffixe."

#: src/csplit.c:1358
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "Trop de spécifications  %% de conversion dans le suffixe."

#: src/csplit.c:1441
#, c-format
msgid "%s: invalid number"
msgstr "%s: nombre invalide."

#: src/csplit.c:1496
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Usage: %s [OPTION]... FICHIER  PATRON...\n"

#: src/csplit.c:1500
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"Produire des morceaux de FICHIER séparées par PATRON(s) vers les fichiers\n"
"« xx01 », « xx02 », ... et le nombre d'octets de chaque morceau sur la "
"sortie standard.\n"
"\n"

#: src/csplit.c:1508
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=FORMAT utiliser sprintf FORMAT au lieu de %d\n"
"  -f, --prefix=PRÉFIXE       utiliser le PRÉFIXE au lieu de « xx »\n"
"  -k, --keep-files           ne pas détruire les fichiers \n"
"                              lorsqu'il y a erreur\n"

#: src/csplit.c:1513
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=NOMBRE        utiliser NOMBRE de chiffres au lieu de 2\n"
"  -s, --quiet, --silent      ne pas afficher la taille des fichiers\n"
"                             de sortie\n"
"  -z, --elide-empty-files    détruire les fichiers de sortie vides\n"

#: src/csplit.c:1520
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"Lire de l'entrée standard si le FICHIER est -.  Chaque PATRON peut être:\n"

#: src/csplit.c:1524
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  ENTIER             copier jusqu'à mais sans inclure le nombre spécifiée\n"
"                     de lignes\n"
"  /REGEXP/[SAUT]     copier jusqu'à la détection d'une ligne identique\n"
"                     mais sans l'inclure\n"
"  %%REGEXP%%[SAUT]     escamoter jusqu'à, mais sans inclure une\n"
"                     ligne identique\n"
"  {ENTIER}           répéter le patron précédent un nombre de fois\n"
"  {*}                répéter le patron précédent le plus souvent possible\n"
"\n"
"Une ligne de SAUT a besoin d'un « + » ou « - » suivi d'un entier positif.\n"

#: src/cut.c:39
msgid "David Ihnat, David MacKenzie, and Jim Meyering"
msgstr "David Ihnat, David MacKenzie et Jim Meyering"

#: src/cut.c:174 src/df.c:711 src/du.c:174 src/expand.c:110 src/fold.c:67
#: src/head.c:88 src/ls.c:3761 src/nl.c:176 src/paste.c:403 src/pr.c:2754
#: src/sort.c:276 src/sum.c:60 src/tac.c:127 src/tail.c:234 src/tee.c:63
#: src/unexpand.c:375 src/wc.c:125
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#: src/cut.c:178
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr ""
"Afficher des parties de lignes de chaque FICHIER vers la sortie standard.\n"
"\n"

#: src/cut.c:185
msgid ""
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=LISTE       afficher seulement la LISTE des octets\n"
"  -c, --characters=LISTE  afficher seulement la LISTE des caractères\n"
"  -d, --delimiter=DÉLIM   utiliser le DÉLIMiteur au lieu d'une tabulation\n"
"                          comme délimiteur de champs\n"

#: src/cut.c:190
msgid ""
"  -f, --fields=LIST       output only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=LISTE      afficher seulement la LISTE des champs; afficher "
"aussi\n"
"                          les lignes qui ne contiennent pas de caractère "
"délimiteur,\n"
"                          à moins que l'option -s soit spécifiée\n"
"  -n                      (ignoré)\n"

#: src/cut.c:196
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    ne pas afficher les lignes ne\n"
"                          contenant pas de délimiteurs\n"
"      --output-delimiter=CHAÎNE\n"
"                          utiliser la CHAÎNE comme délimiteur de sortie\n"
"                          par défaut le délimiteur de l'entrée est utilisée\n"

#: src/cut.c:203
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Utiliser une seule des options -b, -c ou -f.  Chaque LISTE se compose d'une\n"
"intervalle, ou de plusieurs séparées par des virgules.  Chaque intervalle\n"
"se compose de:\n"
"\n"
"  N     Nième octet, caractère ou champ, compté à partir de 1\n"
"  N-    du Nième octet, caractère ou champ, jusqu'à la fin de la ligne\n"
"  N-M   du Nième au Mième (inclus) octet, caractère ou champ\n"
"  -M    du premier au Mième (inclus) octet, caractère ou champ\n"
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/cut.c:288 src/cut.c:319 src/cut.c:379
msgid "invalid byte or field list"
msgstr "Octet ou champ de liste invalide."

#: src/cut.c:667 src/cut.c:676
msgid "only one type of list may be specified"
msgstr "Un seul type de liste peut être spécifié."

#: src/cut.c:670
msgid "missing list of positions"
msgstr "Liste des positions manquante."

#: src/cut.c:679
msgid "missing list of fields"
msgstr "Liste des champs manquante."

#: src/cut.c:686
msgid "the delimiter must be a single character"
msgstr "Le délimiteur doit être un caractère simple."

#: src/cut.c:717
msgid "you must specify a list of bytes, characters, or fields"
msgstr "Une liste d'octets, de caractères, ou de champs doit être spécifiée."

#: src/cut.c:720
msgid "an input delimiter may be specified only when operating on fields"
msgstr ""
"un délimiteur peut être spécifié seulement lorsqu'opérant sur des champs"

#: src/cut.c:724
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"La suppression des lignes non-délimitées est permise\n"
"\tseulement lorsqu'opérant sur des champs."

#: src/date.c:117
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMJJhhmm[[CC]AA][.ss]]\n"

#: src/date.c:122
msgid ""
"Display the current time in the given FORMAT, or set the system date.\n"
"\n"
"  -d, --date=STRING         display time described by STRING, not `now'\n"
"  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
"  -ITIMESPEC, --iso-8601[=TIMESPEC]  output date/time in ISO 8601 format.\n"
"                            TIMESPEC=`date' for date only,\n"
"                            `hours', `minutes', or `seconds' for date and\n"
"                            time to the indicated precision.\n"
"                            --iso-8601 without TIMESPEC defaults to `date'.\n"
msgstr ""
"Afficher la date courante selon le FORMAT spécifié, ou\n"
"initialiser la date du système.\n"
"\n"
"  -d, --date=CHAÎNE        afficher la date selon la description donnée par "
"la CHAÎNE,\n"
"                           excluant le mot réservé « now »\n"
"  -f, --file=FICHIER       identique à --date pour chaque ligne du\n"
"                           FICHIER de dates\n"
"  -ITIMESPEC, --iso-8601[=SPECS-TEMPS]\n"
"                           produire un format de sortie date/heure selon la "
"norme ISO-8601\n"
"                           SPECS-TEMPS=« date » pour la date seulement,\n"
"                           « hours », « minutes » ou « seconds » pour la "
"date et l'heure\n"
"                           à la précision voulue\n"
"                            --iso-8601 sans TIMESPEC par défaut utilise « "
"date ».\n"

#: src/date.c:133
msgid ""
"  -r, --reference=FILE      display the last modification time of FILE\n"
"  -R, --rfc-822             output RFC-822 compliant date string\n"
"  -s, --set=STRING          set time described by STRING\n"
"  -u, --utc, --universal    print or set Coordinated Universal Time\n"
msgstr ""
"  -r, --reference=FICHIER  utiliser la date de modification du FICHIER\n"
"                           comme date de référence\n"
"  -R, --rfc-822            afficher la date selon le format respectant\n"
"                           les spécifications du RFC-822\n"
"  -s, --set=FORMAT         initialiser la date selon le FORMAT décrit\n"
"  -u, --utc, --universal   afficher ou initialiser selon le système de\n"
"                           temps universel (T.U.)\n"

#: src/date.c:141
msgid ""
"\n"
"FORMAT controls the output.  The only valid option for the second form\n"
"specifies Coordinated Universal Time.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (Sun..Sat)\n"
msgstr ""
"\n"
"FORMAT contrôle l'affichage.  Seule l'option valide de la seconde forme\n"
"s'applique au système de temps UCT.  Les séquences interprétées sont:\n"
"\n"
"  %%   le caractère %\n"
"  %a   les noms abrégés localisés des jours de la semaine (Dim..Sam)\n"

#: src/date.c:149
msgid ""
"  %A   locale's full weekday name, variable length (Sunday..Saturday)\n"
"  %b   locale's abbreviated month name (Jan..Dec)\n"
"  %B   locale's full month name, variable length (January..December)\n"
"  %c   locale's date and time (Sat Nov 04 12:02:33 EST 1989)\n"
msgstr ""
"  %A   les noms complets localisés des jours de la semaine\n"
"       de longueurs variables (Dimanche..Samedi)\n"
"  %b   les noms abrégés localisés des mois (Jan..Déc)\n"
"  %B   les noms complets localisés des mois de longueurs variables\n"
"       (Janvier..Décembre)\n"
"  %c   la date et l'heure localisées (Sam 04 Nov 12:02:33 EDT 1989)\n"

#: src/date.c:155
msgid ""
"  %C   century (year divided by 100 and truncated to an integer) [00-99]\n"
"  %d   day of month (01..31)\n"
"  %D   date (mm/dd/yy)\n"
"  %e   day of month, blank padded ( 1..31)\n"
msgstr ""
"  %C   le siècle (année divisée par 100 et tronquée en un entier) [00-99]\n"
"  %d   jour du mois (01..31)\n"
"  %D   date (mm/jj/aa)\n"
"  %e   jour du mois, précédé d'un blanc ( 1..31)\n"

#: src/date.c:161
msgid ""
"  %F   same as %Y-%m-%d\n"
"  %g   the 2-digit year corresponding to the %V week number\n"
"  %G   the 4-digit year corresponding to the %V week number\n"
msgstr ""
"  %F   identique à %Y-%m-%d\n"
"  %g   l'année sur 2 chiffres correspondant à au numéro de semaine %V\n"
"  %G   l'année sur 4 chiffres correspondant à au numéro de semaine %V\n"

#: src/date.c:166
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   identique à %%b\n"
"  %H   heure (00..23)\n"
"  %I   heure (01..12)\n"
"  %j   jour numérique de l'année (001..366)\n"

#: src/date.c:172
msgid ""
"  %k   hour ( 0..23)\n"
"  %l   hour ( 1..12)\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   heure ( 0..23)\n"
"  %l   heure ( 1..12)\n"
"  %m   mois (01..12)\n"
"  %M   minute (00..59)\n"

#: src/date.c:178
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's upper case AM or PM indicator (blank in many locales)\n"
"  %P   locale's lower case am or pm indicator (blank in many locales)\n"
"  %r   time, 12-hour (hh:mm:ss [AP]M)\n"
"  %R   time, 24-hour (hh:mm)\n"
"  %s   seconds since `00:00:00 1970-01-01 UTC' (a GNU extension)\n"
msgstr ""
"  %n   un saut de ligne\n"
"  %N   nanosecondes (000000000..999999999)\n"
"  %p   indicateur localisé AM ou PM en majuscules (blanc dans plusieurs "
"localisations)\n"
"  %P   indicateur localisé am ou pm en minuscules (blanc dans plusieurs "
"localisations)\n"
"  %r   heure en format 12-heure (hh:mm:ss [AP]M)\n"
"  %r   heure en format 24-heure (hh:mm)\n"
"  %s   secondes depuis « 00:00:00, 1970-01-01 UTC » (une extension de GNU)\n"

#: src/date.c:187
msgid ""
"  %S   second (00..60); the 60 is necessary to accommodate a leap second\n"
"  %t   a horizontal tab\n"
"  %T   time, 24-hour (hh:mm:ss)\n"
"  %u   day of week (1..7);  1 represents Monday\n"
msgstr ""
"  %S   secondes (00..60); le 60 est nécessaire pour accomoder la sec. "
"bissextile\n"
"  %t   une tabulation horizontale\n"
"  %T   heure, 24-heure (hh:mm:ss)\n"
"  %u   jour de la semaine (1..7);  1 représente Lundi\n"

#: src/date.c:193
msgid ""
"  %U   week number of year with Sunday as first day of week (00..53)\n"
"  %V   week number of year with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6);  0 represents Sunday\n"
"  %W   week number of year with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   numéro de la semaine dans l'année débutant par Dimanche\n"
"       comme premier jour de la semaine (00..53)\n"
"  %V   numéro de la semaine dans l'année débutant par Lundi\n"
"       comme premier jour de la semaine (01..52)\n"
"  %w   jour de la semaine (0..6);  0 représente Dimanche\n"
"  %W   numéro de la samaine dans l'année débutant par Lundi\n"
"        comme premier jour de la semaine (00..53)\n"

#: src/date.c:199
msgid ""
"  %x   locale's date representation (mm/dd/yy)\n"
"  %X   locale's time representation (%H:%M:%S)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year (1970...)\n"
msgstr ""
"  %x   représentation localisée de la date (mm/jj/aa)\n"
"  %X   représentation localisée de l'heure (%%H:%%M:%%S)\n"
"  %y   les deux derniers chiffres de l'année (00..99)\n"
"  %Y   année (1970...)\n"

#: src/date.c:205
msgid ""
"  %z   RFC-822 style numeric timezone (-0500) (a nonstandard extension)\n"
"  %Z   time zone (e.g., EDT), or nothing if no time zone is determinable\n"
"\n"
"By default, date pads numeric fields with zeroes.  GNU date recognizes\n"
"the following modifiers between `%' and a numeric directive.\n"
"\n"
"  `-' (hyphen) do not pad the field\n"
"  `_' (underscore) pad the field with spaces\n"
msgstr ""
"  %z   fuseau horaire en format numérique selon le RFC-822 (-0500)\n"
"       (une extension non-standard)\n"
"  %Z   fuseau horaire (i.e. EDT), nul si aucun fuseau horaire\n"
"       ne peut être déterminé\n"
"\n"
"Par défaut, les champs numériques de date sont complétés par des zéros.\n"
"GNU reconnaît les modificateurs suivants entre « % » et une directive "
"numérique.\n"
"\n"
"  « - » (tiret) ne pas compléter le champ\n"
"  « _ » (souligné) compléter le champ par des blancs\n"

#: src/date.c:237 src/dd.c:1173 src/dircolors.c:539 src/head.c:221
#: src/md5sum.c:340 src/md5sum.c:681 src/od.c:959 src/od.c:2001 src/pr.c:1164
#: src/pr.c:1371 src/pr.c:1493 src/stty.c:909 src/tac.c:483 src/tac.c:489
#: src/tee.c:151 src/tr.c:2027 src/tsort.c:585
msgid "standard input"
msgstr "entrée standard"

#: src/date.c:268 src/date.c:460
#, c-format
msgid "invalid date `%s'"
msgstr "date invalide « %s »"

#: src/date.c:364
msgid "the options to specify dates for printing are mutually exclusive"
msgstr ""
"les options pour spécifier les dates pour l'impression sont mutuellement "
"exclusives"

#: src/date.c:371
msgid "the options to print and set the time may not be used together"
msgstr ""
"Les options pour afficher et initialiser la date ne peuvent être\n"
"utilisées ensembles."

#: src/date.c:377
#, c-format
msgid "too many non-option arguments: %s%s"
msgstr "trop d'arguments sont des options non reconnues: %s%s"

#: src/date.c:385
#, c-format
msgid ""
"the argument `%s' lacks a leading `+';\n"
"When using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with `+'."
msgstr ""
"l'argument « %s » n'est pas précédé du préfixe « + »;\n"
"lors de l'utilisation d'une option pour spécifier la date,\n"
"chaque argument qui n'est pas une option reconnue doit être\n"
"une chaîne dont le format débute par « + »."

#: src/date.c:397
msgid ""
"a format string may not be specified when using the --rfc-822 (-R) option"
msgstr ""
"une chaîne de format ne peut être spécifié lorsque l'option --rfc-822 (-R) "
"est utilisée"

#: src/date.c:433
msgid "undefined"
msgstr "Indéfini"

#: src/date.c:435
msgid "cannot get time of day"
msgstr "ne peut obtenir la date du jour"

#: src/date.c:468
msgid "cannot set date"
msgstr "ne peut initialiser la date."

#: src/dd.c:43
msgid "Paul Rubin, David MacKenzie, and Stuart Kemp"
msgstr "Paul Rubin, David MacKenzie et Stuart Kemp"

#: src/dd.c:288 src/tty.c:62 src/uname.c:110 src/whoami.c:52
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Usage: %s [OPTION]...\n"

#: src/dd.c:289
msgid ""
"Copy a file, converting and formatting according to the options.\n"
"\n"
"  bs=BYTES        force ibs=BYTES and obs=BYTES\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=KEYWORDS   convert the file as per the comma separated keyword list\n"
"  count=BLOCKS    copy only BLOCKS input blocks\n"
"  ibs=BYTES       read BYTES bytes at a time\n"
msgstr ""
"Copier un fichier, en le convertissant et le formatant selon les options:\n"
"\n"
"  bs=N            forcer ibs=N octets et obs=N octets\n"
"  cbs=N           convertir N octets à la fois\n"
"  conv=CLÉS       convertir le fichier selon les mots CLÉS d'une liste\n"
"                  séparés par une virgule\n"
"  count=N         copier seulement N blocs à partir de l'entrée\n"
"  ibs=N           lire N octets à la fois\n"

#: src/dd.c:298
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  obs=BYTES       write BYTES bytes at a time\n"
"  of=FILE         write to FILE instead of stdout\n"
"  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output\n"
"  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input\n"
msgstr ""
"  if=FICHIER      lire à partir du FICHIER au lieu de l'entrée standard\n"
"  obs=N           écrire N octets à la fois\n"
"  of=FICHIER      écrire dans le FICHIER au lieu de la sortie standard\n"
"  seek=N          escamoter N blocs de taille « obs » du fichier de sortie\n"
"  skip=N          escamoter N blocs de taille « ibs » du fichier d'entrée\n"

#: src/dd.c:307
msgid ""
"\n"
"BLOCKS and BYTES may be followed by the following multiplicative suffixes:\n"
"xM M, c 1, w 2, b 512, kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n"
"GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y.\n"
"Each KEYWORD may be:\n"
"\n"
msgstr ""
"\n"
"N peut être suivi d'un suffixe multiplicatif suivant:,\n"
"xM M, c 1, w 2, b 512, kD 1000, K 1024, MB 1,000,000, M 1,048,576,\n"
"GD 1,000,000,000, G 1,073,741,824, et ainsi de suite pour T, P, E, Z, Y.\n"
"Chaque mot CLÉ peut être:\n"
"\n"

#: src/dd.c:315
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternated EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
msgstr ""
"  ascii     de l'EBCDIC vers l'ASCII\n"
"  ebcdic    de l'ASCII  vers l'EBCDIC\n"
"  ibm       de l'ASCII  vers l'EBCDIC en utilisant une table différente\n"
"  block     remplir les enregistrements terminés par un saut de ligne\n"
"            par des blancs jusqu'à l'obtention de la taille « cbs »\n"
"  unblock   remplacer les blancs de la fin des enregistrements\n"
"            de taille « cbs » par des sauts de ligne\n"
"  lcase     changer les majuscules en minuscules\n"

#: src/dd.c:323
msgid ""
"  notrunc   do not truncate the output file\n"
"  ucase     change lower case to upper case\n"
"  swab      swap every pair of input bytes\n"
"  noerror   continue after read errors\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"              with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  notrunc   ne pas tronquer le fichier de sortie\n"
"  ucase     changer les minuscules en majuscules\n"
"  swab      interchanger chaque paire d'octets\n"
"  noerror   continuer même après des erreurs de lecture\n"
"  sync      remplir chaque bloc lu par des nuls jusqu'à concurrence\n"
"            de la taille « ibs »\n"

#: src/dd.c:362
#, c-format
msgid "%s+%s records in\n"
msgstr "%s+%s enregistrements lus.\n"

#: src/dd.c:364
#, c-format
msgid "%s+%s records out\n"
msgstr "%s+%s enregistrements écrits.\n"

#: src/dd.c:371
msgid "truncated record"
msgstr "enregistrement tronqué."

#: src/dd.c:372
msgid "truncated records"
msgstr "enregistrements tronqués."

#: src/dd.c:382
#, c-format
msgid "closing input file %s"
msgstr "fermeture du fichier d'entrée %s"

#: src/dd.c:385
#, c-format
msgid "closing output file %s"
msgstr "fermeture du fichier de sortie %s"

#: src/dd.c:469
#, c-format
msgid "writing to %s"
msgstr "écriture vers %s"

#: src/dd.c:501
#, c-format
msgid "invalid conversion: %s"
msgstr "conversion invalide: %s"

#: src/dd.c:557
#, c-format
msgid "unrecognized option %s"
msgstr "option non reconnue %s"

#: src/dd.c:610
#, c-format
msgid "unrecognized option %s=%s"
msgstr "option non reconnue %s=%s"

#: src/dd.c:616
#, c-format
msgid "invalid number %s"
msgstr "nombre invalide %s"

#: src/dd.c:646
msgid ""
"only one conv in {ascii,ebcdic,ibm}, {lcase,ucase}, {block,unblock}, "
"{unblock,sync}"
msgstr ""
"Un seul type de conversion est autorisé parmi {ascii,ebcdic,ibm},\n"
"{lcase,ucase}, {block,unblock}, {unblock,sync}"

#: src/dd.c:781
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"AVERTISSEMENT: arrangement pour contourner bug de lseek dans le kernel \n"
"pour le fichier (%s)\n"
"de type mt_type=0x%0lx -- voir <sys/mtio.h> pour la liste des types"

#: src/dd.c:1170 src/dd.c:1188
#, c-format
msgid "opening %s"
msgstr "ouverture de %s"

#: src/dd.c:1196
msgid "file offset out of range"
msgstr "décalage dans le fichier est hors gamme"

#: src/dd.c:1214
#, c-format
msgid "advancing past %s bytes in output file %s"
msgstr "a dépassé de %s octets dans le fichier de sortie %s"

#: src/df.c:49
msgid "Torbjorn Granlund, David MacKenzie, Larry McVoy, and Paul Eggert"
msgstr "Torbjorn Granlund, David MacKenzie, Larry McVoy et Paul Eggert"

#: src/df.c:153
msgid "Filesystem    Type"
msgstr "Sys. de fich. Type "

#: src/df.c:155
msgid "Filesystem        "
msgstr "Sys. de fich.     "

#: src/df.c:158
#, c-format
msgid "    Inodes   IUsed   IFree IUse%%"
msgstr "    Inodes   IUtil.  ILib. %%IUti."

#: src/df.c:162
#, c-format
msgid "    Size  Used Avail Use%%"
msgstr "    Tail. Occ. Disp. %%Occ."

#: src/df.c:164
#, c-format
msgid "     Size   Used  Avail Use%%"
msgstr "     Tail.  Occ.  Disp. %%Occ."

#: src/df.c:167
#, c-format
msgid " %4s-blocks      Used Available Capacity"
msgstr " %4s-blocs    Occupé Disponible Capacité"

#: src/df.c:198
#, c-format
msgid " %4s-blocks      Used Available Use%%"
msgstr " %4s-blocs       Occupé Disponible Capacité"

#: src/df.c:202
msgid " Mounted on\n"
msgstr " Monté sur\n"

#: src/df.c:712
msgid ""
"Show information about the filesystem on which each FILE resides,\n"
"or all filesystems by default.\n"
"\n"
msgstr ""
"Afficher les informations à propos du système de fichiers sur lequel\n"
"réside chaque FICHIER ou de tous les systèmes de fichiers par défaut.\n"
"\n"

#: src/df.c:720
msgid ""
"  -a, --all             include filesystems having 0 blocks\n"
"  -B, --block-size=SIZE use SIZE-byte blocks\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"  -H, --si              likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -a, --all               inclure les systèmes de fichiers ayant 0 bloc\n"
"  -B, --block-size=TAILLE utiliser la TAILLE de blocs\n"
"  -h, --human-readable    afficher les tailles dans un format lisible par\n"
"                          un humain (i.e. 1K 234M 2G)\n"
"  -H, --si                idem mais utiliser un multiple de 1000\n"
"                          au lieu de 1024\n"

#: src/df.c:726
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local filesystems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes            lister les informations sur les « inodes »\n"
"                          plutôt que sur l'utilisation des blocs\n"
"  -k                      identique à --block-size=1K\n"
"  -l, --local             limiter le listing au système local de fichiers\n"
"      --no-sync           ne pas effectuer une synchronisation avant\n"
"                          d'obtenir les informations d'utilisation\n"
"                          des disques (par défaut)\n"

#: src/df.c:732
msgid ""
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
"  -t, --type=TYPE       limit listing to filesystems of type TYPE\n"
"  -T, --print-type      print filesystem type\n"
"  -x, --exclude-type=TYPE   limit listing to filesystems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -P, --portability       utiliser le format de sortie POSIX\n"
"      --sync              demander une synchronisation avant d'obtenir les\n"
"                          informations d'utilisation des disques\n"
"                          (par défaut)\n"
"  -t, --type=TYPE         limiter l'affichage au TYPE de système de\n"
"                          fichiers\n"
"  -T, --print-type        afficher le type du système de fichiers\n"
"  -x, --exclude-type=TYPE limiter l'affichage en excluant le TYPE\n"
"                          de système de fichiers\n"
"  -v                      (ignorée)\n"

#: src/df.c:742 src/du.c:215 src/ls.c:3879
msgid ""
"\n"
"SIZE may be (or may be an integer optionally followed by) one of following:\n"
"kB 1000, K 1024, MB 1,000,000, M 1,048,576, and so on for G, T, P, E, Z, Y.\n"
msgstr ""
"\n"
"TAILLE peut être (ou peut être un entier suivi par) un de ceux qui suivent:\n"
"kB 1000, K 1024, MB 1000*1000, M 1024*1024, et ainsi de suite pour G, T, P, "
"E, Z, Y.\n"
"\n"

#: src/df.c:859
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "Le système de fichiers %s est à la fois sélectionné et exclu."

#: src/df.c:903
msgid "Warning: "
msgstr "AVERTISSEMENT: "

#: src/df.c:906
#, c-format
msgid "%scannot read table of mounted filesystems"
msgstr "La table du système de fichiers %s ne peut être lue."

#: src/dircolors.c:103
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Usage: %s [OPTION]... [FICHIER]\n"

#: src/dircolors.c:104
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Commande d'affichage pour initialiser la variable d'environnement LS_COLOR.\n"
"\n"
"Déterminer le format de sortie:\n"
"  -b, --sh, --bourne-shell    code de sortie pour un Bourne shell\n"
"                              initialiser la variable LS_COLORS\n"
"  -c, --csh, --c-shell        code de sortie pour un C shell pour\n"
"                              initialiser la variable LS_COLORS\n"
"  -p, --print-data-base       utiliser les valeurs par défaut de sortie\n"

#: src/dircolors.c:114
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run `dircolors --print-database'.\n"
msgstr ""
"\n"
"Si le FICHIER est fourni, le lire pour déterminer les couleurs à utiliser\n"
"pour les types de fichiers et les extensions. Autrement, utiliser la base de "
"données\n"
"précompilés. Pour le détail du format de ces fichiers, exécuter «dircolors --"
"print-database'.\n"

#: src/dircolors.c:299
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: ligne invalide;  second jeton manquant"

#: src/dircolors.c:371
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu: mot clé non reconnu %s"

#: src/dircolors.c:372
msgid "<internal>"
msgstr "<interne>"

#: src/dircolors.c:467
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"les options pour la base de données interne de sortie de dircolors et\n"
"la sélection de la syntaxe du shell sont mutuellement exclusives"

#: src/dircolors.c:475
msgid ""
"no FILE arguments may be used with the option to output\n"
"dircolors' internal database"
msgstr ""
"Aucun argument de FICHIER ne peut être utilisé avec l'option\n"
"pour afficher la base de données interne « dircolors »."

#: src/dircolors.c:504
msgid "no SHELL environment variable, and no shell type option given"
msgstr "Aucune variable de shell et aucune option de mode spécifiée."

#: src/dirname.c:33 src/pathchk.c:59
msgid "David MacKenzie and Jim Meyering"
msgstr "David MacKenzie et Jim Meyering"

#: src/dirname.c:46
#, c-format
msgid ""
"Usage: %s NAME\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s NOM\n"
"  or:  %s OPTION\n"

#: src/dirname.c:51
msgid ""
"Print NAME with its trailing /component removed; if NAME contains no /'s,\n"
"output `.' (meaning the current directory).\n"
"\n"
msgstr ""
"Afficher le NOM du répertoire en enlevant ses composantes de fin;\n"
"si le NOM ne contient pas de « / »\n"
"le symbole « . » indique le répertoire courant.\n"
"\n"

#: src/du.c:49
msgid ""
"Torbjorn Granlund, David MacKenzie, Larry McVoy, Paul Eggert, and Jim "
"Meyering"
msgstr ""
"Torbjorn Granlund, David MacKenzie, Larry McVoy, Paul Eggert et Jim Meyering"

#: src/du.c:175
msgid ""
"Summarize disk usage of each FILE, recursively for directories.\n"
"\n"
msgstr ""
"Produire un sommaire de l'utilisation de l'espace disque de chaque FICHIER,\n"
"et récursivement dans tous les répertoires.\n"

#: src/du.c:182
msgid ""
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in (`sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
"  -B, --block-size=SIZE use SIZE-byte blocks\n"
"  -b, --bytes           equivalent to `--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference FILEs that are symbolic links\n"
msgstr ""
"  -a, --all                afficher le décompte pour tous les fichiers,\n"
"                           pas seulement pour les répertoires\n"
"      --apparent-size      afficher les tailles apparentes, au lieu de "
"l'usage du disque; \n"
"                           même si la taille apparente est habituellement "
"plus petite, elle peut être\n"
"                           plus grande en raison de trous dans (`sparse') "
"les fichiers, \n"
"                           de la fragmentation, de blocs indirects ou autre "
"raisons similaires\n"
"  -B, --block-size=TAILLE  utiliser la TAILLE en octets des blocs\n"
"  -b, --bytes              afficher la taille en octets\n"
"  -c, --total              produire le grand total\n"
"  -D, --dereference-args   ne pas tenir compte des CHEMINS lorsqu'il y a\n"
"                           des liens symboliques\n"

#: src/du.c:193
msgid ""
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"  -H, --si              likewise, but use powers of 1000 not 1024\n"
"  -k                    like --block-size=1K\n"
"  -l, --count-links     count sizes many times if hard linked\n"
msgstr ""
"  -h, --human-readable     afficher les tailles dans un format lisible par\n"
"                           un humain (i.e. 1K 234M 2G)\n"
"  -H, --si                 idem mais utiliser un multiple de 1000\n"
"                           au lieu de 1024\n"
"  -k,                      identique à --block-size=1K\n"
"  -l, --count-links        dénombrer les tailles aussi souvent qu'il y a\n"
"                           de liens directs\n"

#: src/du.c:199
msgid ""
"  -L, --dereference     dereference all symbolic links\n"
"  -S, --separate-dirs   do not include size of subdirectories\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -L, --dereference        ne pas tenir compte de tous les liens\n"
"                           symboliques\n"
"  -S, --separate-dirs      ne pas inclure la taille des sous-répertoires\n"
"  -s, --summarize          afficher seulement un total pour chaque type\n"
"                           d'argument\n"

#: src/du.c:204
msgid ""
"  -x, --one-file-system  skip directories on different filesystems\n"
"  -X FILE, --exclude-from=FILE  Exclude files that match any pattern in "
"FILE.\n"
"      --exclude=PATTERN Exclude files that match PATTERN.\n"
"      --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -x, --one-file-system    escamoter les répertoires de différents\n"
"                           systèmes de fichiers\n"
"  -X FICHIER,               \n"
"      --exclude-from=FICHIER\n"
"                           exclure les fichiers qui concordent avec\n"
"                           le nom du FICHIER\n"
"      --exclude=EXPRES     exclure les fichier qui concordent avec\n"
"                           l'expression\n"
"      --max-depth=N        afficher le total pour un répertoire (ou un\n"
"                           fichier, avec l'option --all) seulement\n"
"                           si N a moins de niveaux dans la ligne de "
"commande;\n"
"                           --max-depth=0 est identique à --summurize\n"
"                           systèmes de fichiers\n"

#: src/du.c:337
#, c-format
msgid "cannot change to parent of directory %s"
msgstr "ne peut aller vers le répertoire parent de %s"

#: src/du.c:345
#, c-format
msgid "cannot change to directory %s"
msgstr "ne peut aller vers le répertoire %s"

#: src/du.c:352
#, c-format
msgid "cannot read directory %s"
msgstr "ne peut lire le répertoire %s"

#: src/du.c:554 src/ls.c:2241 src/wc.c:591
msgid "total"
msgstr "total"

#: src/du.c:641
#, c-format
msgid "invalid maximum depth %s"
msgstr "profondeur maximum invalide %s"

#: src/du.c:707
msgid "cannot both summarize and show all entries"
msgstr "Ne peut afficher à la fois un résumé et toutes les entrées."

#: src/du.c:714
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr ""
"AVERTISSEMENT: le résumé est identique si l'option --max-dept=0 est utilisée"

#: src/du.c:720
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%d"
msgstr ""
"AVERTISSEMENT: conflit de l''option -s pour le résumé avec --max-depth=%d"

#: src/echo.c:77
#, c-format
msgid "Usage: %s [OPTION]... [STRING]...\n"
msgstr "Usage: %s [OPTION]... [CHAÎNE]...\n"

#: src/echo.c:78
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n              do not output the trailing newline\n"
"  -e              enable interpretation of the backslash-escaped characters\n"
"                    listed below\n"
"  -E              disable interpretation of those sequences in STRINGs\n"
msgstr ""
"Faire l'écho de CHAÎNE(S) vers la sortie standard.\n"
"\n"
"  -n             ne pas afficher le saut de ligne de fin\n"
"  -e             (inutilisée)\n"
"  -E             inhiber l'interpolation de certaines séquences de la "
"CHAÎNE\n"

#: src/echo.c:88
msgid ""
"\n"
"Without -E, the following sequences are recognized and interpolated:\n"
"\n"
"  \\NNN   the character whose ASCII code is NNN (octal)\n"
"  \\\\     backslash\n"
"  \\a     alert (BEL)\n"
"  \\b     backspace\n"
msgstr ""
"\n"
"Sans -E, les séquences suivantes sont reconnues et interpolées:\n"
"\n"
"  \\NNN   le caractère dont le code ASCII est NNN (en octal)\n"
"  \\\\     barre oblique inverse\n"
"  \\a     bip sonore d'alerte\n"
"  \\b     retour arrière\n"

#: src/echo.c:97
msgid ""
"  \\c     suppress trailing newline\n"
"  \\f     form feed\n"
"  \\n     new line\n"
"  \\r     carriage return\n"
"  \\t     horizontal tab\n"
"  \\v     vertical tab\n"
msgstr ""
"  \\c     supprimer le saut de ligne de fin\n"
"  \\f     saut de page\n"
"  \\n     saut de ligne\n"
"  \\r     retour de chariot\n"
"  \\t     tabulation horizontale\n"
"  \\v     tabulation verticale\n"

#: src/env.c:93
msgid "Richard Mlynarik and David MacKenzie"
msgstr "Richard Mlynarik et David MacKenzie"

#: src/env.c:119
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "Usage: %s [OPTION]... [-] [NOM=VALEUR]... [COMMANDE] [ARG]...\n"

#: src/env.c:122
msgid ""
"Set each NAME to VALUE in the environment and run COMMAND.\n"
"\n"
"  -i, --ignore-environment   start with an empty environment\n"
"  -u, --unset=NAME           remove variable from the environment\n"
msgstr ""
"Initialiser chaque VARIABLE à la VALEUR dans l'environnement\n"
"et exécuter la COMMANDE.\n"
"\n"
"  -i, --ignore-environment   débuter avec un environnement vide\n"
"  -u, --unset=VARIABLE       retirer la VARIABLE de l'environment\n"

#: src/env.c:130
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Un simple - implique -i.  Si aucune COMMANDE n'est fournie,\n"
"afficher les variables d'environnement.\n"

#: src/expand.c:114
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les tabulations de chaque FICHIER par des blancs d'espacement,\n"
"en écrivant sur la sortie standard.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/expand.c:122
msgid ""
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       ne pas convertir les tabulations après des non blancs\n"
"  -t, --tabs=N        utiliser N caractères de tabulations, et non 8\n"

#: src/expand.c:126
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
"                       de tabulation\n"
"                       séparées par des virgules\n"

#: src/expand.c:173 src/unexpand.c:153
msgid "tab size contains an invalid character"
msgstr "La taille de la tabulation contient un caractère invalide."

#: src/expand.c:191 src/unexpand.c:171
msgid "tab size cannot be 0"
msgstr "La taille de la tabulation ne peut être 0."

#: src/expand.c:193 src/unexpand.c:173
msgid "tab sizes must be ascending"
msgstr "Les tailles de tabulation doivent être croissantes."

#: src/expand.c:386
msgid "`-LIST' option is obsolete; use `-t LIST'"
msgstr "option « -LIST » est obsolète; utiliser « -t LIST »"

#: src/expr.c:90
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"

#: src/expr.c:98
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Afficher la valeur de l'EXPRESSION sur la sortie standard.  Une ligne "
"blanche\n"
"sépare la précédence croissante des groupes. L'EXPRESSION peut être:\n"
"\n"
"  ARG1 | ARG2          ARG1 s'il est nul ou 0, autrement ARG2\n"
"\n"
"  ARG1 & ARG2          ARG1 si aucun des arguments est nul ou 0, autrement "
"0\n"

#: src/expr.c:107
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 <  ARG2         ARG1 si plus petit que ARG2\n"
"  ARG1 <= ARG2         ARG1 si plus petit ou égal à ARG2\n"
"  ARG1 =  ARG2         ARG1 si égal à ARG2\n"
"  ARG1 != ARG2         ARG1 n'est pas égal à ARG2\n"
"  ARG1 >= ARG2         ARG1 si plus grand ou égal à ARG2\n"
"  ARG1 >  ARG2         ARG1 si plus grand que ARG2\n"

#: src/expr.c:116
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       somme arithmétique de ARG1 et ARG2\n"
"  ARG1 - ARG2       différence arithmétique de ARG1 et ARG2\n"

#: src/expr.c:121
#, c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       produit arithmétique de ARG1 et ARG2\n"
"  ARG1 / ARG2       quotient arithmétique de ARG1 divisé par ARG2\n"
"  ARG1 % ARG2       reste arithmétique ARG1 divisé par ARG2\n"

#: src/expr.c:127
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  CHAÎNE: EXPREG   patron d'ancrage de concordance de l'EXPREG dans la "
"CHAÎNE\n"
"\n"
"  match CHAÎNE EXPREG      identique à CHAÎNE: EXPREG\n"
"  substr CHAÎNE POS LONG   sous-chaîne de CHAÎNE débutant à la POSition\n"
"                           (comptée à partir de 1) et ayant une LONGueur\n"
"  index CHAÎNE CAR         valeur de la position du CARactère retrouvé\n"
"                           dans la CHAÎNE, sinon 0\n"
"  length CHAÎNE            longueur de la CHAÎNE\n"

#: src/expr.c:136
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like `match' or an operator like `/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + JETON                  interpréter le JETON comme une chaîne, même si "
"c'est\n"
"                           un mot clé comme « match » ou un opérateur comme "
"« / »\n"
"\n"
"  ( EXPRESSION )           valeur de l'EXPRESSION\n"

#: src/expr.c:142
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"Portez attention au fait que plusieurs opérateurs peuvent être escamotés\n"
"ou commentés par certains shells.\n"
"Les comparaisons sont arithmétiques si les deux ARGuments sont des nombres,\n"
"autrement elles sont lexicographiques.\n"
"Les concordances de patrons retournent la chaîne retrouvée si elle est\n"
"encapsulée entre \\( et \\) ou nul; si \\( et \\) ne sont pas utilisés,\n"
"le nombre de caractères qui concordent est retourné sinon 0.\n"

#: src/expr.c:186 src/expr.c:438 src/expr.c:444 src/expr.c:449 src/expr.c:471
msgid "syntax error"
msgstr "erreur de syntaxe"

#: src/expr.c:384
#, c-format
msgid ""
"warning: unportable BRE: `%s': using `^' as the first character\n"
"of the basic regular expression is not portable; it is being ignored"
msgstr ""
"AVERTISSEMENT: BRE non portable: « %s »: l'utilisation de « ^ » comme "
"premier\n"
"caractère d'une expression régulière de base n'est pas portable; ignoré."

#: src/expr.c:586 src/expr.c:625
msgid "non-numeric argument"
msgstr "argument non numérique"

#: src/expr.c:592
msgid "division by zero"
msgstr "division par zéro"

#: src/factor.c:74
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [NOMBRE]...\n"
"  or:  %s OPTION\n"

#: src/factor.c:79
msgid ""
"Print the prime factors of each NUMBER.\n"
"\n"
msgstr ""
"Afficher les facteurs premiers de chaque NOMBRE.\n"
"\n"

#: src/factor.c:85
msgid ""
"\n"
"  Print the prime factors of all specified integer NUMBERs.  If no "
"arguments\n"
"  are specified on the command line, they are read from standard input.\n"
msgstr ""
"\n"
"Afficher les facteurs premiers d'un NOMBRE entier spécifique.\n"
"Si aucun argument n'est fourni, les nombres sont lus de l'entrée standard.\n"

#: src/factor.c:154
#, c-format
msgid "`%s' is not a valid positive integer"
msgstr "« %s » n'est pas un entier positif valide."

#: src/false.c:34
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
"Exit with a status code indicating failure.\n"
"\n"
"These option names may not be abbreviated.\n"
"\n"
msgstr ""
"Usage: %s [arguments ignorés de la ligne de commande]\n"
"   ou: %s OPTION\n"
"Terminer avec un statut indiquant l'échec.\n"
"\n"
"Ces options ne peuvent pas être abrégées.\n"
"\n"

#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "Usage: %s [-CHIFFRES] [OPTION]... [FICHIER]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
msgstr ""
"Reformater chaque paragraphe de FICHIER(s), en écrivant sur la\n"
"sortie standard.\n"
"Si aucun FICHIER ou si FICHIER est « - », lire de l'entrée standard.\n"
"\n"

#: src/fmt.c:280
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        préserver l'indentation des 2 premières lignes\n"
"  -p, --prefix=CHAÎNE       combiner les lignes ayant CHAÎNE comme préfixe\n"
"  -s, --split-only          briser les longues lignes mais sans les remplir\n"

#: src/fmt.c:286
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph    indenter différemment la 1ère ligne de la 2ème\n"
"  -u, --uniform-spacing     séparer d'un blanc les mots,\n"
"                            puis de deux après chaque phrase\n"
"  -w, --width=N             utiliser une largeur de N colonnes pour une\n"
"                            pour une ligne (par défaut 75 colonnes)\n"

#: src/fmt.c:293
msgid ""
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"\n"
"Pour -wNOMBRE, l'option « w » peut être omise.\n"

#: src/fmt.c:345
#, c-format
msgid "invalid width option: `%s'"
msgstr "L'option largeur est invalide: « %s »."

#: src/fmt.c:385
#, c-format
msgid "invalid width: `%s'"
msgstr "Largeur invalide: « %s »"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"Limiter la longueur de chaque ligne de chaque FICHIER (entrée standard par\n"
"défaut) et forcer le bouclage en écrivant sur la sortie standard.\n"
"\n"

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         compter les octets au lieu des colonnes\n"
"  -s, --spaces        briser la ligne sur des blancs\n"
"  -w, --width=N       utiliser N colonnes au lieu de 80\n"

#: src/fold.c:267
#, c-format
msgid "`%s' option is obsolete; use `%s'"
msgstr "option « %s » est obsolète; utiliser « %s »"

#: src/fold.c:295
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "Le nombre de colonnes « %s » est invalide."

#: src/head.c:92
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les 10 premières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un fichier FICHIER, précéder chacun d'une en-tête donnant le "
"nom.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/head.c:101
msgid ""
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
msgstr ""
"  -c, --bytes=N            afficher les N premiers octets\n"
"  -n, --lines=N            afficher les N premières lignes au lieu de 10\n"

#: src/head.c:105
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    ne pas afficher les en-têtes avec les\n"
"                            noms de fichiers\n"
"  -v, --verbose            toujours afficher les en-têtes avec les\n"
"                            noms de fichiers\n"

#: src/head.c:111 src/split.c:120
msgid ""
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"\n"
"La TAILLE peut être suivie d'un suffixe multiplicateur:\n"
"b pour 512, k pour 1K, m pour 1 Meg.\n"

#: src/head.c:190
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "ne peut repositionner le pointeur de fichier pour %s"

#: src/head.c:256 src/tail.c:1388
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s est tellement grande qu'elle n'est pas représentable."

#: src/head.c:257 src/tail.c:1390
msgid "number of lines"
msgstr "Nombre de lignes"

#: src/head.c:257 src/tail.c:1391
msgid "number of bytes"
msgstr "Nombre d'octets"

#: src/head.c:264 src/tail.c:1478
msgid "invalid number of lines"
msgstr "nombre invalide de lignes."

#: src/head.c:265 src/tail.c:1479
msgid "invalid number of bytes"
msgstr "nombre d'octets invalide."

#: src/head.c:341
#, c-format
msgid "unrecognized option `-%c'"
msgstr "L'option « -%c » n'est pas reconnue."

#: src/head.c:348
#, c-format
msgid "`-%s' option is obsolete; use `-%c %.*s%.*s%s'"
msgstr "option « -%s » est obsolète; utiliser « -%c %.*s%.*s%s »"

#: src/hostid.c:48
#, c-format
msgid ""
"Usage: %s\n"
"  or:  %s OPTION\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Usage: %s\n"
"  ou:  %s OPTION\n"
"Afficher l'identificateur numérique (en hexadécimal) de l'hôte courant.\n"
"\n"

#: src/hostname.c:67
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Usage: %s [NOM]\n"
"   ou: %s OPTION\n"
"Afficher le nom du poste (hostname) du système courant.\n"
"\n"

#: src/hostname.c:104
#, c-format
msgid "cannot set hostname to `%s'"
msgstr "ne peut sélectionner l'hôte vers « %s »"

#: src/hostname.c:110
msgid "cannot set hostname; this system lacks the functionality"
msgstr ""
"Ne peut nommer le poste (hostname); le système ne supporte pas cette fonction"

#: src/hostname.c:117
msgid "cannot determine hostname"
msgstr "Ne peut déterminer le nom du poste (hostname)"

#: src/id.c:36
msgid "Arnold Robbins and David MacKenzie"
msgstr "Arnold Robbins et David MacKenzie"

#: src/id.c:87
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]\n"
msgstr "Usage: %s [OPTION]... [NOM-D'USAGER]\n"

#: src/id.c:88
msgid ""
"Print information for USERNAME, or the current user.\n"
"\n"
"  -a              ignore, for compatibility with other versions\n"
"  -g, --group     print only the effective group ID\n"
"  -G, --groups    print all group IDs\n"
"  -n, --name      print a name instead of a number, for -ugG\n"
"  -r, --real      print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user      print only the effective user ID\n"
msgstr ""
"Afficher les informations concernant un USAGER, ou de l'usager courant.\n"
"\n"
"  -a              ignorée, par compatibilité avec les autres version\n"
"  -g, --group     afficher les IDentificateurs de groupes\n"
"  -G, --groups    afficher seulement les groupes supplémentaires\n"
"  -n, --name      afficher le nom au lieu du nombre, avec -ugG\n"
"  -r, --real      afficher l'IDentificateur réel au lieu de\n"
"                  l'effectif, avec -ugG\n"
"  -u, --user      afficher seulement l'IDentificateur de l'usager\n"

#: src/id.c:100
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Sans aucune OPTION, afficher les informations utiles d'identification.\n"

#: src/id.c:162
msgid "cannot print only user and only group"
msgstr "ne peut imprimer seulement l'usager et seulement le groupe"

#: src/id.c:166
msgid "cannot print only names or real IDs in default format"
msgstr ""
"Ne peut afficher seulement les noms ou les IDentificateurs réels\n"
"dans le format par défaut."

#: src/id.c:175
#, c-format
msgid "%s: No such user"
msgstr "%s: usager inexistant."

#: src/id.c:212
#, c-format
msgid "cannot find name for user ID %u"
msgstr "ne peut trouver le nom de l'usager ID %u"

#: src/id.c:235
#, c-format
msgid "cannot find name for group ID %u"
msgstr "ne peut trouver le nom de l'identificateur de groupe %u"

#: src/id.c:273
msgid "cannot get supplemental group list"
msgstr "Ne peut trouver la liste de groupes supplémentaires."

#: src/id.c:385
msgid " groups="
msgstr " groupes="

#: src/install.c:269
msgid "the strip option may not be used when installing a directory"
msgstr ""
"les options de strip peuvent ne pas être utilisées lors de l'installation "
"d'un répertoire"

#: src/install.c:292 src/mkdir.c:140
#, c-format
msgid "invalid mode %s"
msgstr "mode invalide %s"

#: src/install.c:307 src/install.c:371
#, c-format
msgid "creating directory %s"
msgstr "création du répertoire %s"

#: src/install.c:332
#, c-format
msgid "installing multiple files, but last argument, %s is not a directory"
msgstr ""
"durant l'installation de plusieurs fichiers,\n"
"le dernier argument %s n'est pas un répertoire."

#: src/install.c:435
#, c-format
msgid "%s is a directory"
msgstr "%s est un répertoire"

#: src/install.c:495
#, c-format
msgid "cannot obtain time stamps for %s"
msgstr "ne peut obtenir les estampilles de date-heure pour %s"

#: src/install.c:507
#, c-format
msgid "cannot set time stamps for %s"
msgstr "ne peut initialiser les estampilles de date-heure pour %s"

#: src/install.c:528
msgid "fork system call failed"
msgstr "échec de l'appel système fork()"

#: src/install.c:532
msgid "cannot run strip"
msgstr "ne peut exécuter strip"

#: src/install.c:539
msgid "strip failed"
msgstr "échec de strip"

#: src/install.c:560
#, c-format
msgid "invalid user %s"
msgstr "usager invalide %s"

#: src/install.c:578
#, c-format
msgid "invalid group %s"
msgstr "groupe invalide %s"

#: src/install.c:597
#, c-format
msgid ""
"Usage: %s [OPTION]... SOURCE DEST           (1st format)\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY   (2nd format)\n"
"  or:  %s -d [OPTION]... DIRECTORY...       (3rd format)\n"
msgstr ""
"Usage: %s [OPTION]... SOURCE DESTINATION    (1er format)\n"
"   ou: %s [OPTION]... SOURCE... RÉPERTOIRE  (2e  format)\n"
"   ou: %s -d [OPTION]... RÉPERTOIRE...      (3e  format)\n"

#: src/install.c:603
msgid ""
"In the first two formats, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the third format, create all components of the given DIRECTORY(ies).\n"
"\n"
msgstr ""
"Dans les deux premiers formats, copier la SOURCE vers la DESTINATION ou des\n"
"fichiers de plusieurs SOURCE(S) vers un RÉPERTOIRE existant, tout en "
"initialisant\n"
"les bits de protection et l'appartenance propriétaire/groupe.  Dans le\n"
"3e format, créer tous les composants des RÉPERTOIRES spécifiés.\n"
"\n"

#: src/install.c:612
msgid ""
"      --backup[=CONTROL] make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTRÔLE]      archiver chaque fichier de destination\n"
"  -b                           identique à --backup mais sans argument\n"
"  -c                           (ignoré)\n"
"  -d, --directory              traiter tous les arguments comme des noms\n"
"                               de répertoires; créer toutes les composants\n"
"                               des répertoires spécifiés\n"

#: src/install.c:619
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        then copy SOURCE to DEST;  useful in the 1st format\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                        créer tous les composants de tête de la\n"
"                            DESTINATION excepté le dernier\n"
"                            ensuite copier la SOURCE vers la DESTINATION\n"
"                            (pratique lorsque le 1er format est utlisé)\n"
"  -g, --group=GROUPE        attribuer l'appartenance au GROUPE,\n"
"                            plutôt qu'au groupe courant du processus\n"
"  -m, --mode=MODE           initialiser les permissions d'accès au MODE\n"
"                            (comme par chmod), au lieu de rw-r--r--\n"
"  -o, --owner=PROPRIÉTAIRE  attribuer l'appartenance au PROPRIÉTAIRE\n"
"                            (mode super-user seulement)\n"

#: src/install.c:626
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables, only for 1st and 2nd formats\n"
"  -S, --suffix=SUFFIX override the usual backup suffix\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps conserver les dates d'accès et de modification\n"
"                            des fichiers SOURCES aux fichiers de la "
"DESTINATION\n"
"  -s, --strip               enlever les tables de symboles,\n"
"                            valable pour les 1er et 2e formats seulement\n"
"  -S, --suffix=SUFFIXE      écraser le SUFFIXE usuel d'archivage\n"
"  -v, --verbose             afficher le nom de chaque répertoire créé\n"

#: src/install.c:635 src/ln.c:377 src/mv.c:348
msgid ""
"\n"
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Le suffixe d'archive est « ~ », initialisé autrement avec --suffix ou\n"
"SIMPLE_BACKUP_SUFFIX.  La méthode du contrôle de version peut être "
"sélectionné\n"
"par l'option --backup ou par VERSION_CONTROL par le bias des variables\n"
"d'environnement selon les valeurs suivantes:\n"
"\n"

#: src/join.c:144
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Usage: %s [OPTION]... FICHIER1  FICHIER2\n"

#: src/join.c:148
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a FILENUM        print unpairable lines coming from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Pour chaque paire de lignes en entrée ayant des champs de fusion "
"identiques,\n"
"afficher une ligne sur la sortie standard.\n"
"Le champ de fusion par défaut est le premier, délimité par un blanc.\n"
"Si FICHIER1 ou FICHIER2 (pas les 2) est -, lire de l'entrée standard.\n"
"\n"
"  -a COTÉ           afficher les lignes non repérables venant du \n"
"                    fichier COTÉ\n"
"  -e VIDE           remplacer les champs d'entrée manquants par VIDE\n"

#: src/join.c:157
msgid ""
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case ignorer la casse des caractères lors de la\n"
"                    comparaison des champs\n"
"  -j CHAMP          option désuète équivalente à « -1 CHAMP -2 CHAMP »\n"
"  -j1 CHAMP         option désuète équivalente à « -1 CHAMP »\n"
"  -j2 CHAMP         option désuète équivalente à « -2 CHAMP »\n"
"  -o FORMAT         respecter le FORMAT lors de la construction\n"
"                    de sortie\n"
"  -t CAR            utiliser CAR comme délimiteur de champs à l'entrée\n"
"                    et à la sortie\n"

#: src/join.c:165
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
msgstr ""
"  -v NOFICHIER      comme -a NOFICHIERÉ, mais supprimer les lignes jointes "
"sur la sortie\n"
"                    de sortie fusionnées\n"
"  -1 CHAMP          fusionner sur le champs CHAMP du fichier 1\n"
"  -2 CHAMP          fusionner sur le champs CHAMP du fichier 2\n"

#: src/join.c:172
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `FILENUM.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"\n"
"À moins que -t CAR ne soit fourni, les blancs de tête séparant\n"
"les champs sont ignorés sinon les champs sont séparés par CAR.\n"
"Chaque CHAMP est un champ compté numériquement à partir de 1.\n"
"FORMAT est une spécification contenant un ou plusieurs virgules ou blancs\n"
"chacun étant « NOFICHIER.CHAMP » ou « 0 ».  Par défaut FORMAT affiche des\n"
"champs fusionnés, les champs restants de FICHIER1 ou FICHIER2 sont tous "
"séparés par CAR.\n"

#: src/join.c:645
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "Le symbole de champ « %s » est invalide."

#: src/join.c:659 src/join.c:772 src/join.c:808
#, c-format
msgid "invalid field number: `%s'"
msgstr "Le numéro de champ « %s » est invalide."

#: src/join.c:672
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "Le numéro de fichier « %s » est invalide dans le champ spécifié."

#: src/join.c:792
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "Le numéro de champ « %s » est invalide pour le fichier 1."

#: src/join.c:801
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "Le numéro de champ « %s » est invalide pour le fichier 2."

#: src/join.c:833
msgid "too many non-option arguments"
msgstr "Trop de arguments sont des options non reconnues."

#: src/join.c:855
msgid "too few non-option arguments"
msgstr "Trop peu de arguments sont des options non reconnues."

#: src/join.c:866
msgid "both files cannot be standard input"
msgstr "Les deux fichiers ne peuvent pas être à l'entrée standard."

#: src/kill.c:93
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  ou:  %s -l [SIGNAL]...\n"
"  ou:  %s -t [SIGNAL]...\n"

#: src/kill.c:99
msgid ""
"Send signals to processes, or list signals.\n"
"\n"
msgstr ""
"Transmettre les signaux aux processus ou donner la liste des signaux.\n"
"\n"

#: src/kill.c:106
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   utiliser le nom ou le numéro du signal à transmettre.\n"
"  -l, --list       donner la liste des noms de signaux.\n"
"  -t, --table      afficher la table des informations relatives aux "
"signaux.\n"

#: src/kill.c:114
msgid ""
"\n"
"SIGNAL may be a signal name like `HUP', or a signal number like `1',\n"
"or an exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"SIGNAL peut être un nom comme « HUP » ou un numéro de signal commme « 1 »\n"
"ou un état de fin d'exécution d'un processus terminé par un signal.\n"
"PID est un entier; si négatif il identifie un groupe de processus.\n"

#: src/kill.c:163
#, c-format
msgid "%s: invalid signal"
msgstr "%s: signal invalide"

#: src/kill.c:262
#, c-format
msgid "missing operand after `%s'"
msgstr "opérande manquante après « %s »"

#: src/kill.c:274
#, c-format
msgid "%s: invalid process id"
msgstr "%s: identificateur de processus invalide"

#: src/kill.c:327
#, c-format
msgid "invalid option -- %c"
msgstr "option invalide --%c"

#: src/kill.c:336
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: signaux multiples spécifiés"

#: src/kill.c:350
msgid "multiple -l or -t options specified"
msgstr "options multiples -l ou -t spécifiées"

#: src/kill.c:367
msgid "cannot combine signal with -l or -t"
msgstr "ne peut combiner le signal avec -l ou -t"

#: src/link.c:51
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FICHIER FICHIER2\n"
"  or:  %s OPTION\n"

#: src/link.c:54
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Appeler la fonction link() pour créer un lien nommé FICHIER2 sur le FICHIER1 "
"existant.\n"
"\n"

#: src/link.c:98
#, c-format
msgid "cannot create link %s to %s"
msgstr "Ne peut créer le lien %s vers %s"

#: src/ln.c:39
msgid "Mike Parker and David MacKenzie"
msgstr "Mike Parker et David MacKenzie"

#: src/ln.c:167
#, c-format
msgid "%s: warning: making a hard link to a symbolic link is not portable"
msgstr ""
"%s: AVERTISSEMENT: créer un lien direct vers un lien symbolique n'est pas "
"portable"

#: src/ln.c:174
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: lien direct n,est pas permis pour un répertoire"

#: src/ln.c:246
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: ne peut écraser le répertoire"

#: src/ln.c:251
#, c-format
msgid "%s: replace %s? "
msgstr "%s: remplacer %s? "

#: src/ln.c:257
#, c-format
msgid "%s: File exists"
msgstr "%s: fichier existant."

#: src/ln.c:304
#, c-format
msgid "create symbolic link %s to %s"
msgstr "création du lien symbolique %s vers %s"

#: src/ln.c:305
#, c-format
msgid "create hard link %s to %s"
msgstr "création d'un lien direct %s vers %s"

#: src/ln.c:319
#, c-format
msgid "creating symbolic link %s to %s"
msgstr "création d'un lien symbolique %s vers %s"

#: src/ln.c:320
#, c-format
msgid "creating hard link %s to %s"
msgstr "création d'un lien direct %s vers %s"

#: src/ln.c:339
#, c-format
msgid ""
"Usage: %s [OPTION]... TARGET [LINK_NAME]\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... --target-directory=DIRECTORY TARGET...\n"
msgstr ""
"Usage: %s [OPTION]... CIBLE [NOM-DU-LIEN]\n"
"  ou:  %s [OPTION]... CIBLE... RÉPERTOIRE\n"
"  ou:  %s [OPTION]... --target-directory=RÉPERTOIRE CIBLE...\n"

#: src/ln.c:345
msgid ""
"Create a link to the specified TARGET with optional LINK_NAME.\n"
"If LINK_NAME is omitted, a link with the same basename as the TARGET is\n"
"created in the current directory.  When using the second form with more\n"
"than one TARGET, the last argument must be a directory;  create links\n"
"in DIRECTORY to each TARGET.  Create hard links by default, symbolic\n"
"links with --symbolic.  When creating hard links, each TARGET must exist.\n"
"\n"
msgstr ""
"Créer un lien vers la CIBLE spécifiée avec optionnellement un NOM_DE_LIEN.\n"
"S'il y le NOM_DE_LIEN est omis, un lien ayant la même base comme CIBLE est\n"
"créé dans le répertoire courant. Lors de l'utilisation de la seconde forme\n"
"avec plus d'une CIBLE, le dernier argument doit être un répertoire;\n"
"créer des liens dans le RÉPERTOIRE pour chaque CIBLE.  Créer des liens "
"directs\n"
"par défaut et des liens symboliques avec l'option --symbolic.  Lors de la\n"
"création de liens directs, chaque CIBLE doit exister.\n"
"\n"

#: src/ln.c:357
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         hard link directories (super-user only)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=CONTRÔLE]      archiver chaque fichier de destination\n"
"  -b                           identique à --backup mais sans argument\n"
"  -d, -F, --directory          répertoires par liens hard (super usager "
"seulement)\n"
"  -f, --force                  détruire les destinations,\n"
"                               sans demander confirmation\n"

#: src/ln.c:363
msgid ""
"  -n, --no-dereference        treat destination that is a symlink to a\n"
"                                directory as if it were a normal file\n"
"  -i, --interactive           prompt whether to remove destinations\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -n, --no-dereference       avec --force, détruire la destination qui\n"
"                             est un lien symbolique vers un répertoire \n"
"  -i, --interactive          demander confirmation avant de détruire\n"
"                             les destinations\n"
"  -s, --symbolic             créer un lien symbolique au lieu d'un\n"
"                             lien direct\n"

#: src/ln.c:369
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"      --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -v, --verbose               print name of each file before linking\n"
msgstr ""
"  -S, --suffix=SUFFIXE       écraser le suffixe d'archivage par le SUFFIXE\n"
"      --target-directory=RÉPERTOIRE\n"
"                             déplacer tous les fichiers SOURCE en arguments\n"
"                             vers le RÉPERTOIRE\n"
"  -v, --verbose              afficher le nom de chaque fichier avant de "
"créer un lien\n"

#: src/ln.c:521
#, c-format
msgid "%s: specified target directory is not a directory"
msgstr "%s: répertoire cible spécifié n'est pas un répertoire"

#: src/ln.c:542
msgid "when making multiple links, last argument must be a directory"
msgstr ""
"Lors de la création de liens: le dernier argument doit être un répertoire."

#: src/logname.c:48 src/pwd.c:46 src/sync.c:44
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Usage: %s [OPTION]\n"

#: src/logname.c:49
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Afficher le nom de l'usager courant.\n"
"\n"

#: src/logname.c:99
#, c-format
msgid "%s: no login name\n"
msgstr "%s: pas de nom d'usager (login name)\n"

#: src/ls.c:673
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#: src/ls.c:681
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1307
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr ""
"valeur invalide ignorée de la variable d'environnement QUOTING_STYLE: %s"

#: src/ls.c:1334
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr ""
"La taille des colonnes est ignorée:\n"
"la variable d'environnement COLUMNS %s est invalide."

#: src/ls.c:1365
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"La taille de tabulation est ignorée:\n"
"la variable d'environnement TABSIZE %s est invalide."

#: src/ls.c:1482
#, c-format
msgid "invalid line width: %s"
msgstr "largeur de ligne invalide: %s"

#: src/ls.c:1556
#, c-format
msgid "invalid tab size: %s"
msgstr "taille de tabulation invalide: %s"

#: src/ls.c:1722
#, c-format
msgid "invalid time style format %s"
msgstr "format de style de temps invalide %s"

#: src/ls.c:2054
#, c-format
msgid "unrecognized prefix: %s"
msgstr "préfixe non reconnu: %s"

#: src/ls.c:2077
msgid "unparsable value for LS_COLORS environment variable"
msgstr ""
"La valeur de la variable d'environnement LS_COLORS\n"
"est syntaxiquement erronée."

#: src/ls.c:2145
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "ne peut déterminer le périphérique et l'inode de %s"

#: src/ls.c:2155
#, c-format
msgid "not listing already-listed directory: %s"
msgstr "ne peut lister un répertoire déjà listé: %s"

#: src/ls.c:2208 src/remove.c:929
#, c-format
msgid "reading directory %s"
msgstr "lecture du répertoire %s"

#: src/ls.c:2603
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "ne peut comparer les noms de fichier %s et %s"

#: src/ls.c:3762
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuSUX nor --sort.\n"
"\n"
msgstr ""
"Afficher les informations au sujet des FICHIERS (du répertoire\n"
"courant par défaut). Trier les entrées alphabétiquement si aucune\n"
"des options  -cftuSUX  ou  --sort n'est utilisée.\n"
"\n"

#: src/ls.c:3770
msgid ""
"  -a, --all                  do not hide entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               print the author of each file\n"
"  -b, --escape               print octal escapes for nongraphic characters\n"
msgstr ""
"  -a, --all                  ne pas cacher les entrées débutant par .\n"
"  -A, --almost-all           ne pas inclure dans la liste . et ..\n"
"      --author               afficher l'auteur de chaque fichier\n"
"  -b, --escape               afficher en octal les caractères\n"
"                             non-graphiques\n"
"                             en utilisant des séquences d'échappement\n"

#: src/ls.c:3776
msgid ""
"      --block-size=SIZE      use SIZE-byte blocks\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information)\n"
"                               with -l: show ctime and sort by name\n"
"                               otherwise: sort by ctime\n"
msgstr ""
"      --block-size=TAILLE    utiliser la TAILLE de blocs\n"
"  -B, --ignore-backups       ne pas inclure dans la liste,\n"
"                             les entrées se terminant par ~\n"
"  -c                         lister les fichiers triés selon leur date de\n"
"                             modification; \n"
"                             avec -lt:  trier par la date de modification\n"
"                                et afficher la date de modification (ctime)\n"
"                             avec -l:   trier par nom et afficher avec\n"
"                                avec la date de modification (ctime)\n"
"                             autrement: trier par la date de modification "
"(ctime)\n"

#: src/ls.c:3784
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         control whether color is used to distinguish "
"file\n"
"                               types.  WHEN may be `never', `always', or "
"`auto'\n"
"  -d, --directory            list directory entries instead of contents,\n"
"                               and do not dereference symbolic links\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         afficher en colonnes\n"
"      --color[=PARAM]        afficher avec une couleur pour distinguer les "
"types de fichiers\n"
"                             de fichiers, selon un des PARAMètres\n"
"                             suivants: `never', `always', ou `auto'\n"
"  -d, --directory            lister les noms de répertoires plutôt\n"
"                             que leur contenu et ne pas déférencer les liens "
"symboliques\n"
"  -D, --dired                générer une sortie adaptée pour le mode\n"
"                             « dired » de Emacs\n"

#: src/ls.c:3792
msgid ""
"  -f                         do not sort, enable -aU, disable -lst\n"
"  -F, --classify             append indicator (one of */=@|) to entries\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         ne pas trier, autoriser -aU, interdire -lst\n"
"  -F, --classify             ajouter un caractère (parmi */=@|) pour chaque "
"entrée\n"
"      --format=MODE          afficher selon le MODE suivant: -x croisé,\n"
"                             -m avec virgules, -x horizontal, -l long,\n"
"                             -1 en colonne simple, -l en mode bavard,\n"
"                             -C vertical\n"
"      --full-time            identique à -l --time-style=full-iso\n"

#: src/ls.c:3799
msgid ""
"  -g                         like -l, but do not list owner\n"
"  -G, --no-group             inhibit display of group information\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
msgstr ""
"  -g                         (ignorée)\n"
"  -G, --no-group             inhiber l'affichage des informations de groupe\n"
"  -h, --human-readable       afficher les tailles dans un format lisible "
"par\n"
"      --si                   un humain (i.e. 1K 234M 2G) en utilisant un "
"multiple\n"
"                             1000 et non pas de 1024\n"
"  -H, --dereference-command-line\n"
"                             suivre les liens symboliques de la ligne de "
"commande\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             suivre chaque lein symbolique de la ligne de "
"commande\n"
"                             qui pointe vers un répertoire\n"

#: src/ls.c:3810
msgid ""
"      --indicator-style=WORD append indicator with style WORD to entry "
"names:\n"
"                               none (default), classify (-F), file-type (-"
"p)\n"
"  -i, --inode                print index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
"  -k                         like --block-size=1K\n"
msgstr ""
"      --indicator-style=CODE ajouter en suffixe l'indicateur selon le CODE:\n"
"                             none (par défaut), classify (-F), file-type (-"
"p)\n"
"  -i, --inode                afficher le numéro d'index de chaque fichier\n"
"  -I, --ignore=PATRON        ne pas inclure dans la liste les entrées\n"
"                             concordant avec le PATRON de shell\n"
"  -k                         identique à --block-size=1K\n"

#: src/ls.c:3817
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         utiliser le format long d'affichage\n"
"  -L, --dereference          afficher les entrées pointées par des\n"
"                             liens symboliques, monter l'information pointée "
"par le lien\n"
"  -m                         remplir la largeur par une liste d'entrées\n"
"                             séparée par des virgules\n"

#: src/ls.c:3824
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric UIDs and GIDs\n"
"  -N, --literal              print raw entry names (don't treat e.g. "
"control\n"
"                               characters specially)\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --file-type            append indicator (one of /=@|) to entries\n"
msgstr ""
"  -n, --numeric-uid-gid      identique à -l mais en listant les valeurs "
"numériques\n"
"                             des UID et GID\n"
"  -N, --literal              afficher les noms bruts (ne pas traiter les "
"caractères\n"
"                               de contrôle spécialement)\n"
"  -o                         identique à -l mais sans lister l'information "
"de groupe\n"
"  -p, --file-type            accoler un indicateur (parmi /=@|) aux entrées\n"

#: src/ls.c:3831
msgid ""
"  -q, --hide-control-chars   print ? instead of non graphic characters\n"
"      --show-control-chars   show non graphic characters as-is (default\n"
"                             unless program is `ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always, c, "
"escape\n"
msgstr ""
"  -q, --hide-control-chars   afficher ? au lieu de caractères\n"
"                             non-graphiques\n"
"      --show-control-chars   afficher les caractères non graphiques\n"
"                             tel quel (par défaut)\n"
"  -Q, --quote-name           encapsuler chaque nom d'entrée entre\n"
"                             guillemets\n"
"      --quoting-style=MOT    utiliser le style d'encapsultation selon le MOT "
"clé\n"
"                             suivant:  literal, shell, shell-always, c, "
"escape\n"

#: src/ls.c:3839
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print size of each file, in blocks\n"
msgstr ""
"  -r, --reverse              afficher en ordre inverse lors du trie\n"
"  -R, --recursive            afficher les sous-répertoire récursivement\n"
"  -s, --size                 afficher la taille de chaque fichier en blocs\n"

#: src/ls.c:3844
msgid ""
"  -S                         sort by file size\n"
"      --sort=WORD            extension -X, none -U, size -S, time -t,\n"
"                               version -v\n"
"                             status -c, time -t, atime -u, access -u, use -"
"u\n"
"      --time=WORD            show time as WORD instead of modification "
"time:\n"
"                               atime, access, use, ctime or status; use\n"
"                               specified time as sort key if --sort=time\n"
msgstr ""
"  -S                         trier selon la taille des fichiers\n"
"      --sort=CODE            trier selon le CODE suivant: -c pour ctime,\n"
"                             -X pour extension, -U pour aucun,\n"
"                             -S pour la taille, -t pour la date\n"
"                             -v pour la version, -c pour le statut, \n"
"                             -u pour la date d'accès, -u pour l'accès\n"
"      --time=CODE            afficher les temps d'accès en mots au lieu de\n"
"                             date de modification:\n"
"                             atime, access, use, ctime ou status\n"
"                             tel que spécifié dans la clé de trie --"
"sort=clé\n"

#: src/ls.c:3853
msgid ""
"      --time-style=STYLE     show times using style STYLE:\n"
"                               full-iso, long-iso, iso, locale, +FORMAT\n"
"                             FORMAT is interpreted like `date'; if FORMAT "
"is\n"
"                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
"                             non-recent files and FORMAT2 to recent files;\n"
"                             if STYLE is prefixed with `posix-', STYLE\n"
"                             takes effect only outside the POSIX locale\n"
"  -t                         sort by modification time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"      --time-style=STYLE     afficher les dates selon le STYLE désiré:\n"
"                              full-iso, long-iso, iso, locale, +FORMAT\n"
"                             FORMAT est interprété comme « date »; si FORMAT "
"est\n"
"                             FORMAT1<retour de chariot>FORMAT2, FORMAT1 "
"s'applique aux\n"
"                             fichiers non récents et FORMAT2 aux fichiers "
"récents\n"
"  -t                         trier selon la date de modification:\n"
"  -T, --tabsize=TAILLE       utiliser la tabulation de la TAILLE\n"
"                             pour chaque colonne au lieu de 8\n"

#: src/ls.c:3864
msgid ""
"  -u                         with -lt: sort by, and show, access time\n"
"                               with -l: show access time and sort by name\n"
"                               otherwise: sort by access time\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         sort by version\n"
msgstr ""
"  -u                         avec -lt: trier selon la date du dernier "
"accès;\n"
"                             avec -l:  afficher la date d'accès et trier par "
"nom\n"
"  -U                         ne pas trier: afficher selon l'ordre\n"
"                             original des entrées d'un répertoire\n"
"  -v                         trier par version\n"

#: src/ls.c:3871
msgid ""
"  -w, --width=COLS           assume screen width instead of current value\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -1                         list one file per line\n"
msgstr ""
"  -w, --width=COLS           fixer la largeur de l'écran au lieu de la "
"valeur courante\n"
"  -x                         lister les entrées par ligne au lieu de par "
"colonne\n"
"  -X                         trier alphabétiquement par extension d'entrée\n"
"  -1                         lister un fichier par ligne\n"

#: src/ls.c:3883
msgid ""
"\n"
"By default, color is not used to distinguish types of files.  That is\n"
"equivalent to using --color=none.  Using the --color option without the\n"
"optional WHEN argument is equivalent to using --color=always.  With\n"
"--color=auto, color codes are output only if standard output is connected\n"
"to a terminal (tty).\n"
msgstr ""
"\n"
"Par défaut, la couleur n'est pas utilisée pour distinguer les différents "
"types\n"
"de fichiers. Cela est équivalent à l'utilisation de l'option --"
"color=none.  \n"
"L'utilisation de l'option --color sans l'argument WHEN est équivalent à\n"
"l'utilisation de --colors=always.  Avec l'option --color=auto, les codes de\n"
"couleur sont transmis vers la sortie standard si celle-ci est reliée à un \n"
"terminal (tty).\n"

#: src/md5sum.c:38
msgid "Ulrich Drepper and Scott Miller"
msgstr "Ulrich Drepper et Scott Miller"

#: src/md5sum.c:125
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Usage: %s [OPTION] [FICHIER]...\n"
"  ou:  %s [OPTION] --check [FICHIER]\n"
"Afficher ou vérifier les sommes de contrôle %s (%d-bits).\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"

#: src/md5sum.c:134
#, c-format
msgid ""
"\n"
"  -b, --binary            read files in binary mode (default on DOS/"
"Windows)\n"
"  -c, --check             check %s sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
msgstr ""
"\n"
"  -b, --binary            lire les fichiers en mode binaire \n"
"                          (par défaut sous DOS/WIndows)\n"
"  -c, --check             vérifier les sommes %s par rapport à la liste\n"
"  -t, --text              lire les fichiers en mode texte (par défaut)\n"
"\n"

#: src/md5sum.c:142
msgid ""
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated checksum lines\n"
"\n"
msgstr ""
"Les deux options suivantes sont utiles seulement lors de la vérification\n"
"des sommes de contrôle:\n"
"      --status            ne rien afficher, sauf le constat\n"
"                          de fin d'exécution\n"
"  -w, --warn              avertir si les lignes de contrôle MD5\n"
"                          sont mal formatées\n"
"\n"

#: src/md5sum.c:150
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"Les sommes sont calculées selon la description de %s.  Lors de la "
"vérification,\n"
"l'entrée devrait être formellement une sortie de ce programme.  Le mode par "
"défaut\n"
"est d'afficher la ligne avec la somme de contrôle, un caractère indiquant\n"
"le type (« * » pour binaire, « » pour texte) et un nom pour chaque FICHIER.\n"

#: src/md5sum.c:385
#, c-format
msgid "%s: %lu: improperly formatted %s checksum line"
msgstr "%s: %lu: ligne de somme de contrôle %s mal formatée."

#: src/md5sum.c:407
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: ÉCHEC d'ouverture ou de lecture.\n"

#: src/md5sum.c:431
msgid "FAILED"
msgstr "ÉCHEC"

#: src/md5sum.c:431
msgid "OK"
msgstr "OK"

#: src/md5sum.c:444
#, c-format
msgid "%s: read error"
msgstr "%s: erreur de lecture."

#: src/md5sum.c:457
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: aucune ligne de somme de contrôle %s repérée."

#: src/md5sum.c:470
#, c-format
msgid "WARNING: %d of %d listed %s could not be read"
msgstr "AVERTISSEMENT: %d des %d affichés %s n'a pu être lu."

#: src/md5sum.c:473
msgid "file"
msgstr "fichier"

#: src/md5sum.c:473
msgid "files"
msgstr "fichiers"

#: src/md5sum.c:479
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "AVERTISSEMENT: %d des %d sommes de contrôle %s ne concordent pas."

#: src/md5sum.c:482
msgid "checksum"
msgstr "checksum"

#: src/md5sum.c:482
msgid "checksums"
msgstr "checksums"

#: src/md5sum.c:564
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"Les options --binary et --text sont sans effet lors de la\n"
"la vérification des sommes de contrôle."

#: src/md5sum.c:572
msgid "the --string and --check options are mutually exclusive"
msgstr "les options --string et --check sont mutuellement exclusives"

#: src/md5sum.c:579
msgid "the --status option is meaningful only when verifying checksums"
msgstr ""
"L'option --status n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:586
msgid "the --warn option is meaningful only when verifying checksums"
msgstr ""
"L'option --warn n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:596
msgid "no files may be specified when using --string"
msgstr "Aucun fichier ne peut être spécifié lorsque --string est utilisée."

#: src/md5sum.c:618
msgid "only one argument may be specified when using --check"
msgstr "Un seul argument peut être spécifié lorsque --check est utilisée."

#: src/mkdir.c:61
#, c-format
msgid "Usage: %s [OPTION] DIRECTORY...\n"
msgstr "Usage: %s [OPTION] RÉPERTOIRE...\n"

#: src/mkdir.c:62
msgid ""
"Create the DIRECTORY(ies), if they do not already exist.\n"
"\n"
msgstr ""
"Créer le(s) RÉPERTOIRE(s) si il(s) n'existe(nt) pas.\n"
"\n"

#: src/mkdir.c:69
msgid ""
"  -m, --mode=MODE   set permission mode (as in chmod), not rwxrwxrwx - "
"umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=MODE   utiliser le MODE des permissions d'accès\n"
"                    (comme avec chmod),\n"
"                    et non pas le mode  rwxrwxrwx - umask\n"
"  -p, --parents     si l'exécution est sans erreur parce qu'existant:\n"
"                    créer des répertoires parents si nécessaire\n"
"  -v, --verbose     afficher le nom de chaque répertoire créé\n"

#: src/mkdir.c:113
#, c-format
msgid "created directory %s"
msgstr "création du répertoire %s"

#: src/mkdir.c:190
#, c-format
msgid "cannot set permissions of directory %s"
msgstr "ne peut initialiser les permissions du répertoire %s"

#: src/mkfifo.c:55
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Usage: %s [OPTION] NOM...\n"

#: src/mkfifo.c:56
msgid ""
"Create named pipes (FIFOs) with the given NAMEs.\n"
"\n"
msgstr "Créer un relais nommé (named pipe FIFO) qui portera le NOM.\n"

#: src/mkfifo.c:63 src/mknod.c:64
msgid ""
"  -m, --mode=MODE   set permission mode (as in chmod), not a=rw - umask\n"
msgstr ""
"  -m, --mode=MODE   utiliser le MODE d'accès (comme avec « chmod »),\n"
"                    mais non pas selon a=rw - umask\n"

#: src/mkfifo.c:93 src/mknod.c:206
msgid "fifo files not supported"
msgstr "Les fichiers de type « fifo » n'est pas supporté."

#: src/mkfifo.c:123 src/mknod.c:127
msgid "invalid mode"
msgstr "mode invalide"

#: src/mkfifo.c:142
#, c-format
msgid "cannot set permissions of fifo %s"
msgstr "ne peut initialiser les permissions du fifo %s"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Usage: %s [OPTION]... NOM TYPE [MAJEUR MINEUR]\n"

#: src/mknod.c:57
msgid ""
"Create the special file NAME of the given TYPE.\n"
"\n"
msgstr ""
"Créer le fichier spécial avec le NOM et le TYPE donné.\n"
"\n"

#: src/mknod.c:69
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Les deux MAJEUR et MINEUR doivent être spécifiés quand le TYPE est b, c ou "
"u\n"
"et ils doivent être omis lorsque le TYPE est p. Si MAJEUR et MINEUR avec 0x "
"ou 0X,\n"
"est fourni, ils sont interprétés en hexadécimal; autrement, s'ils débutent "
"pas 0, ils\n"
"le sont en octal autrement en décimal. Le TYPE peut être:\n"

#: src/mknod.c:76
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      créer un fichier spécial de type blocage (avec tampon)\n"
"  c, u   créer un fichier spécial de type caractère (sans tampon) \n"
"  p      créer un relais de type « fifo »\n"

#: src/mknod.c:141
msgid "wrong number of arguments"
msgstr "nombre erroné d'arguments"

#: src/mknod.c:153
msgid "block special files not supported"
msgstr "fichier spécial de bloc n'est pas supporté"

#: src/mknod.c:162
msgid "character special files not supported"
msgstr "fichier spécial de caractères n'est pas supporté"

#: src/mknod.c:171
msgid ""
"when creating special files, major and minor device\n"
"numbers must be specified"
msgstr ""
"Lors de la création d'un fichier spécial, les numéros\n"
"majeur et mineur de périphériques doivent être spécifiés."

#: src/mknod.c:186
#, c-format
msgid "invalid major device number %s"
msgstr "numéro majeur de périphérique invalide %s"

#: src/mknod.c:191
#, c-format
msgid "invalid minor device number %s"
msgstr "numéro mineur de périphérique invalide %s"

#: src/mknod.c:196
#, c-format
msgid "invalid device %s %s"
msgstr "périphérique invalide %s %s"

#: src/mknod.c:210
msgid "major and minor device numbers may not be specified for fifo files"
msgstr ""
"Les numéros majeur et mineur de périphérique ne peuvent être\n"
"spécifiés pour des fichiers de type « fifo »"

#: src/mknod.c:231
#, c-format
msgid "cannot set permissions of %s"
msgstr "ne peut initialiser les permissions de %s"

#: src/mv.c:44
msgid "Mike Parker, David MacKenzie, and Jim Meyering"
msgstr "Mike Parker, David MacKenzie et Jim Meyering"

#: src/mv.c:317
msgid ""
"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"Renommer la SOURCE à la DESTINATION ou déplacer la SOURCE vers la "
"DESTINATION.\n"
"\n"

#: src/mv.c:324
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"                                 equivalent to --reply=yes\n"
"  -i, --interactive            prompt before overwrite\n"
"                                 equivalent to --reply=query\n"
msgstr ""
"      --backup[=CONTRÔLE]      archiver chaque fichier de destination\n"
"  -b                           identique à --backup mais sans argument\n"
"  -f, --force                  détruire les destinations,\n"
"                               sans demander confirmation\n"
"  -i, --interactive            demander confirmation avant d'écraser\n"

#: src/mv.c:332
msgid ""
"      --reply={yes,no,query}   specify how to handle the prompt about an\n"
"                                 existing destination file\n"
"      --strip-trailing-slashes remove any trailing slashes from each SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --reply={yes,no,query}   spécifier comment traiter les requêtes à "
"propos\n"
"                               d'un fichier de destination existant\n"
"      --strip-trailing-slashes enlever les « / » en suffixe de chacun\n"
"                               des arguments SOURCE\n"
"  -S, --suffix=SUFFIXE         écraser le suffixe d'archivage\n"
"                               usuel en utilisant SUFFIXE\n"

#: src/mv.c:339
msgid ""
"      --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
msgstr ""
"      --target-directory=RÉP   déplacer tous les fichiers SOURCE vers\n"
"                               le RÉPertoire\n"
"  -u, --update                 déplacer seulement les vieux ou\n"
"                               les tout nouveaux fichiers\n"
"  -v, --verbose                expliquer ce qui a été fait\n"

#: src/mv.c:467
#, c-format
msgid "specified target, %s is not a directory"
msgstr "cible spécifiée %s n'est pas un répertoire"

#: src/mv.c:475
msgid "when moving multiple files, last argument must be a directory"
msgstr ""
"Lors du déplacement de fichiers, le dernier argument doit être un répertoire."

#: src/nice.c:67
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Usage: %s [OPTION] [COMMANDE] [ARG]...\n"

#: src/nice.c:68
msgid ""
"Run COMMAND with an adjusted scheduling priority.\n"
"With no COMMAND, print the current scheduling priority.  ADJUST is 10\n"
"by default.  Range goes from -20 (highest priority) to 19 (lowest).\n"
"\n"
"  -n, --adjustment=ADJUST   increment priority by ADJUST first\n"
msgstr ""
"Exécuter la COMMANDE avec un horaire ajusté de priorité.\n"
"Sans aucune COMMANDE, afficher la priorité courante.  AJUSTement est de 10\n"
"par défaut.  La plage s'étend de -20 (priorité élevé) à 19 (la plus basse).\n"
"\n"
"  -AJUST                   incrémenter d'abord la priorité selon "
"l'AJUSTement\n"
"  -n, --adjustment=AJUST   identique à -AJUST\n"

#: src/nice.c:109 src/nice.c:122
#, c-format
msgid "invalid option `%s'"
msgstr "option invalide « %s »"

#: src/nice.c:147
#, c-format
msgid "invalid priority `%s'"
msgstr "priorité invalide « %s »"

#: src/nice.c:171
msgid "a command must be given with an adjustment"
msgstr "Une commande doit être soumise avec un ajustement."

#: src/nice.c:178 src/nice.c:187
msgid "cannot get priority"
msgstr "ne peut obtenir la priorité"

#: src/nice.c:192
msgid "cannot set priority"
msgstr "ne peut initialiser la priorité"

#: src/nl.c:39
msgid "Scott Bartram and David MacKenzie"
msgstr "Scott Bartram et David MacKenzie"

#: src/nl.c:180
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher chaque FICHIER sur la sortie standard, avec numéros de ligne.\n"
"Sans FICHIER, ou FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/nl.c:188
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=STYLE      utiliser STYLE pour numéroter les lignes\n"
"  -d, --section-delimiter=CC      utiliser CC pour séparer les pages\n"
"                                  logiques\n"
"  -f, --footer-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  de bas de page\n"

#: src/nl.c:193
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  d'en-tête\n"
"  -i, --page-increment=N          incrémenter de N de lignes à chaque ligne\n"
"  -l, --join-blank-lines=N        regrouper N de lignes vides\n"
"                                  en une seule ligne\n"
"  -n, --number-format=FORMAT      insérer un numéro de ligne selon FORMAT\n"
"  -p, --no-renumber               ne pas réinitialiser le nombre de lignes\n"
"                                  aux pages logiques\n"
"  -s, --number-separator=CHAÎNE   ajouter la CHAÎNE après (si possible)\n"
"                                  le numéro de ligne\n"

#: src/nl.c:201
msgid ""
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
"                                   sur chaque page logique\n"
"  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
"                                   numéroter les lignes\n"

#: src/nl.c:207
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
"CC se compose de deux caractères délimiteurs pour séparer les pages "
"logiques\n"
"un deuxième caractère manquant implique que:\n"
"taper \\\\ pour  \\.  STYLE est une des options parmi:\n"
"\n"

#: src/nl.c:213
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         numéroter toutes les lignes\n"
"  t         numéroter seulement les lignes non vides\n"
"  n         numéroter n lignes\n"
"  pEXPREG   numéroter seulement les lignes ayant une concordance à EXPREG\n"
"\n"
"FORMAT doit être choisi parmi:\n"
"\n"
"  ln   justifié à gauche, sans zéro de préfixe\n"
"  rn   justifié à droite, sans zéro de préfixe\n"
"  rz   justifié à droite, avec zéros de préfixe\n"
"\n"

#: src/nl.c:504
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "Le numéro de ligne de départ « %s » est invalide."

#: src/nl.c:514
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "L'incrément du nombre de ligne « %s » est invalide."

#: src/nl.c:527
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "Le nombre de lignes blanches « %s » est invalide."

#: src/nl.c:541
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "La largeur du champ de la numérotation de ligne « %s » est invalide."

#: src/od.c:287
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"Usage: %s [OPTION]... [FICHIER]...\n"
"  ou:  %s --traditional [FICHIER] [[+]SAUT [[+]ÉTIQUETTE]]\n"

#: src/od.c:292
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"Afficher le contenu du FICHIER selon une représentation non ambiguë\n"
"par un affichage des octets en octal par défaut sur la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/od.c:299
msgid "All arguments to long options are mandatory for short options.\n"
msgstr ""
"Tous les arguments obligatoires pour les options de formes longues\n"
"le sont aussi pour les options de formes courtes.\n"

#: src/od.c:302
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=BASE    afficher les octets selon un adressage\n"
"                              relatif dans la BASE sélectionnée\n"
"  -j, --skip-bytes=N          escamoter les N premiers octets de chaque\n"
"                              fichier\n"

#: src/od.c:306
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=N          limiter la vidange à N octets lus à l'entrée\n"
"  -s, --strings[=N]           afficher la chaîne d'au moins N caractères\n"
"                              graphiques\n"
"  -t, --format=TYPE           sélectionner les formats de sortie\n"
"  -v, --output-duplicates     ne pas utiliser * pour marquer la\n"
"                              suppression de ligne\n"
"  -w, --width[=N]             afficher N octets par ligne de sortie\n"
"      --traditional           accepter les arguments selon la forme "
"traditionnelle\n"

#: src/od.c:316
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
msgstr ""
"\n"
"Les spécifications de format traditionnels peuvent être entremêlées;\n"
"ils sont alors cumulées:\n"
"  -a   identique à -t a,    sélectionner les caractères nommés\n"
"  -b   identique à -t oC,   sélectionner les octets en octal\n"
"  -c   identique à -t c,    sélectionner les caractères ASCII ou\n"
"                            les barres obliques inverses\n"
"  -d   identique à -t u2,   sélectionner les entiers courts non signés\n"

#: src/od.c:324
msgid ""
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"  -f   identique à -t fF,   identifier en nombre flottant\n"
"  -h   identique à -t x2,   identifier en hexadécimal court\n"
"  -i   identique à -t d2,   identifier en décimal court\n"
"  -l   identique à -t d4,   identifier en décimal long\n"
"  -o   identique à -t o2,   identifier en octal court\n"
"  -x   identique à -t x2,   identifier en hexadécimal court\n"

#: src/od.c:332
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes may be . for octal and b for multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"Pour la syntaxe plus ancienne (deuxième format d'appel), SAUT\n"
"signifie -j SAUT.  ÉTIQUETTE est une pseudo adresse du premier octet "
"imprimé\n"
"incrémentée lorsque la vidange s'effectue.  Pour le SAUT et l'ÉTIQUETTE, un\n"
"préfixe 0x ou 0X indique un format hexadécimal,  les suffixes peuvent\n"
"être . pour l'octal et b pour un multiple de 512 octets.\n"
"\n"
"Le TYPE est composé d'une ou plusieurs spécifications suivantes:\n"
"\n"
"  a          caractère nommé\n"
"  c          caractère ASCII ou barre oblique inverse\n"

#: src/od.c:344
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[N]       décimal signé, N octets par entier\n"
"  f[N]       point flottant, N octets par entier\n"
"  o[N]       octal, N octets par entier\n"
"  u[N]       décimal non signé N octets par entier\n"
"  x[N]       hexadécimal, N octets par entier\n"

#: src/od.c:351
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"N est un nombre.  Le TYPE est soit d, o, u ou x, N peut être aussi C pour\n"
"sizeof(char), S pour sizeof(short), I pour sizeof(int) ou L pour\n"
"sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float),\n"
"D pour sizeof(double) ou L pour sizeof(long double).\n"

#: src/od.c:358
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  "
msgstr ""
"\n"
"BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour aucun.\n"
"OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un\n"
"multiple de 512 avec le suffixe b, de 1024 avec k et de 1048576 avec m.\n"
"L'ajout du suffixe « z » à chacun de ces types affiche des caractères\n"
"imprimables à la fin de chaque ligne sur la sortie."

#: src/od.c:366
msgid ""
"--string without a number implies 3.  --width without a number\n"
"implies 32.  By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
"--string sans être suivi d'un nombre implique 3. --width sans \n"
"nombre implique 32. Par défaut, od utilise -A o -t d2 -w 16.\n"

#: src/od.c:722 src/od.c:844
#, c-format
msgid "invalid type string `%s'"
msgstr "Le type de chaîne « %s » est invalide."

#: src/od.c:732
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"le type de chaîne « %s » est invalide;\n"
"ce système ne permet pas le type entier %lu-byte"

#: src/od.c:854
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"le type de chaîne « %s » est invalide;\n"
"ce système ne permet pas le type en point flottant %lu-byte"

#: src/od.c:917
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "Le caractère « %c » est invalide dans le type de chaîne « %s »."

#: src/od.c:1144
msgid "cannot skip past end of combined input"
msgstr "Ne peut aller au delà de la fin combinée des fichiers."

#: src/od.c:1397
msgid "old-style offset"
msgstr "Vieux style de décalage."

#: src/od.c:1707
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""
"La base numérique de sortie est invalide « %c »:\n"
"une seule des options doit être sélectionnée parmi les choix [doxn]."

#: src/od.c:1717
msgid "skip argument"
msgstr "Argument escamoté."

#: src/od.c:1725
msgid "limit argument"
msgstr "Argument limite."

#: src/od.c:1735
msgid "minimum string length"
msgstr "Longueur minimum de la chaîne."

#: src/od.c:1740 src/od.c:1806
#, c-format
msgid "%s is too large"
msgstr "%s est trop grand"

#: src/od.c:1804
msgid "width specification"
msgstr "Spécification de la largeur."

#: src/od.c:1826
msgid "no type may be specified when dumping strings"
msgstr "Aucun type ne peut être spécifié lors de l'affichage brut des chaînes."

#: src/od.c:1874
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "La deuxième opérande « %s » est invalide en mode compatible."

#: src/od.c:1895
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr ""
"En mode compatible, les 2 derniers arguments doivent être des adresses "
"relatives."

#: src/od.c:1902
msgid "compatibility mode supports at most three arguments"
msgstr "Le mode compatible supporte au plus 3 arguments."

#: src/od.c:1975
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "AVERTISSEMENT: largeur invalide %lu; utilise %d à la place."

#: src/od.c:1991
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: fmt=« %s » largeur=%d\n"

#: src/paste.c:50
msgid "David M. Ihnat and David MacKenzie"
msgstr "David M. Ihnat et David MacKenzie"

#: src/paste.c:208
msgid "standard input is closed"
msgstr "L'entrée standard est fermée."

#: src/paste.c:407
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Coller séquentiellement les lignes correspondantes de chaque\n"
"FICHIER, séparé par des tabulations, vers la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/paste.c:416
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=LISTE  utiliser les caractères de la LISTE au lieu\n"
"                           de tabulations\n"
"  -s, --serial            copier un fichier à la fois au lieu de\n"
"                           le faire en parallèle\n"

#: src/pathchk.c:146
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Usage: %s [OPTION]... NOM...\n"

#: src/pathchk.c:147
msgid ""
"Diagnose unportable constructs in NAME.\n"
"\n"
"  -p, --portability   check for all POSIX systems, not only this one\n"
msgstr ""
"Diagnostiquer les construits non portables du NOM.\n"
"\n"
" -p,  --portability   vérifier pour tous les systèmes POSIX,\n"
"                      non seulement pour le système courant\n"

#: src/pathchk.c:237
#, c-format
msgid "path `%s' contains nonportable character `%c'"
msgstr "chemin « %s » contient un caractère non portable « %c »"

#: src/pathchk.c:257
#, c-format
msgid "`%s' is not a directory"
msgstr "« %s » n'est pas un répertoire"

#: src/pathchk.c:268
#, c-format
msgid "directory `%s' is not searchable"
msgstr "Le répertoire « %s » n'est pas accessible."

#: src/pathchk.c:355
#, c-format
msgid "name `%s' has length %ld; exceeds limit of %ld"
msgstr "Le nom « %s » a une longueur de %ld; excédant la limite %ld"

#: src/pathchk.c:381
#, c-format
msgid "path `%s' has length %d; exceeds limit of %ld"
msgstr "Le chemin « %s » a une longueur de %d; excédant la limite %ld"

#: src/pinky.c:35 src/uptime.c:39
msgid "Joseph Arceneaux, David MacKenzie, and Kaveh Ghazi"
msgstr "Joseph Arceneaux, David MacKenzie et Kaveh Ghazi"

#: src/pinky.c:292
msgid "Login name: "
msgstr "Nom du compte: "

#: src/pinky.c:295
msgid "In real life: "
msgstr "En réalité: "

#: src/pinky.c:298
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:318
msgid "Directory: "
msgstr "Répertoire"

#: src/pinky.c:320
msgid "Shell: "
msgstr "Shell: "

#: src/pinky.c:341
msgid "Project: "
msgstr "Projet: "

#: src/pinky.c:367
msgid "Plan:\n"
msgstr "Plan:\n"

#: src/pinky.c:386
msgid "Login"
msgstr "Login"

#: src/pinky.c:388
msgid "Name"
msgstr "Nom"

#: src/pinky.c:389
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:391
msgid "Idle"
msgstr "Inactivité"

#: src/pinky.c:392
msgid "When"
msgstr "Quand"

#: src/pinky.c:395
msgid "Where"
msgstr "Où"

#: src/pinky.c:469
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Usage: %s [OPTION]... [USAGER]...\n"

#: src/pinky.c:470
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              afficher en format long\n"
"  -b              omettre le répertoire d'attache de l'usager\n"
"                  et son shell en format long\n"
"  -h              omettre le fichier de projet de l'usager en\n"
"                  format long\n"
"  -p              omettre le fichier de plan de l'usager en\n"
"                  format long\n"

#: src/pinky.c:478
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              omettre la ligne de l'en-tête des colonnes\n"
"                  en format court\n"
"  -w              omettre le nom complet de l'usager en format court\n"
"  -i              omettre le nom complet de l'usager et le nom de l'hôte\n"
"                  en format court\n"
"  -q              omettre le nom complet de l'usager, le nom de l'hôte\n"
"                  et le temps d'inactivité en format court\n"

#: src/pinky.c:487
#, c-format
msgid ""
"\n"
"A lightweight `finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Une version allégée du programme « finger »;  afficher les informations "
"relatives à un usager.\n"
"Le fichier utmp sera %s.\n"

#: src/pinky.c:574
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"aucun nom d'usager spécifié; au moins doit être spécifié lorsque -l est "
"utilisée"

#: src/pr.c:328
msgid "Pete TerMaat and Roland Huebner"
msgstr "Pete TerMaat et Roland Huebner"

#: src/pr.c:805
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "« --pages » intervalle des pages invalide: « %s »"

#: src/pr.c:817
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "« --pages » numéro de page de départ invalide: « %s »"

#: src/pr.c:829
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "« --pages » numéro de page finale invalide: « %s »"

#: src/pr.c:836
msgid "`--pages' starting page number is larger than ending page number"
msgstr ""
"« --pages » numéro de page de départ est plus grand que le no. de page finale"

#: src/pr.c:911
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "« --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE] » argument manquant"

#: src/pr.c:922
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "« --columns=N »    nombre invalide de colonnes: « %s »"

#: src/pr.c:976
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "« -l LONGUEUR_PAGE » contient un nombre invalide de lignes: « %s »."

#: src/pr.c:1000
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "« -N NUMBER » contient un nombre invalide de départ: « %s »."

#: src/pr.c:1012
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "« -o MARGIN » saut de ligne invalide: « %s »"

#: src/pr.c:1053
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr ""
"« -w LARGEUR_DE_PAGE » contient un nombre invalide de caractères: « %s »"

#: src/pr.c:1065
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr ""
"« -W LARGEUR_DE_PAGE » contient un nombre invalide de caractères: « %s »"

#: src/pr.c:1079
msgid "%b %e %H:%M %Y"
msgstr "%b %e %H:%M %Y"

#: src/pr.c:1088
msgid "Cannot specify number of columns when printing in parallel."
msgstr "Ne peut spécifier le nombre de colonnes lorsqu'imprimant en parallèle."

#: src/pr.c:1092
msgid "Cannot specify both printing across and printing in parallel."
msgstr "Ne peut faire un affichage à la fois croisée et en parallèle."

#: src/pr.c:1188
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr ""
"« -%c': caractères superflus ou nombre invalide dans les arguments: « %s »."

#: src/pr.c:1299
msgid "page width too narrow"
msgstr "La largeur de page est trop petite."

#: src/pr.c:2362
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr ""
"Le numéro de page de départ est plus grand que le nombre total de pages: « %"
"d »"

#: src/pr.c:2393
#, c-format
msgid "Page %d"
msgstr "Page %d"

#: src/pr.c:2759
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""
"Paginer ou mettre en colonne les FICHIERS pour impression.\n"
"\n"

#: src/pr.c:2766
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""
"  +PREMIÈRE_PAGE[:DERNIÈRE_PAGE], \n"
"      --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE]\n"
"                       débuter [stopper] l'impression à la PREMIÈRE_PAGE\n"
"                       ou à la DERNIÈRE_PAGE\n"
"  -COLUMN\n"
"      --columns=COLONNES\n"
"                       produire une sortie en COLONNES et imprimer les\n"
"                       les colonnes vers le bas à moins que -a ne soit\n"
"                       utilisé.  Équilibrer le nombre de lignes de chaque\n"
"                       colonne sur chaque page.\n"

#: src/pr.c:2774
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across         imprimer les colonnes horizontalement au lieu de\n"
"                       verticalement, utilisé ensemble avec -COLUMN\n"
"  -c, --show-control-chars\n"
"                       utiliser une notation par chapeau (^G) et octale\n"
"                       avec barre oblique inverse\n"
"  -d, --double-space\n"
"                       produire une sortie avec double espacement\n"

#: src/pr.c:2782
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=FORMAT\n"
"                          utiliser le FORMAT pour l'en-tête de la date\n"
"  -e[CAR[LARGEUR]], --expand-tabs[=CAR[LARGEUR]]\n"
"                       faire l'expansion des CARactères (ou de tabulation)\n"
"                       selon la LARGEUR de tabulation (par défaut 8)\n"
"  -F, -f,\n"
"      --form-feed\n"
"                       utiliser des sauts de page au lieu des sauts de \n"
"                       lignes pour séparer les pages (3 lignes par en-tête\n"
"                       avec -f ou 5 lignes par en-tête et bas de page sans -"
"f) \n"

#: src/pr.c:2792
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h EN-TÊTE, --header=EN-TÊTE\n"
"                       centrer l'EN-TÊTE au lieu du nom de fichier dans\n"
"                       l'en-tête de la page, \n"
"                        -h \"\" imprime une ligne blanche.\n"
"                       ne pas utiliser:  -h\"\"\n"
"  -i[CAR[LARGEUR]], --output-tabs[=CAR[LARGEUR]]\n"
"                       remplacer les blancs par des CARactères (ou\n"
"                       de tabulation) selon la LARGEUR de tabulation (8 par "
"défaut)\n"
"  -J, --join-lines\n"
"                       faire la fusion des lignes pleines, inhiber la \n"
"                       troncation des lignes -W, sans alignement des\n"
"                       colonnes -s-sep-string[=CHAÎNE] initialise les "
"séparateurs\n"

#: src/pr.c:2801
msgid ""
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l LONGUEUR_DE_PAGE, --length LONGUEUR_DE_PAGE\n"
"                       utiliser LONGUEUR_DE_PAGE au lieu de 66 lignes\n"
"                       (par défaut de lignes est de 56 pour un texte,\n"
"                       avec -f de 63)\n"
"  -m, --merge          imprimer tous les fichiers en parallèle un par\n"
"                       colonne, tronque les lignes, mais joint les\n"
"                       lignes de pleine longueur avec -j\n"

#: src/pr.c:2808
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n, --number-lines[=SÉP[CHIFFRES]]\n"
"                       numéroter les lignes, par des CHIFFRES (5), suivi de\n"
"                       SÉParateurs (TAB) par défaut le compteur débute\n"
"                       avec la première ligne du fichier d'entrée\n"
"  -N, --first-line-number=VALEUR\n"
"                       débuter le compteur avec la VALEUR avec la 1ère "
"ligne\n"
"                       de la 1ère page imprimée (voir +PREMIÈRE_PAGE)\n"

#: src/pr.c:2816
msgid ""
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=MARGE\n"
"                       débuter l'impression de chaque ligne après une\n"
"                       MARGE d'espacement  (n'affecte pas -w)\n"
"  -r, --no-file-warnings\n"
"                       inhiber les avertissements lorsqu'un fichier\n"
"                       ne peut être ouvert\n"

#: src/pr.c:2823
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[CAR], --separator[=CHAÎNE]\n"
"                       séparer les colonnes à l'aide d'un simple CARactère\n"
"                       par défaut le caractère de TABulation sans -w et 'no "
"char»\n"
"                       avec -w et -s[CAR] inhibe la troncation de ligne des "
"3 colonnes\n"
"                       options de 3 colonnes (-COLUMN|-a - COLUMN|-m) sauf "
"si -w est utilisé\n"

#: src/pr.c:2830
msgid "  -SSTRING, --sep-string[=STRING]\n"
msgstr "  -SSTRING, --sep-string[=CHAÎNE]\n"

#: src/pr.c:2833
msgid ""
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
msgstr ""
"                       séparer les colonnes à l'aide d'une CHAÎNE\n"
"                       sans -S: le séparateur par défaut est <TAB> avec -J "
"et <ESPACE>\n"
"                       autrement (identique as -S« »), sans effet sur les "
"options\n"
"                       des colonnes\n"
"  -t, --omit-header\n"
"                      inhiber l'en-tête et le bas de page\n"

#: src/pr.c:2839
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                       inhiber l'en-tête et le bas de page, éliminer\n"
"                       les agencements de page par saut de page indiqués\n"
"                       dans les fichiers d'entrée\n"
"  -v, --show-nonprinting\n"
"                       utiliser la notation octale avec barre oblique\n"
"                       inverse\n"
"  -w LARGEUR_DE_PAGE,\n"
"      --width=LARGEUR_DE_PAGE\n"
"                       utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\\n\"\n"
"                       tronquer les lignes (voir aussi l'option -j)\n"

#: src/pr.c:2849
msgid ""
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W LARGEUR_DE_PAGE,\n"
"       --page-width=LARGEUR_DE_PAGE\n"
"                       toujours utiliser une LARGEUR_DE_PAGE de 72 "
"caractères,\n"
"                       tronquer les lignes, sauf lorsque l'option -J est "
"utilisée\n"
"                       sans interférence avec -S ou -s\n"

#: src/pr.c:2857
msgid ""
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"\n"
"L'option -T est implicite lorsque -l N est utilisée et avec -f quand nn <= "
"10\n"
"ou <= 3. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"

#: src/printenv.c:43
msgid "David MacKenzie and Richard Mlynarik"
msgstr "David MacKenzie et Richard Mlynarik"

#: src/printenv.c:63
#, c-format
msgid ""
"Usage: %s [VARIABLE]...\n"
"  or:  %s OPTION\n"
"If no environment VARIABLE specified, print them all.\n"
"\n"
msgstr ""
"Usage: %s [VARIABLE]...\n"
"   ou: %s OPTION\n"
"Si aucune VARIABLE d'environnement n'est spécifiée, les afficher toutes.\n"
"\n"

#: src/printf.c:87
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"AVERTISSEMENT: %s: caractère(s) suivant le caractère de constante ignoré(s)"

#: src/printf.c:100
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"

#: src/printf.c:105
msgid ""
"Print ARGUMENT(s) according to FORMAT.\n"
"\n"
msgstr ""
"Afficher les ARGUMENTS selon le FORMAT.\n"
"\n"

#: src/printf.c:111
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
"  \\0NNN   character with octal value NNN (0 to 3 digits)\n"
"  \\\\      backslash\n"
msgstr ""
"\n"
"Le FORMAT contrôle la sortie comme la fonction printf() en C.\n"
"Les séquences interprétées sont:\n"
"\n"
"  \\\"      guillemets\n"
"  \\0NNN   caractère ayant la valeur octale NNN (0 à 3 chiffres)\n"
"  \\\\      barre oblique inverse\n"

#: src/printf.c:119
msgid ""
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\f      form feed\n"
msgstr ""
"  \\a      bip sonore d'alerte\n"
"  \\b      retour arrière\n"
"  \\c      ne pas afficher d'autres informations sur la sortie\n"
"  \\f      saut de page\n"

#: src/printf.c:125
msgid ""
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\n      saut de ligne\n"
"  \\r      retour de chariot\n"
"  \\t      tabulation horizontale\n"
"  \\v      tabulation verticale\n"

#: src/printf.c:131
msgid ""
"  \\xNN    byte with hexadecimal value NN (1 to 2 digits)\n"
"\n"
"  \\uNNNN  character with hexadecimal value NNNN (4 digits)\n"
"  \\UNNNNNNNN  character with hexadecimal value NNNNNNNN (8 digits)\n"
msgstr ""
"  \\xNNN   caractère ayant la valeur hexadécimale NN (1 à 3 chiffres)\n"
"\n"
"  \\uNNNN  caractère avec la valeur hexadécimale NNNN (4 chiffres)\n"
"  \\UNNNNNNNN  caractère ayant la valeur hexadécimal NNNNNNNN (8 chiffres)\n"

#: src/printf.c:137
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with `\\' escapes interpreted\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      le caractère %%\n"
"  %b      PARAMÈTRES comme une chaîne avec « \\ » d'échappement interprétés\n"
"\n"
"ainsi que toutes les spécifications de format en C se terminant par une des\n"
"options suivantes diouxXfeEgGcs, avec un ARGUMENT\n"
"converti au premier type approprié.\n"
"Les largeurs variables de champ sont supportées.\n"

#: src/printf.c:160
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: valeur numérique attendue."

#: src/printf.c:162
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: valeur pas complètement convertie."

#: src/printf.c:254 src/printf.c:280
msgid "missing hexadecimal number in escape"
msgstr "Nombre hexadécimal manquant dans l'échappement."

#: src/printf.c:292
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "nom de caractère universel invalide \\%c%0*x"

#: src/printf.c:472
#, c-format
msgid "invalid field width: %s"
msgstr "largeur de champ invalide: %s"

#: src/printf.c:498
#, c-format
msgid "invalid precision: %s"
msgstr "précision invalide: %s"

#: src/printf.c:519
#, c-format
msgid "%%%c: invalid directive"
msgstr "%%%c: directive invalide"

#: src/printf.c:576
#, c-format
msgid "Usage: %s format [argument...]\n"
msgstr "Usage: %s format [argument...]\n"

#: src/printf.c:594
#, c-format
msgid "warning: ignoring excess arguments, starting with `%s'"
msgstr "AVERTISSEMENT:  arguments superflus ignorés, débutant avec « %s »"

#: src/ptx.c:410
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (pour regexp « %s »)"

#: src/ptx.c:1859
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Usage: %s [OPTION]... [ENTRÉE]...   (sans l'option -G)\n"
"  ou:  %s -G [OPTION]... [ÉNTRÉE [SORTIE]]\n"

#: src/ptx.c:1863
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""
"Produire un index permuté, incluant le contexte des mots des fichiers "
"d'entrée.\n"
"\n"

#: src/ptx.c:1870
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A, --auto-reference           générer des références automatiquement\n"
"  -C, --copyright                afficher les Droits d'auteur et les "
"conditions\n"
"                                 de recopie\n"
"  -G, --traditional              faire fonctionner « ptx » comme en System "
"V\n"
"  -F, --flag-truncation=CHAÎNE   utiliser la CHAÎNE pour indiquer la "
"troncation\n"
"                                 des lignes\n"

#: src/ptx.c:1876
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=CHAÎNE        nom de la macro à utiliser au lieu de « xx "
"»\n"
"  -O, --format=roff              générer la sortie comme des directives "
"roff\n"
"  -R, --right-side-refs          placer les références à droite, sans "
"décompte -w\n"
"  -S, --sentence-regexp=REGEXP   pour la fin des lignes ou des phrases\n"
"  -T, --format=tex               générer la sortie comme des directives TeX\n"

#: src/ptx.c:1883
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       utiliser REGEXP pour établir la concordance "
"avec chaque mot\n"
"  -b, --break-file=FICHIER       utiliser les coupures de mots de ce "
"FICHIER\n"
"  -f, --ignore-case              ramener les minuscules en majuscules pour "
"le trie\n"
"  -g, --gap-size=N               espacer de N blancs les colonnes entre les "
"champs\n"
"  -i, --ignore-file=FICHIER      lire la liste des mots à ignorer de ce "
"FICHIER\n"
"  -o, --only-file=FICHIER        lire la liste des mots uniquement de ce "
"FICHIER\n"

#: src/ptx.c:1891
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               donner la référence du 1er champ de chaque "
"ligne\n"
"  -t, --typeset-mode               - option non implanté -\n"
"  -w, --width=N                  largeur des colonnes, références exclues\n"

#: src/ptx.c:1898
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard. -F par "
"défaut.\n"

#: src/ptx.c:1978
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
msgstr ""
"Ce programme est un logiciel libre; vous pouvez le redistribuer ou le\n"
"modifier selon les termes de la License Publique Générale de GNU, publiée\n"
"par la Free Software Foundation (soit la version 2 ou soit, à votre\n"
"discrétion, toute version ultérieure).\n"
"\n"

#: src/ptx.c:1985
msgid ""
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
msgstr ""
"Ce programme est distribué dans l'espoir qu'il soit utile,\n"
"mais AUCUNE garantie n'est donnée tant pour des raisons COMMERCIALES que\n"
"pour RÉPONDRE À UN BESOIN PARTICULIER.  Consulter la licence\n"
"GNU General Public License pour plus de détails.\n"
"\n"

#: src/ptx.c:1992
msgid ""
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"Vous devriez avoir reçu copie de la Licence Publique Générale de GNU\n"
"avec ce programme; sinon, écrire à la Free Software Foundation, Inc.,\n"
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"

#: src/pwd.c:47
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Afficher le nom complet du fichier du répertoire courant.\n"
"\n"

#: src/pwd.c:74
msgid "ignoring non-option arguments"
msgstr "rejet des arguments qui ne sont pas des options reconnues"

#: src/pwd.c:78
msgid "cannot get current directory"
msgstr "ne peut obtenir le répertoire courant"

#: src/readlink.c:69
#, c-format
msgid "Usage: %s [OPTION]... FILE\n"
msgstr "Usage: %s [OPTION]... FICHIER\n"

#: src/readlink.c:70
msgid ""
"Display value of a symbolic link on standard output.\n"
"\n"
msgstr ""
"Afficher la valeur d'un lien symbolique sur la sortie standard.\n"
"\n"

#: src/readlink.c:72
msgid ""
"  -f, --canonicalize      canonicalize by following every symlink in every\n"
"                          component of the given path recursively\n"
"  -n, --no-newline        do not output the trailing newline\n"
"  -q, --quiet,\n"
"  -s, --silent            suppress most error messages\n"
"  -v, --verbose           report error messages\n"
msgstr ""
"  -f, --canonicalize      canoniser en suivant chaque lien symbolique dans "
"chacun\n"
"                          des composants d'un chemin donné récursivement\n"
"  -n, --no-newline        ne pas afficher de retour de chariot en suffixe\n"
"  -q, --quiet,            \n"
"  -s, --silent            supprimer la pluplart des messages d'erreur\n"
"  -v, --verbose           rapporter les message d'erreur\n"

#: src/remove.c:394
#, c-format
msgid "cannot chdir from %s to .."
msgstr "ne peut aller du répertoire %s vers .."

#: src/remove.c:407 src/remove.c:488
#, c-format
msgid "cannot lstat `.' in %s"
msgstr "ne peut évaluer par lstat() « . » dans %s"

#: src/remove.c:414 src/remove.c:492
#, c-format
msgid "%s changed dev/ino"
msgstr "%s modifié par dev/ino"

#: src/remove.c:574 src/remove.c:712 src/remove.c:881 src/remove.c:984
#, c-format
msgid "cannot lstat %s"
msgstr "ne peut évaluer par lstat() %s"

#: src/remove.c:603
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: descendre dans un répertoire protégé en écriture %s?"

#: src/remove.c:604
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: descendre dans le répertoire %s?"

#: src/remove.c:614
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: détruire un fichier protégé en écriture %s %s? "

#: src/remove.c:615
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: détruire %s %s? "

#: src/remove.c:639
#, c-format
msgid "removed %s\n"
msgstr "détruit %s\n"

#: src/remove.c:654 src/remove.c:1059
#, c-format
msgid "removed directory: %s\n"
msgstr "détruire le répertoire: %s\n"

#: src/remove.c:734 src/remove.c:751 src/remove.c:1064
#, c-format
msgid "cannot remove directory %s"
msgstr "ne peut détruire le répertoire %s"

#: src/remove.c:815
#, c-format
msgid "cannot open directory %s"
msgstr "ne peut ouvrir le répertoire %s"

#: src/remove.c:896 src/remove.c:1002
#, c-format
msgid "cannot chdir from %s to %s"
msgstr "ne peut aller du le répertoire %s vers %s"

#: src/remove.c:904
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"AVERTISSEMENT: structure de répertoire circulaire.\n"
"Cela signifie très certainement que votre système de fichiers est corrompu.\n"
"AVISER VOTRE ADMINISTRATEUR SYSTÈME.\n"
"Le répertoire suivant fait parti du cycle:\n"
"  %s\n"

#: src/remove.c:1098
msgid "cannot remove `.' or `..'"
msgstr "ne peut enlever « . » or « .. »"

#: src/rm.c:60
msgid "Paul Rubin, David MacKenzie, Richard Stallman, and Jim Meyering"
msgstr "Paul Rubin, David MacKenzie, Richard Stallman et Jim Meyering"

#: src/rm.c:99 src/touch.c:244
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Usage: %s [OPTION]... FICHIER...\n"

#: src/rm.c:100
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -d, --directory       unlink FILE, even if it is a non-empty directory\n"
"                          (super-user only)\n"
"  -f, --force           ignore nonexistent files, never prompt\n"
"  -i, --interactive     prompt before any removal\n"
"  -r, -R, --recursive   remove the contents of directories recursively\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"Enlever (unlink) les FICHIER(s).\n"
"\n"
"  -d, --directory       enlever le répertoire, même si non vide\n"
"                        (usager root seulement)\n"
"  -f, --force           ignorer les fichiers inexistants,\n"
"                        ne pas demander de confirmation\n"
"  -i, --interactive     demander une confirmation avant chaque destruction\n"
"  -r, -R, --recursive   enlever le contenu des répertoires récursivement\n"
"  -v, --verbose         expliquer ce qui a été fait\n"

#: src/rm.c:112
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a `-', for example `-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"Pour enlever un fichier dont le nom début par « - », par exemple « -foo »,\n"
"utiliser une de ces commandes:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:121
msgid ""
"\n"
"Note that if you use rm to remove a file, it is usually possible to recover\n"
"the contents of that file.  If you want more assurance that the contents "
"are\n"
"truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Noter que si vous utilisez « rm » pour détruire un fichier, il est "
"habituellement possible\n"
"de récupérer le contenu de ce fichier. Si vous désirez plus d'assurance à "
"l'effet\n"
"de ne pas pouvoir récupérer le contenu, considérez shred.\n"

#: src/rmdir.c:116 src/rmdir.c:217
#, c-format
msgid "removing directory, %s"
msgstr "destruction du répertoire %s"

#: src/rmdir.c:146
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Usage: %s [OPTION]... RÉPERTOIRE...\n"

#: src/rmdir.c:147
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                  is non-empty\n"
msgstr ""
"Enlever les RÉPERTOIRES, s'ils sont vides.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignorer les échecs qui sont causées uniquement\n"
"                  en raison d'un répertoire qui n'est pas vide\n"

#: src/rmdir.c:154
msgid ""
"  -p, --parents   remove DIRECTORY, then try to remove each directory\n"
"                  component of that path name.  E.g., `rmdir -p a/b/c' is\n"
"                  similar to `rmdir a/b/c a/b a'.\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   enlever le RÉPERTOIRE, ensuite essayer d'enlever\n"
"                  chaque répertoire composant le nom du chemin,\n"
"                  i.e. « rmdir -p a/b/c » est identique à «rmdir a/b/c a/b "
"a'.\n"
"  -v, --verbose   afficher un diagnostic pour chaque répertoire traité\n"

#: src/seq.c:82
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Usage: %s [OPTION]... DERNIER\n"
"  ou:  %s [OPTION]... PERMIER DERNIER\n"
"  ou:  %s [OPTION]... PREMIER INCRÉMENT DERNIER\n"

#: src/seq.c:87
#, c-format
msgid ""
"Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
"\n"
"  -f, --format=FORMAT      use printf style floating-point FORMAT (default: %"
"g)\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"Afficher les nombres du PREMIER jusqu'au DERNIER,\n"
"selon le PAS d'incrémentation.\n"
"\n"
"  -f, --format FORMAT      utiliser le style de FORMAT de printf(3)\n"
"                           (par défaut: %g)\n"
"  -s, --separator CHAÎNE   utiliser la CHAÎNE pour séparer les nombres\n"
"                           (par défaut: \\n)\n"
"  -w, --equal-width        équilibrer les largeurs en remplissant\n"
"                           par des zéros de tête\n"

#: src/seq.c:96
#, c-format
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT should be positive if FIRST is smaller than LAST, and negative\n"
"otherwise.  When given, the FORMAT argument must contain exactly one of\n"
"the printf-style, floating point output formats %e, %f, %g\n"
msgstr ""
"\n"
"Si PREMIER ou PAS sont omis, ils prennent la valeur 1 par défaut.\n"
"PREMIER, PAS, DERNIER sont valeurs interprétées en notation flottante.\n"
"PAS doit être > 0 si PREMIER est plus petit que DERNIER  et\n"
"négatif autrement.  Lorsque fourni, l'argument de FORMAT doit contenir\n"
"exactement un format de style printf, \n"
"et la notation flottante %e, %f, or %g.\n"

#: src/seq.c:119
#, c-format
msgid "invalid floating point argument: %s"
msgstr "arguement en virgule flottante invalide: %s"

#: src/seq.c:189
msgid ""
"when the starting value is larger than the limit,\n"
"the increment must be negative"
msgstr ""
"lorsque la valeur de départ est plus grande que la limite,\n"
"l'incrément doit être négatif."

#: src/seq.c:213
msgid ""
"when the starting value is smaller than the limit,\n"
"the increment must be positive"
msgstr ""
"quand la valeur de départ est plus petite que la limite,\n"
"l'incrément doit être positif"

#: src/seq.c:423
#, c-format
msgid "invalid format string: `%s'"
msgstr "format de chaîne invalide: « %s »"

#: src/seq.c:445
msgid "format string may not be specified when printing equal width strings"
msgstr ""
"format de chaîne ne peut pas être spécifié quand l'impression est égal à la "
"largeur des chaînes"

#: src/shred.c:160
#, c-format
msgid "Usage: %s [OPTIONS] FILE [...]\n"
msgstr "Usage: %s [OPTIONS] FICHIER [...]\n"

#: src/shred.c:161
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
"\n"
msgstr ""
"Écraser un fichier de façon répétitive, afin de rendre difficile\n"
"toute récupération des données par du matériel même coûteux.\n"
"\n"

#: src/shred.c:169
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  Overwrite N times instead of the default (%d)\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force         modifier les permissions pour permettre\n"
"                      l'écriture si nécessaire\n"
"  -n, --iterations=N  écraser N fois au lieu du nombre par défaut (%d)\n"
"  -s, --size=N        déchiqueter N octets (les suffixes k, M, G sont "
"acceptés)\n"

#: src/shred.c:174
msgid ""
"  -u, --remove   truncate and remove file after overwriting\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
"  -              shred standard output\n"
msgstr ""
"  -u, --remove        tronquer et détruire le fichier après l'avoir écraser\n"
"  -v, --verbose       afficher un indicateur de progrès\n"
"  -x, --exact         ne pas arrondir la taille des fichiers\n"
"                      jusqu'au prochain bloc complet;\n"
"                      comportement par défaut pour les fichiers non "
"réguliers\n"
"  -z, --zero          ajouter une réécriture finale avec des zéros\n"
"                      pour camoufler le déchiquetage du fichier\n"
"                      déchiqueter l'entrée standard \n"

#: src/shred.c:184
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.  When operating on regular\n"
"files, most people use the --remove option.\n"
"\n"
msgstr ""
"\n"
"Détruire le FICHIER si --remove (-u) est spécifié. Le défaut est de ne pas "
"détruire\n"
"les fichiers parce qu'il est commun d'opérer sur le fichier du périphérique "
"comme /dev/hda,\n"
"et habituellement ces fichiers ne sont pas détruits.  Sur des fichier "
"réguliers,\n"
"la plupart des gens utilise l'option --remove.\n"
"\n"

#: src/shred.c:192
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the filesystem overwrites data in place.  This is the traditional\n"
"way to do things, but many modern filesystem designs do not satisfy this\n"
"assumption.  The following are examples of filesystems on which shred is\n"
"not effective:\n"
"\n"
msgstr ""
"ATTENTION: noter que le déchiquetage s'appuie sur l'hypothèse que \n"
"le système de fichiers écrasera les données en place. Cela est la manière\n"
"traditionnelle de faire les choses, mais plusieurs design modernes de "
"systèmes\n"
"de fichiers ne se satisfont pas de cette hypothèse. Les exemples suivants de "
"systèmes\n"
"de fichiers sont ceux où le déchiquetage n'est pas effectif:\n"
"\n"

#: src/shred.c:200
msgid ""
"* log-structured or journaled filesystems, such as those supplied with\n"
"  AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* filesystems that write redundant data and carry on even if some writes\n"
"  fail, such as RAID-based filesystems\n"
"\n"
"* filesystems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* systèmes de fichiers à journalisation ou à structure de journalisation \n"
"  comme ceux fournis avec AIX et Solaris (et JFS, ReiserFS, XFS, etc.)\n"
"\n"
"* systèmes de fichiers avec écriture redondante et soutienne les écritures\n"
"  même lorsqu'il y a erreur d'écriture\n"
"  comme sur les systèmes de fichiers RAID\n"
"\n"
"* systèmes de fichiers qui prennent des instantanés, comme\n"
"  le serveur NFS de Network Appliance\n"
"\n"

#: src/shred.c:210
msgid ""
"* filesystems that cache in temporary locations, such as NFS\n"
"  version 3 clients\n"
"\n"
"* compressed filesystems\n"
"\n"
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"* systèmes de fichiers qui utilisent des caches temporaires,\n"
"  comme NFS la version 3 clientète\n"
"\n"
"* systèmes de fichiers compressés\n"
"\n"
"Il faut ajouter que l'archivage des systèmes de fichiers et systèmes miroirs "
"distants  peuvent\n"
"contenir des copies de fichiers qui n'ont pas été détruits et qui "
"permettraient qui\n"
"fichier déchiqueté soit récupéré plus tard.\n"

#: src/shred.c:808
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: ne peut rembobiner"

#: src/shred.c:831
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: pass %lu/%lu (%s)..."

#: src/shred.c:868
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: erreur d'écriture au décalage %s"

#: src/shred.c:897
#, c-format
msgid "%s: file too large"
msgstr "%s: fichier trop gros"

#: src/shred.c:920
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: passes %lu/%lu (%s)...%s"

#: src/shred.c:936
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: passes %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:1195
#, c-format
msgid "%s: invalid file type"
msgstr "%s: type de fichier invalide"

#: src/shred.c:1212
#, c-format
msgid "%s: file has negative size"
msgstr "%s: le fichier a une taille négative."

#: src/shred.c:1265
#, c-format
msgid "%s: error truncating"
msgstr "%s: erreur de troncation"

#: src/shred.c:1286
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: ne peut déchiqueter "

#: src/shred.c:1371
#, c-format
msgid "%s: removing"
msgstr "destruction de « %s »"

#: src/shred.c:1412
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: renommé à %s"

#: src/shred.c:1438
#, c-format
msgid "%s: removed"
msgstr "%s: détruit"

#: src/shred.c:1503
#, c-format
msgid "%s: cannot remove"
msgstr "Ne peut enlever « %s »."

#: src/shred.c:1551
#, c-format
msgid "%s: invalid number of passes"
msgstr "%s: nombre de passes invalide"

#: src/shred.c:1568
#, c-format
msgid "%s: invalid file size"
msgstr "%s: longueur de fichier invalide"

#: src/sleep.c:34
msgid "Jim Meyering and Paul Eggert"
msgstr "Jim Meyering et Paul Eggert"

#: src/sleep.c:52
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be `s' for seconds (the default),\n"
"`m' for minutes, `h' for hours or `d' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.\n"
"\n"
msgstr ""
"Usage: %s NOMBRE[SUFFIXE]...\n"
"   ou: %s OPTION\n"
"Effectuer une pause de NOMBRE de secondes. Le SUFFIXE peut être « s » pour "
"des\n"
"secondes (par défaut), « m » pour des  minutes, « h » pour des heures ou « d "
"»\n"
"pour des jours. Contrairement à la plupart des implantations qui requierent "
"un\n"
"nombre entier, ici le NOMBRE peut être un nombre arbitraire en virgule "
"flottante.\n"
"\n"

#: src/sleep.c:155
#, c-format
msgid "invalid time interval `%s'"
msgstr "intervalle de temps invalide « %s »"

#: src/sleep.c:166 src/tail.c:1031
msgid "cannot read realtime clock"
msgstr "ne peut lire l'horloge en temps réel"

#: src/sort.c:53
msgid "Mike Haertel and Paul Eggert"
msgstr "Mike Haertel et Paul Eggert"

#: src/sort.c:280
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"Ordering options:\n"
"\n"
msgstr ""
"Afficher la concaténation triée de tous les FICHIERS sur la sortie "
"standard.\n"
"\n"
"Options de tri:\n"
"\n"

#: src/sort.c:289
msgid ""
"  -b, --ignore-leading-blanks ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ignorer les blancs de tête\n"
"  -d, --dictionary-order      considérer seulement les blancs et\n"
"                              les caractères alphanumériques\n"
"  -f, --ignore-case           suivre les caractères minuscules et "
"majuscules\n"

#: src/sort.c:294
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -r, --reverse               reverse the result of comparisons\n"
"\n"
msgstr ""
"  -g, --general-numeric-sort  comparer selon la valeur numérique des "
"caractères\n"
"  -i, --ignore-nonprinting    considérer seulement les caractères "
"imprimables\n"
"  -M, --month-sort            comparer (inconnu) < « JAN » < ... < « DÉC »\n"
"  -n, --numeric-sort          comparer selon la valeur numérique de la "
"chaîne\n"
"  -r, --reverse               afficher dans l'ordre inverse le résultat\n"
"\n"

#: src/sort.c:302
msgid ""
"Other options:\n"
"\n"
"  -c, --check               check whether input is sorted; do not sort\n"
"  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"Autres options:\n"
"\n"
"  -c, --check               vérifier si l'entrée est triée; ne pas trier\n"
"  -k, --key=POS1[,POS2]     débuter avec la clé à la POS1, terminer à POS 2 "
"(origine 1)\n"
"  -m, --merge               faire la fusion des fichiers déjà triés; ne pas "
"trier\n"
"  -o, --output=FICHIER      écrire le résultat au FICHIER au lieu de la "
"sortie standard\n"
"  -s, --stable              stabiliser le tri en inhibant la comparaison de "
"dernier recours\n"
"  -S, --buffer-size=TAILLE  utiliser la TAILLE pour le tampon mémoire "
"principal\n"

#: src/sort.c:312
#, c-format
msgid ""
"  -t, --field-separator=SEP use SEP instead of non- to whitespace "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c: check for strict ordering\n"
"                              otherwise: output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=SEP utiliser le SÉParateur au lieu de non- par les "
"transitions d'espace blancs\n"
"  -T, --temporary-directory=RÉP utiliser le RÉP pour les fichiers "
"temporaires, pas $TMPDIR ou %s\n"
"                            options multiples pour spécifier de multiples "
"répertoires\n"
"  -u, --unique              avec -c: vérifier l'ordonnancement strict\n"
"                            autrement: afficher les premiers d'une passe "
"équivalente\n"

#: src/sort.c:319
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     terminer les lignes avec l'octet 0, \n"
"                            et non pas par un retour de chariot\n"

#: src/sort.c:324
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field.  OPTS is one or more single-letter ordering options, which\n"
"override global ordering options for that key.  If no key is given, use the\n"
"entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS est F[.C][OPTS], où F est le numéro du champ et C le caractère de la\n"
"position dans le champ.  OPTS se compose d'une ou plusieurs lettres "
"simples,\n"
"laquelle écrase l'ordonnancement global pour cette clé.\n"
"Si aucune clé n'est donnée, la ligne entière est utilisée comme clé.\n"
"\n"
"TAILLE peut être suivi d'un des suffixe multiplicatif suivant:\n"

#: src/sort.c:333
#, c-format
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% de mémoire, b 1, k 1024 (par défaut), et ainsi de suite pour M, G, T, "
"P, E, Z, Y.\n"
"\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"
"*** AVERTISSEMENT ***\n"
"La localisation utilisée dans l'environnement affecte l'ordre du tri.\n"
"Utiliser LC_ALL=C pour obtenir un tri selon un ordre traditionnel qui "
"utilise la valeur\n"
"native des octets.\n"

#: src/sort.c:444
msgid "cannot create temporary file"
msgstr "Ne peut créer de fichier temporaire"

#: src/sort.c:467
msgid "open failed"
msgstr "Échec d'ouverture"

#: src/sort.c:487 src/sort.c:2496
msgid "close failed"
msgstr "Échec de fermeture"

#: src/sort.c:495
msgid "write failed"
msgstr "Echec d'écriture."

#: src/sort.c:641
msgid "sort size"
msgstr "taille du tri"

#: src/sort.c:715
msgid "stat failed"
msgstr "Échec de stat()"

#: src/sort.c:972
msgid "read failed"
msgstr "Échec de lecture"

#: src/sort.c:1570
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: désordre: "

#: src/sort.c:1574
msgid "standard error"
msgstr "erreur standard"

#: src/sort.c:2032
#, c-format
msgid "%s: invalid field specification `%s'"
msgstr "%s: spécification invalide du champ « %s »"

#: src/sort.c:2058
#, c-format
msgid "%s: count `%.*s' too large"
msgstr "%s: décompte « %.*s » trop grand"

#: src/sort.c:2064
#, c-format
msgid "%s: invalid count at start of `%s'"
msgstr "%s: compteur invelide au départ de « %s »."

#: src/sort.c:2298
msgid "invalid number after `-'"
msgstr "nombre invalide après « - »"

#: src/sort.c:2301 src/sort.c:2347 src/sort.c:2374
msgid "invalid number after `.'"
msgstr "nombre invalide après « . »"

#: src/sort.c:2304 src/sort.c:2383
msgid "stray character in field spec"
msgstr "caractère égaré dans le champ de spécification"

#: src/sort.c:2338
msgid "invalid number at field start"
msgstr "nombre invalide dans le champ de départ"

#: src/sort.c:2342 src/sort.c:2370
msgid "field number is zero"
msgstr "numéro de champ est zéro"

#: src/sort.c:2351
msgid "character offset is zero"
msgstr "adresse relative du caractère est zéro"

#: src/sort.c:2366
msgid "invalid number after `,'"
msgstr "nombre invalide après « , »"

#: src/sort.c:2411
#, c-format
msgid "multi-character tab `%s'"
msgstr "tab multi-caractère « %s »"

#: src/sort.c:2479
#, c-format
msgid "extra operand `%s' not allowed with -c"
msgstr "opérande surnuméraire « %s » non permise avec -c"

#: src/split.c:96
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "Usage: %s [OPTION] [ENTRÉE [PRÉFIXE]]\n"

#: src/split.c:100
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
msgstr ""
"Afficher sur la sortie des morceaux de l'ENTRÉE de taille selon\n"
"PRÉFIXEaa, PRÉFIXEab, ...; le PRÉFIXE par défaut est « x ».\n"
"Sans ENTRÉE, ou quand l'ENTRÉE est -, lire l'entrée standard.\n"
"\n"

#: src/split.c:108
#, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"  -a, --suffix-length=N   utiliser les suffixes de longueur N (par défaut %"
"d)\n"
"  -b, --bytes=N           écrire N octets par fichier de sortie\n"
"  -C, --line-bytes=N      écrire au plus N octets par ligne\n"
"                          par fichier de sortie\n"
"  -l, --lines=N           écrire N lignes par fichier de sortie\n"

#: src/split.c:114
msgid ""
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
msgstr ""
"      --verbose           afficher un diagnostic sur la sortie standard "
"d'erreur\n"
"                            juste avant l'ouverture du fichier de sortie\n"

#: src/split.c:171
msgid "Output file suffixes exhausted"
msgstr "Produire les suffixes des fichiers épuisés"

#: src/split.c:189
#, c-format
msgid "creating file `%s'\n"
msgstr "Création du fichier « %s »\n"

#: src/split.c:341
msgid "cannot split in more than one way"
msgstr "Ne peut segmenter plus d'une façon."

#: src/split.c:394
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s: longueur de suffixe invalide"

#: src/split.c:408 src/split.c:434
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: nombre d'octets invalide."

#: src/split.c:421
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: nombre de lignes invalide."

#: src/split.c:470
#, c-format
msgid "`-%d' option is obsolete; use `-l %d'"
msgstr "option « -%d » est obsolète; utiliser « -l %d »"

#: src/split.c:483
msgid "invalid number"
msgstr "Nombre invalide."

#: src/stat.c:326
msgid "*** invalid date/time ***"
msgstr "*** date/heure invalide ***"

#: src/stat.c:608
#, c-format
msgid "cannot read file system information for %s"
msgstr "ne peut lire les informations du système de fichier pour %s"

#: src/stat.c:684
#, c-format
msgid "Usage: %s [OPTION] FILE...\n"
msgstr "Usage: %s [OPTION] FICHIER...\n"

# src/stat.c:300 MRO
#: src/stat.c:685
msgid ""
"Display file or filesystem status.\n"
"\n"
"  -f, --filesystem      display filesystem status instead of file status\n"
"  -c  --format=FORMAT   use the specified FORMAT instead of the default\n"
"  -L, --dereference     follow links\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"Afficher l'état des fichiers ou du système de fichiers.\n"
"\n"
"  -f, --filesystem           afficher l'état du système de fichiers\n"
"                              au lieu de l'état des fichiers\n"
"  -c  --format=FORMAT        utiliser le FORMAT spécifié au lieu du défaut\n"
"  -L, --deference            suivre les liens\n"
"  -t, --terse                afficher l'information en format terse\n"

#: src/stat.c:696
msgid ""
"\n"
"The valid format sequences for files (without --filesystem):\n"
"\n"
"  %A   Access rights in human readable form\n"
"  %a   Access rights in octal\n"
"  %B   The size in bytes of each block reported by `%b'\n"
"  %b   Number of blocks allocated (see %B)\n"
msgstr ""
"\n"
"Le format valide pour les séquences des fichiers (sans --filesystem):\n"
"\n"
"  %A   droits d'accès en format lisible pour un humain\n"
"  %a   droits d'accès en octal\n"
"  %B   la taille en octets de chaque bloc rapporté par `%b'\n"
"  %b   nombre de blocs alloués (voir %B)\n"

#: src/stat.c:704
msgid ""
"  %D   Device number in hex\n"
"  %d   Device number in decimal\n"
"  %F   File type\n"
"  %f   Raw mode in hex\n"
"  %G   Group name of owner\n"
"  %g   Group ID of owner\n"
msgstr ""
"  %D   numéro de périphéque en hexadécimal\n"
"  %d   numéro de périphérique en décimal\n"
"  %F   type de fichier\n"
"  %f   mode brut en hexadécimal\n"
"  %G   nom de groupe du propriétaire\n"
"  %g   identificateur de groupe du propriétaire\n"

#: src/stat.c:712
msgid ""
"  %h   Number of hard links\n"
"  %i   Inode number\n"
"  %N   Quoted File name with dereference if symbolic link\n"
"  %n   File name\n"
"  %o   IO block size\n"
"  %s   Total size, in bytes\n"
"  %T   Minor device type in hex\n"
"  %t   Major device type in hex\n"
msgstr ""
"  %h - nombre de liens directs (hard)\n"
"  %i - numéro d'inode\n"
"  %N - nom de fichier en citation avec référence si avec lien symbolique\n"
"  %n - nom de fichier\n"
"  %o - taille de bloc d'entrée/sortie\n"
"  %s - taille totale, en octets\n"
"  %T - type mineur de périphérique en hexadécimal\n"
"  %t - type majeur de périphérique en hexadécimal\n"

#: src/stat.c:722
msgid ""
"  %U   User name of owner\n"
"  %u   User ID of owner\n"
"  %X   Time of last access as seconds since Epoch\n"
"  %x   Time of last access\n"
"  %Y   Time of last modification as seconds since Epoch\n"
"  %y   Time of last modification\n"
"  %Z   Time of last change as seconds since Epoch\n"
"  %z   Time of last change\n"
"\n"
msgstr ""
"  %U - nom de l'usager du propriétaire\n"
"  %u - identificateur du propriétaire\n"
"  %X - date du dernier accès en seconded depuis l'Époque\n"
"  %x - date du dernier accès\n"
"  %Y - date de la dernière modification en secondes depuis l'Époque\n"
"  %y - date de la dernière modification\n"
"  %Z - date du dernier changement en secondes depuis l'Époque\n"
"  %z - date du dernier changement\n"
"\n"

#: src/stat.c:734
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   Free blocks available to non-superuser\n"
"  %b   Total data blocks in file system\n"
"  %c   Total file nodes in file system\n"
"  %d   Free file nodes in file system\n"
"  %f   Free blocks in file system\n"
msgstr ""
"Séquences valides de format pour les systèmes de fichiers:\n"
"\n"
"  %a - blocs lilbres disponibles pour un non super-usager\n"
"  %b - total du blocs de données dans le systèmes de fichiers\n"
"  %c - total de noeuds de fichiers dans le système de fichiers\n"
"  %d - noeuds de fichiers libres dans le système de fichiers\n"
"  %f - blocs libres dans le système de fichiers\n"

#: src/stat.c:743
msgid ""
"  %i   File System id in hex\n"
"  %l   Maximum length of filenames\n"
"  %n   File name\n"
"  %s   Optimal transfer block size\n"
"  %T   Type in human readable form\n"
"  %t   Type in hex\n"
msgstr ""
"  %i - identificateur du sytème de fichiers en hexadécimal\n"
"  %l - longueur maximum des noms de fichiers\n"
"  %n - nom de fichier\n"
"  %s - taille optimale de bloc de transfert\n"
"  %T - afficher en format lisible pour un humain\n"
"  %t - afficher en hexadécimal\n"

#: src/stty.c:498
#, c-format
msgid ""
"Usage: %s [-F DEVICE] [--file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE] [--file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE] [--file=DEVICE] [-g|--save]\n"
msgstr ""
"Usage: %s [-F PÉRIPHÉRIQUE] [--file=PÉRIPHÉRIQUE] [SÉLECTION]...\n"
"  ou:  %s [-F PÉRIPHÉRIQUE] [--file=PÉRIPHÉRIQUE] [-a|--all]\n"
"  ou:  %s [-F PÉRIPHÉRIQUE] [--file=PÉRIPHÉRIQUE] [-g|--save]\n"

#: src/stty.c:504
msgid ""
"Print or change terminal characteristics.\n"
"\n"
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"Afficher ou modifier les caractéristiques du terminal.\n"
"\n"
"  -a, --all       afficher toutes les caractéristiques courantes dans\n"
"                  un format humainement lisible\n"
"  -g, --save      afficher toutes les caractéristiques dans un format\n"
"                  lisible par « stty »\n"
"  -F, --file=PÉRIPHÉRIQUE\n"
"                  utiliser le périphérique spécifié au lieu de stdin\n"

#: src/stty.c:513
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Un « - » optionnel avant SÉLECTION indique une négation.  Un * indique une\n"
"SÉLECTION non-POSIX.  Le système détermine les options applicables.\n"

#: src/stty.c:518
msgid ""
"\n"
"Special characters:\n"
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"Caractères spéciaux:\n"
"* dsusp CAR     CAR émettra un signal d'arrêt de terminal une\n"
"                    fois le tampon d'entrée vidé\n"
"  eof CAR       CAR transmettra une fin de fichier\n"
"                    (pour stopper l'ingestion à l'entrée)\n"
"  eol CAR       CAR terminera la ligne\n"

#: src/stty.c:525
msgid ""
" * eol2 CHAR     alternate CHAR for ending the line\n"
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"* eol2 CAR      CAR servira de caractère alternatif de fin de ligne\n"
"  erase CAR     CAR servira de touche d'effacement sur le dernier\n"
"                    caractère entrée\n"
"  intr CAR      CAR transmettra un signal d'interruption\n"
"  kill CAR      CAR effacera la ligne courante\n"

#: src/stty.c:531
msgid ""
" * lnext CHAR    CHAR will enter the next character quoted\n"
"   quit CHAR     CHAR will send a quit signal\n"
" * rprnt CHAR    CHAR will redraw the current line\n"
"   start CHAR    CHAR will restart the output after stopping it\n"
msgstr ""
"* lnext CAR     CAR entrera le prochain caractère entre guillemets\n"
"  quit CAR      CAR transmettra un signal de fin\n"
"* rprnt CAR     CAR servira à ré-afficher la dernière ligne\n"
"  start CAR     CAR permettra la poursuite de l'affichage de\n"
"                    sortie après avoir été stoppé\n"

#: src/stty.c:537
msgid ""
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
" * swtch CHAR    CHAR will switch to a different shell layer\n"
" * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""
"  stop CAR      CAR stoppera l'affichage de sortie\n"
"  susp CAR      CAR transmettra un signal d'arrêt de terminal\n"
"* swtch CAR     CAR permettra de passer à une couche différente de shell\n"
"* werase CAR    CAR effacera le dernier mot tapé\n"

#: src/stty.c:543
msgid ""
"\n"
"Special settings:\n"
"  N             set the input and output speeds to N bauds\n"
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"Configurations spéciales:\n"
"  N             initialiser les vitesses d'entrée et de sortie à N bauds\n"
"* cols N        indiquer au kernel que le terminal a N colonnes\n"
"* columns N     identique à cols N\n"

#: src/stty.c:550
msgid ""
"   ispeed N      set the input speed to N\n"
" * line N        use line discipline N\n"
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"  ispeed N      initialiser la vitesse d'entrée à N\n"
"* line N        utiliser le conditionnement propre de la ligne N\n"
"  min N         avec -icanon, initialiser à N le nombre de caractères\n"
"                nécessaires pour obtenir une lecture complète\n"
"  ospeed N      initialiser la vitesse de sortie à N\n"

#: src/stty.c:556
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"* rows N        indiquer au kernel que le terminal a N lignes\n"
"* size          afficher le nombre de lignes et de colonnes\n"
"                selon les paramètres du kernel\n"
"  speed         afficher la vitesse du terminal\n"
"  time N        avec -icanon, initialiser le délai\n"
"                d'inactivité de lecture à N dizièmes de seconde\n"

#: src/stty.c:562
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
" * [-]crtscts    enable RTS/CTS handshaking\n"
"   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"\n"
"Configurations de contrôle:\n"
"  [-]clocal     inhiber les signaux de contrôle du modem\n"
"  [-]cread      autoriser la réception sur l'entrée\n"
"* [-]crtscts    autoriser RTS/CTS handshaking\n"
"  csN           initialiser la taille des caractères à N bits,\n"
"                N variant entre [5..8]\n"

#: src/stty.c:570
msgid ""
"   [-]cstopb     use two stop bits per character (one with `-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (even with `-')\n"
msgstr ""
"  [-]cstopb     utiliser 2 bits d'arrêt par caractère (un avec « - »)\n"
"  [-]hup        transmettre un signal de raccrochement quand le\n"
"                dernier processus ferme le lien tty\n"
"  [-]hupcl      identique à [-]hup\n"
"  [-]parenb     génèrer le bit de parité pour la sortie et\n"
"                traiter l'entrée avec un bit de parité implicite\n"
"  [-]parodd     utiliser une parité impaire (paire avec « - »)\n"

#: src/stty.c:577
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
msgstr ""
"\n"
"Configurations d'entrée:\n"
"  [-]brkint     le « break » provoque un signal d'interruption\n"
"  [-]icrnl      traduire le retour de chariot en saut de ligne\n"
"  [-]ignbrk     ignorer le caractère break\n"
"  [-]igncr      ignorer le retour de chariot\n"

#: src/stty.c:585
msgid ""
"   [-]ignpar     ignore characters with parity errors\n"
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"  [-]ignpar     ignorer les caractères ayant des erreurs de parité\n"
"* [-]imaxbel    indiquer par un bip sonore et ne pas vider le tampon\n"
"                d'entrée lors de l'arrivée d'un caractère\n"
"  [-]inlcr      traduire le saut de ligne en retour de chariot\n"
"  [-]inpck      autoriser la vérification de la parité à l'entrée\n"
"  [-]istrip     mettre à zéro le bit du haut (8e) d'un caractère de "
"l'entrée\n"

#: src/stty.c:592
msgid ""
" * [-]iuclc      translate uppercase characters to lowercase\n"
" * [-]ixany      let any character restart output, not only start character\n"
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"* [-]iuclc      traduire les majuscles en minuscules\n"
"* [-]ixany      permettre à n'importe quel caractère de relancer "
"l'affichage\n"
"                sur la sortie, pas uniquement le caractère de redémarrage\n"
"  [-]ixoff      autoriser l'envoie d'un caractère d'arrêt/départ\n"
"  [-]ixon       autoriser le contrôle de flux XON/XOFF\n"
"  [-]parmrk     indiquer les erreur de parité par une séquence\n"
"                de caractères (255-0)\n"
"  [-]tandem     identique à [-]ixoff\n"

#: src/stty.c:600
msgid ""
"\n"
"Output settings:\n"
" * bsN           backspace delay style, N in [0..1]\n"
" * crN           carriage return delay style, N in [0..3]\n"
" * ffN           form feed delay style, N in [0..1]\n"
" * nlN           newline delay style, N in [0..1]\n"
msgstr ""
"\n"
"Configurations de sortie:\n"
"* bsN           style du délai de retour arrière, N parmi [0..1]\n"
"* crN           style du délai du retour de chariot, N parmi [0..3]\n"
"* ffN           style du délai du saut de page, N parmi [0..1]\n"
"* nlN           style du délai du saut de ligne, N parmi [0..1]\n"

#: src/stty.c:608
msgid ""
" * [-]ocrnl      translate carriage return to newline\n"
" * [-]ofdel      use delete characters for fill instead of null characters\n"
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
" * [-]olcuc      translate lowercase characters to uppercase\n"
" * [-]onlcr      translate newline to carriage return-newline\n"
" * [-]onlret     newline performs a carriage return\n"
msgstr ""
"* [-]ocrnl      traduire un retour de chariot par un saut de ligne\n"
"* [-]ofdel      utiliser des caractères d'effacement comme caractère\n"
"                de remplissage au lieu de caractères nuls\n"
"* [-]ofill      utiliser le remplissage de caractères au lieu du délai\n"
"                par minuterie\n"
"* [-]olcuc      traduire les minuscules en majuscules\n"
"* [-]onlcr      traduire le saut de ligne en retour de chariot-saut de "
"ligne\n"
"* [-]onlret     le saut de ligne provoque un retour de chariot\n"

#: src/stty.c:616
msgid ""
" * [-]onocr      do not print carriage returns in the first column\n"
"   [-]opost      postprocess output\n"
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
" * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
"* [-]onocr      ne pas afficher un retour de chariot en première colonne\n"
"  [-]opost      exécuter un post-traitement de sortie\n"
"* tabN          style du délai de tabulation horizontale, N parmi [0..3]\n"
"* tabs          identique à tab0\n"
"* -tabs         identique à tab3\n"
"* vtN           style du délai de tabulation verticale, N parmi [0..1]\n"

#: src/stty.c:624
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"Configurations locales:\n"
"  [-]crterase   faire l'écho du caractère « erase » selon la séquence\n"
"                retour arrière-espace-retour arrière\n"
"* crtkill       annuler les ligne respectant la configuration\n"
"                « echoprt » et « echoe »\n"
"* -crtkill      annuler les lignes respectant la configuration\n"
"                « echoctl » et « echok »\n"

#: src/stty.c:631
msgid ""
" * [-]ctlecho    echo control characters in hat notation (`^c')\n"
"   [-]echo       echo input characters\n"
" * [-]echoctl    same as [-]ctlecho\n"
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"* [-]ctlecho    faire l'écho des caractères de contrôle par une notation\n"
"                en chapeau (« ^c »)\n"
"  [-]echo       faire l'écho des caractères à l'entrée\n"
"* [-]echoctl    identique à [-]ctlecho\n"
"  [-]echoe      identique à [-]crterase\n"
"  [-]echok      faire l'écho d'un saut de ligne après un caractère "
"d'annulation\n"

#: src/stty.c:638
msgid ""
" * [-]echoke     same as [-]crtkill\n"
"   [-]echonl     echo newline even if not echoing other characters\n"
" * [-]echoprt    echo erased characters backward, between `\\' and '/'\n"
"   [-]icanon     enable erase, kill, werase, and rprnt special characters\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"* [-]echoke     identique à [-]crtkill\n"
"  [-]echonl     faire l'écho d'un saut de ligne même s'il n'y pas\n"
"                d'écho des autres caractères\n"
"* [-]echoprt    faire l'écho des caractères d'effacement par retour "
"arrière,\n"
"                entre « \\ » et « / »\n"
"  [-]icanon     autoriser les caractères spéciaux\n"
"                « erase », « kill », « werase », et « rprnt »\n"
"  [-]iexten     autoriser les caractères spéciaux non-POSIX\n"

#: src/stty.c:645
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
" * [-]prterase   same as [-]echoprt\n"
" * [-]tostop     stop background jobs that try to write to the terminal\n"
" * [-]xcase      with icanon, escape with `\\' for uppercase characters\n"
msgstr ""
"  [-]isig       autoriser les caractères spéciaux\n"
"                « interrupt », « quit », et « suspend »\n"
"  [-]noflsh     inhiber la vidange après réception des caractères\n"
"                « interrupt » et « quit »\n"
"* [-]prterase   identique à [-]echoprt\n"
"* [-]tostop     stopper les tâches d'arrière plan qui essaient d'écrire\n"
"                sur le terminal\n"
"* [-]xcase      avec « icanon », faire l'échappement avec « \\ »\n"
"                pour les majuscules\n"

#: src/stty.c:652
msgid ""
"\n"
"Combination settings:\n"
" * [-]LCASE      same as [-]lcase\n"
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"\n"
"Configuration par combinaison:\n"
"* [-]LCASE      identique à [-]lcase\n"
"  cbreak        identique à -icanon\n"
"  -cbreak       identique à icanon\n"

#: src/stty.c:659
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
"   crt           same as echoe echoctl echoke\n"
msgstr ""
"  cooked        identique à brkint ignpar istrip icrnl ixon opost isig\n"
"                icanon, eof et eol selon leur valeur par défaut\n"
"  -cooked       identique à raw\n"
"  crt           identique à echoe echoctl echoke\n"

#: src/stty.c:665
msgid ""
"   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                 kill ^u\n"
" * [-]decctlq    same as [-]ixany\n"
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
msgstr ""
"  dec           identique à echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                kill ^u\n"
"* [-]decctlq    identique à [-]ixany\n"
"  ek            réinitialiser les caractères erase et kill à leur valeur\n"
"                par défaut\n"
"  evenp         identique à parenb -parodd cs7\n"

#: src/stty.c:672
msgid ""
"   -evenp        same as -parenb cs8\n"
" * [-]lcase      same as xcase iuclc olcuc\n"
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
"   nl            same as -icrnl -onlcr\n"
"   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
msgstr ""
"  -evenp        identique à -parenb cs8\n"
"* [-]lcase      identique à xcase iuclc olcuc\n"
"  litout        identique à -parenb -istrip -opost cs8\n"
"  -litout       identique à parenb istrip opost cs7\n"
"  nl            identique à -icrnl -onlcr\n"
"  -nl           identique à icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#: src/stty.c:680
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"  oddp          identique à parenb parodd cs7\n"
"  -oddp         identique à -parenb cs8\n"
"  [-]parity     identique à [-]evenp\n"
"  pass8         identique à -parenb -istrip cs8\n"
"  -pass8        identique à parenb istrip cs7\n"

#: src/stty.c:687
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"  raw           identique à -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                -imaxbel -opost -isig -icanon -xcase min 1 fois 0\n"
"  -raw          identique à cooked\n"

#: src/stty.c:693
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                 isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                 -xcase -tostop -echoprt echoctl echoke, all special\n"
"                 characters to their default values.\n"
msgstr ""
"  sane          identique à cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                -xcase -tostop -echoprt echoctl echoke, et tous les "
"caractères\n"
"                spéciaux à leur valeur par défaut.\n"

#: src/stty.c:701
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Prendre en charge la ligne « tty » reliée à l'entrée standard.  Sans "
"argument,\n"
"afficher la vitesse, le conditionnement de ligne et les modifications "
"appliquées\n"
"par 'stty sane'.  Dans les configurations,\n"
"CARactère est pris littéralement, ou codé comme ^c, 0x37, 0177 ou 127;\n"
"les valeurs spéciales comme ^- ou indéfinies sont utilisées pour inhiber\n"
"les caractères spéciaux.\n"

#: src/stty.c:787
msgid "only one device may be specified"
msgstr "un seul périphérique peut être spécifié"

#: src/stty.c:882
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"les options pour le mode bavard et les styles de sortie de stty-readable\n"
"sont mutuellement exclusives"

#: src/stty.c:887
msgid "when specifying an output style, modes may not be set"
msgstr ""
"Lors de la spécification d'un style de sortie, \n"
"les mode peuvent ne pas être initialisés."

#: src/stty.c:903
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: n'a pu réinitialiser en mode non par bloc"

#: src/stty.c:957 src/stty.c:1064
#, c-format
msgid "invalid argument `%s'"
msgstr "argument invalide « %s »"

#: src/stty.c:968 src/stty.c:985 src/stty.c:997 src/stty.c:1010
#: src/stty.c:1022 src/stty.c:1041
#, c-format
msgid "missing argument to `%s'"
msgstr "argument manquant pour « %s »"

#: src/stty.c:1117
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: incapable d'exécuter toutes les opérations demandées."

#: src/stty.c:1122
msgid "new_mode: mode\n"
msgstr "new_mode: mode\n"

#: src/stty.c:1462
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: aucune information sur la taille pour ce périphérique."

#: src/stty.c:1944
#, c-format
msgid "invalid integer argument `%s'"
msgstr "argument numérique invalide « %s »"

#: src/su.c:289
msgid "Password:"
msgstr "Mot de passe:"

#: src/su.c:292
msgid "getpass: cannot open /dev/tty"
msgstr "getpass(): ne peut ouvrir /dev/tty"

#: src/su.c:350
msgid "cannot set groups"
msgstr "ne peut initialiser les groupes"

#: src/su.c:354
msgid "cannot set group id"
msgstr "ne peut initialiser l'identificateur de groupe"

#: src/su.c:356
msgid "cannot set user id"
msgstr "ne peut initialiser l'identificateur de l'usager"

#: src/su.c:437
#, c-format
msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
msgstr "Usage: %s [OPTION]... [-] [USAGER [ARG]...]\n"

#: src/su.c:438
msgid ""
"Change the effective user id and group id to that of USER.\n"
"\n"
"  -, -l, --login               make the shell a login shell\n"
"  -c, --commmand=COMMAND       pass a single COMMAND to the shell with -c\n"
"  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
"  -m, --preserve-environment   do not reset environment variables\n"
"  -p                           same as -m\n"
"  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
msgstr ""
"Modifier les identificateurs effectifs de l'usager et de groupe comme\n"
"étant ceux de l'USAGER.\n"
"\n"
"  -, -l, --login               utiliser ce shell comme étant celui de\n"
"                               la session de travail\n"
"  -c, --commmand=COMMANDE      passer la COMMANDE au shell avec -c\n"
"  -f, --fast                   passer -f au shell (valable pour csh ou "
"tcsh)\n"
"  -m, --preserve-environment   ne pas réinitialiser les variables\n"
"                               d'environnement\n"
"  -p                           identique à -m\n"
"  -s, --shell=SHELL            lancer le SHELL si /etc/shells le permet\n"

#: src/su.c:450
msgid ""
"\n"
"A mere - implies -l.   If USER not given, assume root.\n"
msgstr ""
"\n"
"Un tiret - implique -l.   Si l'argument USAGER n'est pas fourni,\n"
"l'usager « root » est utilisé.\n"

#: src/su.c:529
#, c-format
msgid "user %s does not exist"
msgstr "L'usager %s n'existe pas."

#: src/su.c:552
msgid "incorrect password"
msgstr "Mot de passe incorrect."

#: src/su.c:569
#, c-format
msgid "using restricted shell %s"
msgstr "Utilisation du shell %s restreint."

#: src/su.c:580
#, c-format
msgid "warning: cannot change directory to %s"
msgstr "AVERTISSEMENT: ne peut changer de répertoire vers %s"

#: src/sum.c:36
msgid "Kayvan Aghaiepour and David MacKenzie"
msgstr "Kayvan Aghaiepour et David MacKenzie"

#: src/sum.c:64
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Imprimer la somme de contrôle et le nombre de blocs pour chaque FICHIER.\n"
"\n"
"  -r              annuler -s et utiliser l'algorithme de sommation BSD\n"
"                  avec des blocs de 1K octets\n"
"  -s, --sysv      utiliser l'algorithme de sommation du Système V\n"
"                  avec des blocs de 512 octets\n"

#: src/sync.c:45
msgid ""
"Force changed blocks to disk, update the super block.\n"
"\n"
msgstr ""
"Forcer l'écriture des blocs modifiés sur disque et\n"
"la mise à jour du super bloc.\n"

#: src/sync.c:70 src/tty.c:112
msgid "ignoring all arguments"
msgstr "tous les arguments sont ignorés"

#: src/sys2.h:492
msgid "      --help     display this help and exit\n"
msgstr "      --help      afficher l'aide-mémoire\n"

#: src/sys2.h:494
msgid "      --version  output version information and exit\n"
msgstr "      --version   afficher le nom et la version du logiciel\n"

#: src/tac.c:54
msgid "Jay Lepreau and David MacKenzie"
msgstr "Jay Lepreau et David MacKenzie"

#: src/tac.c:131
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Écrire chaque FICHIER sur la sortie standard, la dernière ligne en premier.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tac.c:139
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before           placer le séparateur avant plutôt qu'après\n"
"  -r, --regex            interpréter le séparateur comme une expression\n"
"                          régulière\n"
"  -s, --separator=CHAÎNE utiliser la CHAÎNE comme séparateur au lieu\n"
"                          du saut de ligne\n"

#: src/tac.c:453 src/tac.c:592
msgid "stdin: read error"
msgstr "stdin: erreur de lecture."

#: src/tac.c:638
msgid "separator cannot be empty"
msgstr "Le séparateur ne peut être vide."

#: src/tail.c:49
msgid "Paul Rubin, David MacKenzie, Ian Lance Taylor, and Jim Meyering"
msgstr "Paul Rubin, David MacKenzie, Ian Lance Taylor et Jim Meyering"

#: src/tail.c:238
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les %d dernières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un fichier FICHIER, précéder chacun d'une en-tête donnant le "
"nom.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

# src/tail.c:250
#: src/tail.c:247
msgid ""
"      --retry              keep trying to open a file even if it is\n"
"                           inaccessible when tail starts or if it becomes\n"
"                           inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
msgstr ""
"      --retry              continuer de tenter d'ouvrir le fichier même "
"s'il\n"
"                           est inaccessible lorsque tail démarre ou s'il "
"devient\n"
"                           inaccessible plus tard -- utile seulement avec -"
"f\n"
"  -c, --bytes=N            afficher les N derniers octets\n"

#: src/tail.c:253
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={nom|descripteur}]\n"
"                           afficher les dernières données ajoutées tant\n"
"                            que le fichier s'accroît; -f, --follow, et\n"
"                           --follow=descripteur sont équivalents\n"
"  -F                        identique à --follow=nom --retry\n"

#: src/tail.c:260
#, c-format
msgid ""
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""
"  -n, --lines=N            afficher les N dernièreslignes, au lieu des %d\n"
"      --max-unchanged-stats=N\n"
"                           avec l'option --follow=nom, le FICHIER qui n'a "
"pas\n"
"                           changé de taille après N itérations (par défaut %"
"d)\n"
"                           afin de vérifier s'il a été détruit ou s'il a "
"changé\n"
"                           de nom (c'est le cas habituellement des fichiers\n"
"                           de journalisation dont on fait la rotation)\n"

#: src/tail.c:271
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, sleep for approximately S seconds\n"
"                           (default 1.0) between iterations.\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"      --pid=PID            avec -f, terminer après le processus ID, PID est "
"arrêté\n"
"  -q, --quiet, --silent    ne jamais afficher l'en-tête avec\n"
"                            les noms de fichiers\n"
"  -s, --sleep-interval=S   avec -f, attendre S secondes (1.0 par défaut)\n"
"                            entre les itérations\n"
"  -v, --verbose            toujours afficher les en-têtes des noms de "
"fichier\n"

#: src/tail.c:280
msgid ""
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).\n"
"\n"
msgstr ""
"\n"
"Si le premier caractère de N (le nombre d'octets ou de lignes) est un « + "
"»,\n"
"afficher à partir du Nième item depuis le début de chaque fichier,\n"
"autrement, afficher les derniers N items du fichier.\n"
"N peut avoir un suffixe multiplicateur:\n"
"b pour 512, k pour 1024, m pour 1048576 (1 Meg).\n"

# src/tail.c:290
#: src/tail.c:288
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""
"Avec l'option --follow (-f), tail utilise par défaut le descripteur de "
"fichier\n"
"qui permet de suivre l'évolution du fichier ciblé même s'il change de nom.\n"
"Tail continuera de suivre l'évolution du fichier jusqu'à la fin. "

#: src/tail.c:293
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""
"Ce comportement par défaut n'est pas désirable lorsqu'on désire suivre "
"l'évolution\n"
"d'un fichier à l'aide de son nom et non pas par le descripteur de fichier (i."
"e. cas\n"
"lors de la rotation des journaux). Utiliser --follow=nom dans ce cas.\n"
"À ce moment, tail suivra l'évolution du fichier en l'ouvrant périodiquement\n"
"afin de vérifier s'il a été détruit ou recréé par un autre programme.\n"

#: src/tail.c:331
#, c-format
msgid "closing %s (fd=%d)"
msgstr "fermeture %s (fd=%d)"

#: src/tail.c:391
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: ne peut repérer selon le déplacement %s"

#: src/tail.c:395
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: ne peut repérer selon le déplacement relatif %s"

#: src/tail.c:400
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: ne peut repérer la fin selon le déplacement relatif %s"

#: src/tail.c:818
#, c-format
msgid "`%s' has become inaccessible"
msgstr "« %s » est devenu inaccessible"

#: src/tail.c:835
#, c-format
msgid "`%s' has been replaced with an untailable file; giving up on this name"
msgstr ""
"« %s » a été remplacé par un fichier dont on ne peut déterminer la taille; "
"abandon sur ce nom."

#: src/tail.c:856
#, c-format
msgid "`%s' has become accessible"
msgstr "%s» est devenu accessible"

#: src/tail.c:864
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "« %s » a été remplacé; à la suite de la fin d'un nouveau fichier"

#: src/tail.c:875
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "« %s » a été remplacé; à la suite de la fin d'un nouveau fichier"

#: src/tail.c:1000
#, c-format
msgid "%s: file truncated"
msgstr "%s: fichier tronqué"

#: src/tail.c:1020
msgid "no files remaining"
msgstr "aucun fichier restant"

#: src/tail.c:1236
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr ""
"%s: ne peut déterminer la fin de ce type de fichier; abandon sur ce nom"

#: src/tail.c:1356
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: caractère invalide en suffixe dans une option désuète."

#: src/tail.c:1405
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"Trop de arguments; lors de l'utilisation d'une syntaxe désuète (%s) de tail\n"
"Il ne peut y avoir plus d'un fichier en argument. Utiliser l'option -n ou -"
"b\n"
"équivalente à la place."

#: src/tail.c:1414
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"AVERTISSEMENT: l'utilisation de 2 ou plusieurs fichiers en argument\n"
"avec une syntaxe désuète des options (%s) de tail n'est pas portable.\n"
"Utiliser les options équivalentes -n ou -c à la place."

#: src/tail.c:1423
#, c-format
msgid "`%s' option is obsolete; use `%s-%c %.*s'"
msgstr "option « %s » est obsolète; utiliser « %s-%c %.*s »"

#: src/tail.c:1484
#, c-format
msgid "%s is larger than the maximum file size on this system"
msgstr "%s est plus grand que la taille maximale possible sur ce système"

#: src/tail.c:1510
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr ""
"%s: nombre maximum invalide de changements d'états entre les ouvertures"

#: src/tail.c:1522
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s: nombre maximum invalide de changements consécutifs de taille"

#: src/tail.c:1534
#, c-format
msgid "%s: invalid PID"
msgstr "%s: PID invalide."

#: src/tail.c:1549
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: nombre de secondes invalide."

#: src/tail.c:1568
msgid "warning: --retry is useful only when following by name"
msgstr "AVERTISSEMENT: --retry est utile seulement si suivi par un nom"

#: src/tail.c:1572
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"AVERTISSEMENT: PID ignoré; --pid=PID est utile seulement lorsqu'il suit"

#: src/tail.c:1575
msgid "warning: --pid=PID is not supported on this system"
msgstr "AVERTISSEMENT: --pid=PID n'est pas supporté sur ce système"

#: src/tee.c:33
msgid "Mike Parker, Richard M. Stallman, and David MacKenzie"
msgstr "Mike Parker, Richard Stallman et David MacKenzie"

#: src/tee.c:64
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Copier de l'entrée standard vers chaque FICHIER, \n"
"et également vers la sortie standard.\n"
"\n"
"  -a, --append              accoler la sortie au(x) FICHIER(s),\n"
"                            sans les écraser\n"
"  -i, --ignore-interrupts   ignorer les signaux d'interruption\n"

#: src/test.c:216
msgid "argument expected\n"
msgstr "argument attendu\n"

#: src/test.c:224
#, c-format
msgid "integer expression expected %s\n"
msgstr "expression en valeur entière attendue %s\n"

#: src/test.c:342
msgid "')' expected\n"
msgstr "« ) » attendu\n"

#: src/test.c:345
#, c-format
msgid "')' expected, found %s\n"
msgstr "attendait « ) », mais a trouvé %s\n"

#: src/test.c:361 src/test.c:894
#, c-format
msgid "%s: unary operator expected\n"
msgstr "%s: opérateur unaire attendu.\n"

#: src/test.c:389 src/test.c:920
#, c-format
msgid "%s: binary operator expected\n"
msgstr "%s: opérateur binaire attendu.\n"

#: src/test.c:424
msgid "before -lt"
msgstr "avant -lt"

#: src/test.c:432
msgid "after -lt"
msgstr "après -lt"

#: src/test.c:446
msgid "before -le"
msgstr "avant -le"

#: src/test.c:453
msgid "after -le"
msgstr "après -le"

#: src/test.c:469
msgid "before -gt"
msgstr "avant -gt"

#: src/test.c:476
msgid "after -gt"
msgstr "après -gt"

#: src/test.c:490
msgid "before -ge"
msgstr "avant -ge"

#: src/test.c:497
msgid "after -ge"
msgstr "après -ge"

#: src/test.c:512
msgid "-nt does not accept -l\n"
msgstr "-nt ne permet pas -l\n"

#: src/test.c:526
msgid "before -ne"
msgstr "avant -ne"

#: src/test.c:533
msgid "after -ne"
msgstr "après -ne"

#: src/test.c:549
msgid "before -eq"
msgstr "avant -eq"

#: src/test.c:556
msgid "after -eq"
msgstr "après -eq"

#: src/test.c:567
msgid "-ef does not accept -l\n"
msgstr "-ef ne permet pas -l\n"

#: src/test.c:586
msgid "-ot does not accept -l\n"
msgstr "-ot ne permet pas -l\n"

#: src/test.c:593
msgid "unknown binary operator"
msgstr "opérateur binaire inconnu"

#: src/test.c:781
msgid "after -t"
msgstr "après -t"

#: src/test.c:979
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  [ EXPRESSION ]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s EXPRESSION\n"
"  or:  [EXPRESSION]\n"
"  or:  %s OPTION\n"

#: src/test.c:985
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"Terminer l'exécution avec l'état déterminé par l'EXPRESSION.\n"
"\n"

#: src/test.c:991
msgid ""
"\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"L'EXPRESSION est vraie ou fausse et initialise l'état de fin d'exécution. "
"Selon un des options:\n"

#: src/test.c:995
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( EXPRESSION )               EXPRESSION est vraie\n"
"  ! EXPRESSION                 EXPRESSION est fausse\n"
"  EXPRESSION1 -a EXPRESSION2   si les deux EXPRESSION1 et EXPRESSION2\n"
"                               sont vraies\n"
"  EXPRESSION1 -o EXPRESSION2   si l'une ou l'autre des expressions:\n"
"                               EXPRESSION1 ou EXPRESSION2 est vraie\n"

#: src/test.c:1002
msgid ""
"\n"
"  [-n] STRING          the length of STRING is nonzero\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  [-n] CHAÎNE             si la longueur de la CHAÎNE n'est pas nulle\n"
"  -z CHAÎNE               si la longueur de la CHAÎNE est nulle\n"
"  CHAÎNE1 = CHAÎNE2       si les chaînes sont identiques\n"
"  CHAÎNE1 != CHAÎNE2      si les chaînes sont différentes\n"

#: src/test.c:1009
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ENTIER1 -eq ENTIER2     si ENTIER1 est égal à ENTIER2\n"
"  ENTIER1 -ge ENTIER2     si ENTIER1 est plus grand ou égal à ENTIER2\n"
"  ENTIER1 -gt ENTIER2     si ENTIER1 est plus grand que ENTIER2\n"
"  ENTIER1 -le ENTIER2     si ENTIER1 est plus petit ou égal à ENTIER2\n"
"  ENTIER1 -lt ENTIER2     si ENTIER1 est plus petit que ENTIER2\n"
"  ENTIER1 -ne ENTIER2     si ENTIER1 n'est pas égal à ENTIER2\n"

#: src/test.c:1018
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  FICHIER1 -ef FICHIER2   FICHIER1 et FICHIER2 ont les mêmes numéros\n"
"                          de périphérique et d'inode\n"
"  FICHIER1 -nt FICHIER2   FICHIER1 est plus récent (date de modification)\n"
"                          que FICHIER2\n"
"  FICHIER1 -ot FICHIER2   FICHIER1 est plus vieux que FICHIER2\n"

#: src/test.c:1024
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b FICHIER     FICHIER existe et est de type à blocage spécial\n"
"  -c FICHIER     FICHIER existe et est de type caractère spécial\n"
"  -d FICHIER     FICHIER existe et est un répertoire\n"
"  -e FICHIER     FICHIER existe\n"

#: src/test.c:1031
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f FICHIER     FICHIER existe et est de type régulier\n"
"  -g FICHIER     FICHIER existe et le bit « set-group-ID », est initialisé\n"
"  -G FICHIER     FICHIER existe et appartient au groupe effectif ID\n"
"  -k FICHIER     FICHIER existe et le bit « sticky » est initialisé\n"

#: src/test.c:1038
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and is readable\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L FICHIER     FICHIER existe et est un lien symbolique\n"
"  -O FICHIER     FICHIER existe et appartient à l'usager effectif ID\n"
"  -p FICHIER     FICHIER existe et est un relais nommé (named pipe)\n"
"  -r FICHIER     FICHIER existe et est lisible\n"
"  -s FICHIER     FICHIER existe et a une taille non nulle\n"

#: src/test.c:1045
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t [FD]     file descriptor FD (stdout by default) is opened on a "
"terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and is writable\n"
"  -x FILE     FILE exists and is executable\n"
msgstr ""
"  -S FICHIER     FICHIER existe et est de type « socket »\n"
"  -t [DF]        descripteur de fichier DF (sortie standard par défaut)\n"
"                 est ouvert sur le terminal\n"
"  -u FICHIER     FICHIER existe et le bit « set-user-ID », est initialisé\n"
"  -w FICHIER     FICHIER existe et l'écriture y est permise\n"
"  -x FICHIER     FICHIER existe et exécutable\n"

#: src/test.c:1052
msgid ""
"\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Portez attention au fait que les parenthèses doivent être précédées par des\n"
"barres obliques inverses (pour éviter l'échappement vers un shell).\n"
"Un ENTIER peut être évalué par la notation -l CHAÎNE, laquelle\n"
"évalue alors la longueur de la chaîne.\n"

#: src/test.c:1067
msgid "FIXME: ksb and mjb"
msgstr "CORRIGEZ-MOI: ksb et mjb"

#: src/test.c:1111
msgid "missing `]'\n"
msgstr "« ] » manquant\n"

#: src/test.c:1125
msgid "too many arguments\n"
msgstr "trop d'arguments\n"

#: src/touch.c:39
msgid ""
"Paul Rubin, Arnold Robbins, Jim Kingdon, David MacKenzie, and Randy Smith"
msgstr ""
"Paul Rubin, Arnold Robbins, Jim Kingdon, David MacKenzie et Randy Smith"

#: src/touch.c:164 src/touch.c:179
#, c-format
msgid "creating %s"
msgstr "création de %s"

#: src/touch.c:222
#, c-format
msgid "cannot touch %s"
msgstr "ne peut faire un touch sur %s"

#: src/touch.c:228
#, c-format
msgid "setting times of %s"
msgstr "initialisation des dates de %s"

#: src/touch.c:245
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
msgstr ""
"Mettre à jour les dates d'accès et de modification de chaque FICHIER\n"
"selon la date courante.\n"

#: src/touch.c:252
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -a                   modifier seulement la date d'accès\n"
"  -c, --no-create      ne créer aucun fichier\n"
"  -d, --date=CHAÎNE    analyser la CHAÎNE et l'utiliser au lieu\n"
"                       de la date courante\n"
"  -f                   (ignorée)\n"
"  -m                   modifier seulement la date de modification\n"

#: src/touch.c:259
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"  --time=WORD            set time given by WORD: access atime use (same as -"
"a)\n"
"                           modify mtime (same as -m)\n"
msgstr ""
"  -r, --file=FICHIER   utiliser la date du FICHIER comme référence\n"
"                       au lieu de la date courante\n"
"  -t DATE              utiliser la DATE selon le format:\n"
"                        [[CC]AA]MMJJhhmm[.ss]\n"
"                       comme tampon date-heure au lieu de la date courante\n"
"      --time=CODE      -a pour « atime », -m pour « mtime », -m pour "
"modifié,\n"
"                       -a pour utilisé\n"

#: src/touch.c:267
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Noter que les options -d et -t acceptent différents formats de date et "
"d'heure.\n"

#: src/touch.c:311 src/touch.c:331
#, c-format
msgid "invalid date format %s"
msgstr "format de date invalide %s"

#: src/touch.c:355
msgid "cannot specify times from more than one source"
msgstr "ne peut spécifier les dates pour plus d'une source"

#: src/touch.c:378
#, c-format
msgid ""
"warning: `touch %s' is obsolete; use `touch -t %04d%02d%02d%02d%02d.%02d'"
msgstr ""
"AVERTISSEMENT: `touch %s' est obsolète; utiliser `touch -t %04d%02d%02d%02d%"
"02d.%02d'"

#: src/touch.c:399
msgid "file arguments missing"
msgstr "arguments fichier manquants"

#: src/tr.c:327
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Usage: %s [OPTION]... ENSEMBLE1 [ENSEMBLE2]\n"

#: src/tr.c:331
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Traduire, compresser, et/ou éliminer des caractères de l'entrée standard,\n"
"par écriture sur la sortie standard.\n"
"\n"
"  -c, --complement        complémenter à un l'ENSEMBLE1 \n"
"  -d, --delete            éliminer les caractères de l'ENSEMBLE1\n"
"                          et ne pas traduire\n"
"  -s, --squeeze-repeats   remplacer chaque séquence d'entrée de caractères "
"répétés\n"
"                          qui apparaît dans l'ENSEMBLE1 par une seule "
"occurence\n"
"                          de ce caractère\n"
"  -t, --truncate-set1     tronquer d'abord l'ENSEMBLE1 à la longueur\n"
"                          de l'ENSEMBLE2\n"

#: src/tr.c:344
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"Les ENSEMBLES sont spécifiés comme des chaînes de caractères.\n"
"La plupart se représente eux-mêmes.\n"
"Les séquences d'interprétation sont:\n"
"\n"
"  \\NNN            caractère ayant la valeur octale NNN (1 à 3 chiffres "
"octaux)\n"
"  \\\\             barre oblique inverse\n"
"  \\a              cloche sonore \n"
"  \\b              caractère d'effacement\n"
"  \\f              saut de page \n"
"  \\n              saut de ligne \n"
"  \\r              retour\n"
"  \\t              saut horizontal\n"

#: src/tr.c:358
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              saut vertical \n"
"  CAR1-CAR2       tous les caractères de CAR1 à CAR2 en ordre croissant\n"
"  [CAR*]          dans ENS2, copie de CAR jusqu'à longueur de ENS1\n"
"  [CAR*RÉP]       RÉPéter copies de CAR, RÉPéter en octal si débute par 0\n"
"  [:alnum:]       toutes les lettres et les chiffres\n"
"  [:alpha:]       toutes les lettres\n"
"  [:blank:]       tous les blancs horizontaux\n"
"  [:cntrl:]       tous les caractères de contrôle\n"
"  [:digit:]       tous les chiffres\n"

#: src/tr.c:369
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       tous les caractères imprimables, sans inclure les blancs\n"
"  [:lower:]       tous les lettres minuscules\n"
"  [:print:]       tous les caractères imprimables, incluant les blancs\n"
"  [:punct:]       tous les caractères de ponctuation\n"
"  [:space:]       tous les sauts verticaux ou horizontaux\n"
"  [:upper:]       toutes les lettres majuscules\n"
"  [:xdigit:]      tous les chiffres hexadécimaux\n"
"  [=CAR=]         tous les caractères équivalents à CAR\n"

#: src/tr.c:379
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  "
msgstr ""
"\n"
"La traduction survient si -d n'est pas fourni et si les deux ensembles\n"
"ENSEMBLE1 et ENSEMBLE2 sont fournis en argument.\n"
"L'option -t peut être utilisée seulement lors de la traduction.  "
"L'ENSEMBLE2\n"
"est dilaté selon la taille de l'ENSEMBLE1 par répétition des derniers\n"
"caractères si nécessaire."

#: src/tr.c:385
msgid ""
"Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  "
msgstr ""
"Les caractères en excès de l'ENSEMBLE2 sont ignorés.\n"
"Seuls [:lower:] et [:upper:] sont garants d'une expansion en ordre\n"
"en ordre croissant; utilisé dans l'ENSEMBLE2 lors de la traduction, ils "
"peuvent\n"
"seulement être utilisés par paire pour spécifier une conversion de la casse."

#: src/tr.c:391
msgid ""
"-s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"L'option -s s'emploie avec l'ENSEMBLE1 sinon il n'y a pas de traduction ou\n"
"d'élimination autrement la compression utilise l'ENSEMBLE2 et se produit "
"après\n"
"la traduction ou l'élimination.\n"

#: src/tr.c:557
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"AVERTISSEMENT: l'échappement ambigu octal \\%c%c%c est\n"
"               interprété comme une séquence de 2-octets \\0%c%c, « %c »"

#: src/tr.c:566
msgid "invalid backslash escape at end of string"
msgstr "Échappement barre oblique inverse invalide à la fin d'une chaîne."

#: src/tr.c:572
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "Échappement barre oblique inverse invalide « \\%c »"

#: src/tr.c:725
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr ""
"bornes d'intervalle de « %s-%s » sont en ordre inverse de séquence\n"
"de comparaison."

#: src/tr.c:906
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "compte de répétions « %s » invalide dans le construit [c*n]"

#: src/tr.c:999
msgid "missing character class name `[::]'"
msgstr "caractères de nom de classe « [::] » manquants"

#: src/tr.c:1002
msgid "missing equivalence class character `[==]'"
msgstr "caractères d'équivalence de classe « [==] » manquants"

#: src/tr.c:1025
#, c-format
msgid "invalid character class `%s'"
msgstr "caractère de classe « %s » invalide"

#: src/tr.c:1050
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: opérande d'équivalence de classe doit être un caractère simple"

#: src/tr.c:1522
msgid "the [c*] repeat construct may not appear in string1"
msgstr "le construit [c*] de répétition ne peut apparaître dans la chaîne1"

#: src/tr.c:1532
msgid "only one [c*] repeat construct may appear in string2"
msgstr "un seul construit de répétition [c*] peut apparaître dans chaîne2"

#: src/tr.c:1540
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr ""
"les expressions [=c=] ne peuvent apparaître dans chaîne2 lors de traductions"

#: src/tr.c:1553
msgid "when not truncating set1, string2 must be non-empty"
msgstr "lorsque que l'ensemble1 n'est pas tronqué, chaîne2 ne peut être vide"

#: src/tr.c:1562
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"lors de traduction avec des caractères complémentées de classes,\n"
"la chaîne2 doit ramener tous les caractères du domaine à un seul"

#: src/tr.c:1569
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"lors de traductions la seule classe de caractères pouvant apparaître\n"
"dans chaîne2 est « upper » ou « lower »"

#: src/tr.c:1578
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"le construit [c*] peut apparaître dans chaîne2 seulement lors d'une\n"
"traduction"

#: src/tr.c:1853
msgid "two strings must be given when translating"
msgstr "deux chaînes doivent être fournies lors de la traduction"

#: src/tr.c:1856
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr ""
"deux chaînes doivent être fournies lorsqu'il y a destruction\n"
"et réduction des répétitions"

#: src/tr.c:1870
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""
"seule une chaîne peut être fournie lors d'une destruction sans\n"
"réduction des répétitions"

#: src/tr.c:1876
msgid "at least one string must be given when squeezing repeats"
msgstr ""
"au moins une chaîne doit être fournie lors de réduction des répétitions"

#: src/tr.c:1967
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "construit [:upper:] et/ou [:lower:] mal aligné"

#: src/tr.c:1990
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"correspondance d'identité invalide:  lors de la traduction de contruits\n"
"[:lower:] ou [:upper:], le construit dans la chaîne1 doit être aligné\n"
"avec le construit correspondant ([:upper:] ou [:lower:] respectivement)\n"
"dans la chaîne2"

#: src/true.c:34
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
"Exit with a status code indicating success.\n"
"\n"
"These option names may not be abbreviated.\n"
"\n"
msgstr ""
"Usage: %s [arguments ignorés de la ligne de commande]\n"
"   ou: %s OPTION\n"
"Terminer avec un statut indiquant l'échec.\n"
"\n"
"Ces options ne peuvent pas être abrégées.\n"
"\n"

#: src/tsort.c:97
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Usage: %s [OPTION] [FICHIER]\n"
"Afficher une liste totalement ordonnée consistante avec l'ordenancement\n"
"partiel donné dans le FICHIER.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tsort.c:533
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: l'entrée contient une boucle:"

#: src/tsort.c:575
msgid "only one argument may be specified"
msgstr "Un seul argument peut être spécifié."

#: src/tty.c:63
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Afficher le nom de fichier du terminal relié à l'entrée standard.\n"
"\n"
"  -s, --silent, --quiet   ne rien afficher, retourner seulement un\n"
"                          statut de fin d'exécution\n"

#: src/tty.c:120
msgid "not a tty"
msgstr "n'est pas un « tty »"

#: src/uname.c:111
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Afficher certaines informations identifiant le système.\n"
"Sans OPTION, identique à -s.\n"
"\n"
"  -a, --all                afficher toutes les informations\n"
"  -s, --kernel-name        afficher le nom du kernel\n"
"  -n, --nodename           afficher le nom du noeud réseau du poste "
"(hostname)\n"
"  -r, --release            afficher la révision de la version du\n"
"                           système d'exploitation\n"

#: src/uname.c:119
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type\n"
"  -i, --hardware-platform  print the hardware platform\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     afficher la version du kernel\n"
"  -m, --machine            afficher le nom du système d'exploitation\n"
"  -p, --processor          afficher le type de processeur\n"
"  -i, --hardware-platform  afficher les infos matérielles de la plate-forme\n"
"  -o, --operating-system   afficher les infos du système d'exploitation\n"

#: src/uname.c:226
msgid "cannot get system name"
msgstr "ne peut obtenir le nom de système"

#: src/unexpand.c:379
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les blancs d'espacement de chaque FICHIER par des tabulations,\n"
"lors de l'écriture sur la sortie standard.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/unexpand.c:387
msgid ""
"  -a, --all        convert all whitespace, instead of just initial "
"whitespace\n"
"      --first-only convert only leading sequences of whitespace (overrides -"
"a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
"  -t, --tabs=LIST  use comma separated LIST of tab positions (enables -a)\n"
msgstr ""
"  -a, --all           convertir tous les espaces blancs,\n"
"                      au lieu du blanc d'espacement initial\n"
"      --first-only    convertir seulement les séquences de tête d'espaces "
"blancs (écrase -a)\n"
"  -t, --tabs=N        utiliser N caractères de tabulations au lieu de 8\n"
"  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
"                      de tabulation\n"
"                      séparées par des virgules\n"

#: src/unexpand.c:464
msgid "`-LIST' option is obsolete; use `--first-only -t LIST'"
msgstr "option « -LIST » est obsolète; utiliser « --first-only -t LIST »"

#: src/uniq.c:139
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Usage: %s [OPTION]... [ENTRÉE [SORTIE]]\n"

#: src/uniq.c:143
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
msgstr ""
"Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
"(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
"(ou vers la sortie standard).\n"
"\n"

#: src/uniq.c:151
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           préfixer les lignes par le nombre d'occurences\n"
"  -d, --repeated        afficher seulement les lignes ayant des duplicatats\n"

#: src/uniq.c:155
msgid ""
"  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -D, --all-repeated    afficher toutes les lignes qui ont des duplicatats\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        La délimitation est faite avec des lignes blanches.\n"
"  -f, --skip-fields=N   éviter de comparer les N premiers champs\n"
"  -i, --ignore-case     ignorer les différences de la casse\n"
"  -s, --skip-chars=N    éviter de comparer les N premiers caractères\n"
"  -u, --unique          afficher seulement les lignes uniques\n"

#: src/uniq.c:164
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=N   ne pas comparer plus de N caractères des lignes\n"

#: src/uniq.c:169
msgid ""
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"\n"
"Un champ est une suite de blancs, suivi de caractères non-blancs.\n"
"Les champs sont escamotés avant les caractères.\n"

#: src/uniq.c:381
#, c-format
msgid "error reading %s"
msgstr "Erreur lors de la lecture %s"

#: src/uniq.c:386
#, c-format
msgid "error writing %s"
msgstr "Erreur lors de l'écriture %s"

#: src/uniq.c:433 src/uniq.c:450
#, c-format
msgid "extra operand `%s'"
msgstr "opérande surnuméraire « %s »"

#: src/uniq.c:473 src/uniq.c:498
msgid "invalid number of fields to skip"
msgstr "nombre invalide de champs à escamoter"

#: src/uniq.c:507
msgid "invalid number of bytes to skip"
msgstr "nombre invalide d'octets à escamoter"

#: src/uniq.c:516
msgid "invalid number of bytes to compare"
msgstr "nombre invalide d'octets à comparer"

#: src/uniq.c:530
#, c-format
msgid "`-%lu' option is obsolete; use `-f %lu'"
msgstr "option « -%lu » est obsolète; utiliser « -f %lu »"

#: src/uniq.c:538
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"afficher toutes les lignes dupliquées et le décompte de répétition\n"
"est inutile"

#: src/unlink.c:51
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FICHIER...\n"
"  ou:  %s OPTION\n"

#: src/unlink.c:54
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Appeler la fonction unlink() pour enlever le fichier spécifié.\n"
"\n"

#: src/unlink.c:99
#, c-format
msgid "cannot unlink %s"
msgstr "ne peut enlever le lien %s"

#: src/uptime.c:129
msgid "couldn't get boot time"
msgstr "n'a pu obtenir la date du réamorçage"

#: src/uptime.c:136
#, c-format
msgid " %2d:%02d%s  up "
msgstr " %2d:%02d%s  up "

#: src/uptime.c:140
msgid "am"
msgstr "am"

#: src/uptime.c:140
msgid "pm"
msgstr "pm"

#: src/uptime.c:142
#, c-format
msgid "%d day"
msgid_plural "%d days"
msgstr[0] "jour"
msgstr[1] "jours"

#: src/uptime.c:144
#, c-format
msgid "%d user"
msgid_plural "%d users"
msgstr[0] "%d usager invalide"
msgstr[1] "%d usagers invalides"

#: src/uptime.c:157
#, c-format
msgid ",  load average: %.2f"
msgstr ",  charge moyenne: %.2f"

#: src/uptime.c:191 src/users.c:118
#, c-format
msgid "Usage: %s [OPTION]... [ FILE ]\n"
msgstr "Usage: %s [OPTION]... [FICHIER]\n"

#: src/uptime.c:192
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Afficher la date courante, la durée de temps depuis lequel le système\n"
"a été amorcé, le nombre d'usagers sur le système, et le nombre moyen\n"
"de tâches dans la file d'exécution depuis les dernières 1, 5 et 15 minutes.\n"
"Si FICHIER n'est pas utilisé, utiliser %s. %s comme FICHIER est d'usager "
"courant.\n"
"\n"

#: src/users.c:35
msgid "Joseph Arceneaux and David MacKenzie"
msgstr "Joseph Arceneaux et David MacKenzie"

#: src/users.c:119
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Afficher la liste des usagers actifs selon la liste contenue dans\n"
"le FICHIER.   Si le FICHIER n'est pas spécifié, utiliser %s.\n"
"L'utilisation de %s comme FICHIER est d'usage courant.\n"
"\n"

#: src/wc.c:75
msgid "Paul Rubin and David MacKenzie"
msgstr "Paul Rubin et David MacKenzie"

#: src/wc.c:129
msgid ""
"Print byte, word, and newline counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Afficher le décompte d'octets, de mots et lignes de chaque FICHIER, et\n"
"le nombre total de ligne si plus d'un FICHIER est spécifié.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"  -c, --bytes            afficher le nombre d'octets\n"
"  -m, --chars            afficher le nombre de caractères\n"
"  -l, --lines            afficher le nombre de lignes \n"

#: src/wc.c:137
msgid ""
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"  -L, --max-line-length  afficher la longueur de la ligne la plus longue\n"
"  -w, --words            afficher le nombre de mots\n"

#: src/who.c:41
msgid "Joseph Arceneaux, David MacKenzie, and Michael Stone"
msgstr "Joseph Arceneaux, David MacKenzie et Michael Stone"

#: src/who.c:223
msgid " old "
msgstr "vieux"

#: src/who.c:387 src/who.c:390
msgid "id="
msgstr "id="

#: src/who.c:403 src/who.c:408
msgid "term="
msgstr "term="

#: src/who.c:405 src/who.c:409
msgid "exit="
msgstr "sortie="

#: src/who.c:446
msgid "clock change"
msgstr "changement d'horloge"

#: src/who.c:458 src/who.c:459
msgid "run-level"
msgstr "niveau d'exécution"

#: src/who.c:462 src/who.c:463
msgid "last="
msgstr "dernier="

#: src/who.c:492
#, c-format
msgid ""
"\n"
"# users=%u\n"
msgstr ""
"\n"
"# usager=%u\n"

#: src/who.c:498
msgid "NAME"
msgstr "NOM"

#: src/who.c:498
msgid "LINE"
msgstr "LIGNE"

#: src/who.c:498
msgid "TIME"
msgstr "HEURE"

#: src/who.c:498
msgid "IDLE"
msgstr "OSIF"

#: src/who.c:498
msgid "PID"
msgstr "PID"

#: src/who.c:499
msgid "COMMENT"
msgstr "COMMENTAIRE"

#: src/who.c:499
msgid "EXIT"
msgstr "EXIT"

#: src/who.c:574
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Usage: %s [OPTION]... [ FICHIER | ARG1 ARG2]\n"

#: src/who.c:575
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all        afficher toutes les informations\n"
"  -b, --boot       afficher l'heure du dernier amorçage\n"
"  -d, --dead       afficher la liste des processus morts\n"
"  -H, --heading    afficher les lignes d'en-tête\n"

#: src/who.c:582
msgid ""
"  -i, --idle        add idle time as HOURS:MINUTES, . or old\n"
"                    (deprecated, use -u)\n"
"      --login       print system login processes\n"
"                    (equivalent to SUS -l)\n"
msgstr ""
"  -i, -u, --idle    ajouter le temps d'inactivité de l'usager en\n"
"                    selon le format HEURE:MINUTES, . ou « old »\n"
"      --login       afficher la liste des processus système de login\n"
"                    (équivalent à SUS -l)\n"

#: src/who.c:588
msgid ""
"  -l, --lookup      attempt to canonicalize hostnames via DNS\n"
"                    (-l is deprecated, use --lookup)\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"  -l, --lookup      utiliser la forme canonique des noms des hôtes\n"
"                    via le DNS (-l est déprécié, utiliser --lookup)\n"
"  -m                seulement du poste (hostname) et\n"
"                    de l'usager associé à « stdin »\n"
"  -p, --process     afficher la liste des processus lancés par init\n"

#: src/who.c:594
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       afficher tous les comptes actifs et le nombre d'usagers\n"
"                    présents sur le système\n"
"  -r, --runlevel    afficher le niveau d'exécution courant\n"
"  -s, --short       afficher seulement le nom, la ligne et l'heure (par "
"défaut)\n"
"  -t, --time        afficher l'heure du dernier changement d'heure de "
"l'horloge\n"

#: src/who.c:600
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    ajouter le statut du message usager avec +, - ou ?\n"
"  -u, --users       afficher la liste des usagers actifs\n"
"      --message     identique à -T\n"
"      --writeable   identique à -T\n"

#: src/who.c:608
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: `am i' or `mom likes' are usual.\n"
msgstr ""
"\n"
"Si FICHIER n'est pas spécifié, utilise %s.  %s comme FICHIER\n"
"est d'usage courant.  Si PARAM1 et PARAM2 sont fournis, -m est assumé:\n"
"« am i » ou « mom likes » sont d'usage courant.\n"

#: src/who.c:711
msgid "Warning: -i will be removed in a future release;   use -u instead"
msgstr ""
"AVERTISSEMENT: -i sera retiré dans une prochaine version; utiliser -u à la "
"place"

#: src/who.c:722
msgid ""
"Warning: the meaning of '-l' will change in a future release to conform to "
"POSIX"
msgstr ""
"AVERTISSEMENT: le sens de « -l » sera modifié dans une prochaine version "
"pour se conformer à POSIX"

#: src/whoami.c:53
msgid ""
"Print the user name associated with the current effective user id.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Afficher le nom de l'usager associé à l'identificateur effectif\n"
"courant de l'usager.  Identique à: id -un.\n"
"\n"

#: src/whoami.c:104
#, c-format
msgid "%s: cannot find username for UID %u\n"
msgstr "%s: ne trouve pas le nom de l'usager ayant le « UID » %u\n"

#: src/yes.c:49
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [CHAÎNE]...\n"
"  ou:  %s OPTION\n"

#: src/yes.c:55
msgid ""
"Repeatedly output a line with all specified STRING(s), or `y'.\n"
"\n"
msgstr ""
"Afficher à répétition une ligne de caractères telle que spécifiée\n"
"par CHAÎNE ou par « y ».\n"

#~ msgid "\\%c: invalid escape"
#~ msgstr "\\%c: échappement invalide"

#~ msgid "program error"
#~ msgstr "erreur du programme"

#~ msgid "stack overflow"
#~ msgstr "débordement de la pile"

#~ msgid "warning: unable to use large stack"
#~ msgstr "AVERTISSEMENT: incapable d'utiliser une grande pile"

#~ msgid "   Type"
#~ msgstr "   Type"

#~ msgid "missing file arguments"
#~ msgstr "arguments de fichier manquants"

#~ msgid "cannot change to `..' from directory %s"
#~ msgstr "ne peut aller vers `..' à partir du répertoire %s"

#~ msgid "%s: is so large that it is not representable"
#~ msgstr "%s: est tellement grand qu'il n'est pas représentable."

#, fuzzy
#~ msgid "cannot execute %s"
#~ msgstr "Ne peut changer la protection de %s"

#, fuzzy
#~ msgid "cannot run %s"
#~ msgstr "Ne peut changer la protection de %s"

#, fuzzy
#~ msgid "Try %s --help' for more information.\n"
#~ msgstr "Pour en savoir davantage, faites: « %s --help ».\n"

#, fuzzy
#~ msgid "preserving permissions for %s"
#~ msgstr "Ne peut changer les permissions de %s"

#, fuzzy
#~ msgid "cannot lstat `.'"
#~ msgstr "ne peut initialiser la date."

#, fuzzy
#~ msgid "closing directory %s"
#~ msgstr "ne peut aller vers le répertoire %s"

#, fuzzy
#~ msgid "%s: remove directory %s? "
#~ msgstr "Ne peut créer le répertoire %s"

#~ msgid "%s: directory %s is write protected; descend into it anyway? "
#~ msgstr "%s: répertoire %s protégé en écriture; le parcourir quand même?"

#~ msgid "removing all entries of directory %s\n"
#~ msgstr "destruction de toutes les entrées du répertoire %s\n"

#~ msgid "directory %s was replaced before being removed"
#~ msgstr "r/pertoire %s a été remplacé avant d'être enlevé"

#, fuzzy
#~ msgid "cannot change back to directory %s via `..'"
#~ msgstr "ne peut aller vers le répertoire %s"

#~ msgid "subdirectory of %s was moved while being removed"
#~ msgstr "sous-répertoire de %s a été déplacé pendant son déplacement"

#, fuzzy
#~ msgid "%s: remove directory %s%s? "
#~ msgstr "Ne peut créer le répertoire %s"

#~ msgid " (might be nonempty)"
#~ msgstr " (peut ne pas être vide)"

#, fuzzy
#~ msgid "removing the directory itself: %s\n"
#~ msgstr "AVERTISSEMENT: ne peut changer pour le répertoire %s"

#, fuzzy
#~ msgid "cannot remove current directory %s"
#~ msgstr "Ne peut créer le répertoire %s"

#~ msgid "continue? "
#~ msgstr "poursuivre? "

#~ msgid ""
#~ "ERROR: the source file %s initially had device/inode\n"
#~ "numbers %lu/%lu, but now (after opening it), the numbers\n"
#~ "are %lu/%lu.  That means that while this program was running,\n"
#~ "the file was replaced with another one.  Skipping this file."
#~ msgstr ""
#~ "ERREUR: le fichier source %s avait initialement un numéro de périphérique/"
#~ "inode\n"
#~ "%lu/%lu, mais à présent (après l'avoir ouvert), les numéros\n"
#~ "pour «.» sont %lu/%lu. Cela signifie que durant l'exécution du programme, "
#~ "le\n"
#~ "fichier a été remplacé soit par un autre. Fichier escamoté."

#, fuzzy
#~ msgid "cannot fork"
#~ msgstr "Ne peut changer la protection de %s"

#~ msgid ""
#~ "ERROR: the directory %s initially had device/inode\n"
#~ "numbers %lu/%lu, but now (after a chdir into it), the numbers for `.'\n"
#~ "are %lu/%lu.  That means that while rm was running, the directory\n"
#~ "was replaced with either another directory or a link to another directory."
#~ msgstr ""
#~ "ERREUR: le répertoire %s avait initialement un numéro de périphérique/"
#~ "inode\n"
#~ "%lu/%lu, mais à présent (après s'être positionné dedans par chdir), les "
#~ "numéros\n"
#~ "pour «.» sont %lu/%lu. Cela signifie que durant l'exécution de «rm», le\n"
#~ "répertoire a été remplacé soit par un autre répertoire ou un lien\n"
#~ "sur un autre répertoire."

#~ msgid ""
#~ "      --sparse=WHEN            control creation of sparse files\n"
#~ "  -R, --recursive              copy directories recursively\n"
#~ "      --reply={yes,no,query}   specify how to handle the prompt about an\n"
#~ "                                 existing destination file\n"
#~ "      --strip-trailing-slashes remove any trailing slashes from each "
#~ "SOURCE\n"
#~ "                                 argument\n"
#~ msgstr ""
#~ "      --sparse=DATE            contrôler la DATE de création des "
#~ "fichiers\n"
#~ "                               dispersés\n"
#~ "      --reply={yes,no,query}   spécifier comment traiter les requêtes à "
#~ "propos\n"
#~ "                               d'un fichier de destination existant\n"
#~ "      --strip-trailing-slashes enlever les '/' en suffixe de chacun\n"
#~ "                               des arguments SOURCE\n"

#~ msgid "  or:  %s [-acm] MMDDhhmm[YY] FILE... (obsolescent)\n"
#~ msgstr "  ou : %s [-acm] MMJJhhmm[AA] FICHIER... (désuet)\n"

#~ msgid ""
#~ "\n"
#~ "Note that the three time-date formats recognized for the -d and -t "
#~ "options\n"
#~ "and for the obsolescent argument are all different.\n"
#~ msgstr ""
#~ "\n"
#~ "Noter que les 3 formats du tampon date-heure sont reconnus pour les\n"
#~ "options -d et -t et les arguments désuets sont tous différents.\n"

#, fuzzy
#~ msgid ""
#~ "      --help             display this help and exit\n"
#~ "      --version          output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help                   display this help and exit\n"
#~ "      --version                output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help      display this help and exit\n"
#~ "      --version   output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#, fuzzy
#~ msgid ""
#~ "      --help                   display this help and exit\n"
#~ "      --version                output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Change the group membership of each FILE to GROUP.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link, "
#~ "rather\n"
#~ "                         than the symbolic link itself\n"
#~ "  -h, --no-dereference   affect symbolic links instead of any referenced "
#~ "file\n"
#~ "                         (available only on systems that can change the\n"
#~ "                         ownership of a symlink)\n"
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's group rather than the specified\n"
#~ "                         GROUP value\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "      --help             display this help and exit\n"
#~ "      --version          output version information and exit\n"
#~ msgstr ""
#~ "Changer le groupe d'appartenance de chaque FICHIER au GROUPE.\n"
#~ "\n"
#~ "  -c, --changes             utiliser le mode bavard mais rapporter "
#~ "seulement\n"
#~ "                            les modifications lorsqu'elles surviennent\n"
#~ "      --dereference         affecter le référent de chaque lien "
#~ "symbolique,\n"
#~ "                            plutôt que le lien symbolique lui-même\n"
#~ "  -h, --no-dereference      modifier les liens symboliques au lieu des\n"
#~ "                            fichiers référencés (disponible seulement\n"
#~ "                            sur les systèmes offrant l'appel système "
#~ "lchown)\n"
#~ "  -f, --silent, --quiet     supprimer la plupart des messages d'erreur\n"
#~ "      --reference=FICHIER   utiliser le groupe de référence du FICHIER\n"
#~ "                            au lieu d'une valeur de groupe\n"
#~ "  -R, --recursive           modifier récursivement fichiers et "
#~ "répertoires\n"
#~ "  -v, --verbose             produire un diagnostic pour chaque fichier "
#~ "traité\n"
#~ "      --help                afficher l'aide-mémoire\n"
#~ "      --version             afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link, "
#~ "rather\n"
#~ "                         than the symbolic link itself\n"
#~ "  -h, --no-dereference   affect symbolic links instead of any referenced "
#~ "file\n"
#~ "                         (available only on systems that can change the\n"
#~ "                         ownership of a symlink)\n"
#~ "      --from=CURRENT_OWNER:CURRENT_GROUP\n"
#~ "                         change the owner and/or group of each file only "
#~ "if\n"
#~ "                         its current owner and/or group match those "
#~ "specified\n"
#~ "                         here.  Either may be omitted, in which case a "
#~ "match\n"
#~ "                         is not required for the omitted attribute.\n"
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's owner and group rather than\n"
#~ "                         the specified OWNER:GROUP values\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "      --help             display this help and exit\n"
#~ "      --version          output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Changer le propriétaire et/ou le groupe de chaque FICHIER.\n"
#~ "\n"
#~ "  -c, --changes             utiliser le mode bavard mais rapporter "
#~ "seulement\n"
#~ "                            les modifications lorsqu'elles surviennent\n"
#~ "      --dereference         affecter le référent de chaque lien "
#~ "symbolique,\n"
#~ "                            plutôt que le lien symbolique lui-même\n"
#~ "  -h, --no-dereference      modifier les liens symboliques au lieu des\n"
#~ "                            fichiers référencés (disponible seulement\n"
#~ "                            sur les systèmes offrant l'appel système "
#~ "lchown)\n"
#~ "      --from=PROPRIÉTAIRE_COURANT:GROUPE_COURANT\n"
#~ "                            changer le propriétaire et/ou le groupe de "
#~ "chaque fichier\n"
#~ "                            seulement s'il y a concordance avec le "
#~ "propriétaire\n"
#~ "                            et/ou groupe courant spécifié. Les deux "
#~ "peuvent être\n"
#~ "                            omis, auquel cas la concordance n'est pas "
#~ "requise pour\n"
#~ "                            l'argument non spécifié.\n"
#~ "  -f, --silent, --quiet     supprimer la plupart des messages d'erreur\n"
#~ "      --reference=FICHIER   utiliser l'appartenance du propriétaire et "
#~ "du\n"
#~ "                            groupe du FICHIER de référence au lieu\n"
#~ "                            de valeurs explicites PROPRIÉTAIRE:GROUPE\n"
#~ "  -R, --recursive           modifier récursivement fichiers et "
#~ "répertoires\n"
#~ "  -v, --verbose             indiquer ce qui a été fait\n"
#~ "      --help                afficher l'aide-mémoire\n"
#~ "      --version             afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "  -l, --link                   link files instead of copying\n"
#~ "  -L, --dereference            always follow symbolic links\n"
#~ "  -p                           same as --preserve=mode,ownership,"
#~ "timestamps\n"
#~ "      --preserve[=ATTR_LIST]   preserve the specified attributes "
#~ "(default:\n"
#~ "                                 mode,ownership,timestamps), if possible\n"
#~ "                                 additional attributes: links, all\n"
#~ "      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
#~ "      --parents                append source path to DIRECTORY\n"
#~ "  -P                           same as `--no-dereference'\n"
#~ "  -r                           copy recursively, non-directories as "
#~ "files\n"
#~ "                                 WARNING: use -R instead when you might "
#~ "copy\n"
#~ "                                 special files like FIFOs or /dev/zero\n"
#~ "      --remove-destination     remove each existing destination file "
#~ "before\n"
#~ "                                 attempting to open it (contrast with --"
#~ "force)\n"
#~ msgstr ""
#~ "  -l, --link                 établir des liens sur les fichiers au lieu \n"
#~ "                             de copier\n"
#~ "  -L, --dereference          toujours suivre les liens symboliques\n"
#~ "  -p,                        identique à --preserve=mode,ownership,"
#~ "timestamps\n"
#~ "      --preserve[=ATTRIBUTS] préserver les attributs (par défaut:\n"
#~ "                             mode, propriété, )\n"
#~ "                             si possible et les attributs additionnels: "
#~ "links,all\n"
#~ "      --no-preserve[=ATTRIBUTS]\n"
#~ "                             ne pas préserver les attributs spécifiés\n"
#~ "      --parents              accoller le chemin du répertoire source au "
#~ "RÉPERTOIRE\n"
#~ "  -P                         identique à `--no-deference'\n"
#~ "  -r                         copier récursivement , les non-répertoires\n"
#~ "                             comme des fichiers\n"
#~ "                             ATTENTION: l'utilisation de -R à la place "
#~ "peut copier\n"
#~ "                             les fichiers spéciaux comme FIFO ou /dev/"
#~ "zero\n"
#~ "      --remove-destination   enlever chaque fichier de destination "
#~ "existant\n"
#~ "                             avant de l'ouvrir (par contraste avec --"
#~ "force)\n"

#~ msgid ""
#~ "      --sparse=WHEN            control creation of sparse files\n"
#~ "  -R, --recursive              copy directories recursively\n"
#~ "      --reply={yes,no,query}   specify how to handle the prompt about an\n"
#~ "                                 existing destination file\n"
#~ "      --strip-trailing-slashes remove any trailing slashes from each "
#~ "SOURCE\n"
#~ "                                 argument\n"
#~ "  -s, --symbolic-link          make symbolic links instead of copying\n"
#~ "  -S, --suffix=SUFFIX          override the usual backup suffix\n"
#~ "      --target-directory=DIRECTORY  move all SOURCE arguments into "
#~ "DIRECTORY\n"
#~ "  -u, --update                 copy only when the SOURCE file is newer\n"
#~ "                                 than the destination file or when the\n"
#~ "                                 destination file is missing\n"
#~ msgstr ""
#~ "      --sparse=DATE          contrôler la DATE de création des fichiers\n"
#~ "                             dispersés\n"
#~ "  -R, --recursive            copier récursivement les répertoires\n"
#~ "      --reply={yes,no,query} spécifier comment traiter les requêtes à "
#~ "propos\n"
#~ "                             d'un fichier de destination existant\n"
#~ "      --strip-trailing-slashes\n"
#~ "                             enlever les '/' en suffixe de chacun\n"
#~ "                             des arguments SOURCE\n"
#~ "  -s, --symbolic-link        créer des liens symboliques au lieu de "
#~ "copier\n"
#~ "  -S, --suffix=SUFFIXE       écraser le suffixe usuel d'archivage\n"
#~ "                             par le SUFFIXE\n"
#~ "      --target-directory=RÉPERTOIRE\n"
#~ "                             déplacer tous les fichiers SOURCE en "
#~ "arguments\n"
#~ "                             vers le RÉPERTOIRE\n"
#~ "  -u, --update               copier seulement lorsque le fichier SOURCE "
#~ "est\n"
#~ "                             plus récent que le fichier de DESTINATION "
#~ "ou\n"
#~ "                             lorsque le fichier de DESTINATION n'existe "
#~ "pas\n"

#~ msgid ""
#~ "Copy a file, converting and formatting according to the options.\n"
#~ "\n"
#~ "  bs=BYTES        force ibs=BYTES and obs=BYTES\n"
#~ "  cbs=BYTES       convert BYTES bytes at a time\n"
#~ "  conv=KEYWORDS   convert the file as per the comma separated keyword "
#~ "list\n"
#~ "  count=BLOCKS    copy only BLOCKS input blocks\n"
#~ "  ibs=BYTES       read BYTES bytes at a time\n"
#~ "  if=FILE         read from FILE instead of stdin\n"
#~ "  obs=BYTES       write BYTES bytes at a time\n"
#~ "  of=FILE         write to FILE instead of stdout\n"
#~ "  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output\n"
#~ "  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input\n"
#~ "      --help      display this help and exit\n"
#~ "      --version   output version information and exit\n"
#~ "\n"
#~ "BLOCKS and BYTES may be followed by the following multiplicative "
#~ "suffixes:\n"
#~ "xM M, c 1, w 2, b 512, kD 1000, k 1024, MD 1,000,000, M 1,048,576,\n"
#~ "GD 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y.\n"
#~ "Each KEYWORD may be:\n"
#~ "\n"
#~ "  ascii     from EBCDIC to ASCII\n"
#~ "  ebcdic    from ASCII to EBCDIC\n"
#~ "  ibm       from ASCII to alternated EBCDIC\n"
#~ "  block     pad newline-terminated records with spaces to cbs-size\n"
#~ "  unblock   replace trailing spaces in cbs-size records with newline\n"
#~ "  lcase     change upper case to lower case\n"
#~ "  notrunc   do not truncate the output file\n"
#~ "  ucase     change lower case to upper case\n"
#~ "  swab      swap every pair of input bytes\n"
#~ "  noerror   continue after read errors\n"
#~ "  sync      pad every input block with NULs to ibs-size; when used\n"
#~ "              with block or unblock, pad with spaces rather than NULs\n"
#~ msgstr ""
#~ "Copier un fichier, en le convertissant et le formatant selon les "
#~ "options:\n"
#~ "\n"
#~ "  bs=N            forcer ibs=N octets et obs=N octets\n"
#~ "  cbs=N           convertir N octets à la fois\n"
#~ "  conv=CLÉS       convertir le fichier selon les mots CLÉS d'une liste\n"
#~ "                  séparés par une virgule\n"
#~ "  count=N         copier seulement N blocs à partir de l'entrée\n"
#~ "  ibs=N           lire N octets à la fois\n"
#~ "  if=FICHIER      lire à partir du FICHIER au lieu de l'entrée standard\n"
#~ "  obs=N           écrire N octets à la fois\n"
#~ "  of=FICHIER      écrire dans le FICHIER au lieu de la sortie standard\n"
#~ "  seek=N          escamoter N blocs de taille 'obs' du fichier de sortie\n"
#~ "  skip=N          escamoter N blocs de taille 'ibs' du fichier d'entrée\n"
#~ "      --help      afficher l'aide-mémoire\n"
#~ "      --version   afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "N peut être suivi d'un suffixe multiplicatif suivant:,\n"
#~ "xM M, c 1, w 2, b 512, kD 1000, k 1024, MD 1,000,000, M 1,048,576,\n"
#~ "GD 1,000,000,000, G 1,073,741,824, et ainsi de suite pour T, P, E, Z, Y.\n"
#~ "Chaque mot CLÉ peut être:\n"
#~ "\n"
#~ "  ascii     de l'EBCDIC vers l'ASCII\n"
#~ "  ebcdic    de l'ASCII  vers l'EBCDIC\n"
#~ "  ibm       de l'ASCII  vers l'EBCDIC en utilisant une table différente\n"
#~ "  block     remplir les enregistrements terminés par un saut de ligne\n"
#~ "            par des blancs jusqu'à l'obtention de la taille 'cbs'\n"
#~ "  unblock   remplacer les blancs de la fin des enregistrements\n"
#~ "            de taille 'cbs' par des sauts de ligne\n"
#~ "  lcase     changer les majuscules en minuscules\n"
#~ "  notrunc   ne pas tronquer le fichier de sortie\n"
#~ "  ucase     changer les minuscules en majuscules\n"
#~ "  swab      interchanger chaque paire d'octets\n"
#~ "  noerror   continuer même après des erreurs de lecture\n"
#~ "  sync      remplir chaque bloc lu par des nuls jusqu'à concurrence\n"
#~ "            de la taille 'ibs'\n"

#~ msgid ""
#~ "Show information about the filesystem on which each FILE resides,\n"
#~ "or all filesystems by default.\n"
#~ "\n"
#~ "  -a, --all             include filesystems having 0 blocks\n"
#~ "      --block-size=SIZE use SIZE-byte blocks\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "  -H, --si              likewise, but use powers of 1000 not 1024\n"
#~ "  -i, --inodes          list inode information instead of block usage\n"
#~ "  -k, --kilobytes       like --block-size=1024\n"
#~ "  -l, --local           limit listing to local filesystems\n"
#~ "  -m, --megabytes       like --block-size=1048576\n"
#~ "      --no-sync         do not invoke sync before getting usage info "
#~ "(default)\n"
#~ "  -P, --portability     use the POSIX output format\n"
#~ "      --sync            invoke sync before getting usage info\n"
#~ "  -t, --type=TYPE       limit listing to filesystems of type TYPE\n"
#~ "  -T, --print-type      print filesystem type\n"
#~ "  -x, --exclude-type=TYPE   limit listing to filesystems not of type "
#~ "TYPE\n"
#~ "  -v                    (ignored)\n"
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ msgstr ""
#~ "Afficher les informations à propos du système de fichiers sur lequel\n"
#~ "réside chaque FICHIER ou de tous les systèmes de fichier par défaut.\n"
#~ "\n"
#~ "  -a, --all               inclure les systèmes de fichiers ayant 0 bloc\n"
#~ "      --block-size=TAILLE utiliser la TAILLE de blocs\n"
#~ "  -h, --human-readable    afficher les tailles dans un format lisible "
#~ "par\n"
#~ "                          un humain (i.e. 1K 234M 2G)\n"
#~ "  -H, --si                idem mais utiliser un multiple de 1000\n"
#~ "                          au lieu de 1024\n"
#~ "  -i, --inodes            lister les informations sur les 'inodes'\n"
#~ "                          plutôt que sur l'utilisation des blocs\n"
#~ "  -k, --kilobytes         utiliser des blocs de 1024 octets, et non pas\n"
#~ "                          de 512 octets malgré l'option POSIXLY_CORRECT\n"
#~ "  -m, --megabytes         utiliser des blocs de 1024K-octets, et non pas\n"
#~ "                          de 512 octets malgré l'option POSIXLY_CORRECT\n"
#~ "      --no-sync           ne pas effectuer une synchronisation avant\n"
#~ "                          d'obtenir les informations d'utilisation\n"
#~ "                          des disques (par défaut)\n"
#~ "  -P, --portability       utiliser le format de sortie POSIX\n"
#~ "      --sync              demander une synchronisation avant d'obtenir "
#~ "les\n"
#~ "                          informations d'utilisation des disques\n"
#~ "                          (par défaut)\n"
#~ "  -t, --type=TYPE         limiter l'affichage au TYPE de système de\n"
#~ "                          fichiers\n"
#~ "  -T, --print-type        afficher le type du système de fichiers\n"
#~ "  -x, --exclude-type=TYPE limiter l'affichage en excluant le TYPE\n"
#~ "                          de système de fichiers\n"
#~ "  -v                      (ignorée)\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Summarize disk usage of each FILE, recursively for directories.\n"
#~ "\n"
#~ "  -a, --all             write counts for all files, not just directories\n"
#~ "      --block-size=SIZE use SIZE-byte blocks\n"
#~ "  -b, --bytes           print size in bytes\n"
#~ "  -c, --total           produce a grand total\n"
#~ "  -D, --dereference-args  dereference PATHs when symbolic link\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "  -H, --si              likewise, but use powers of 1000 not 1024\n"
#~ "  -k, --kilobytes       like --block-size=1024\n"
#~ "  -l, --count-links     count sizes many times if hard linked\n"
#~ "  -L, --dereference     dereference all symbolic links\n"
#~ "  -m, --megabytes       like --block-size=1048576\n"
#~ "  -S, --separate-dirs   do not include size of subdirectories\n"
#~ "  -s, --summarize       display only a total for each argument\n"
#~ "  -x, --one-file-system  skip directories on different filesystems\n"
#~ "  -X FILE, --exclude-from=FILE  Exclude files that match any pattern in "
#~ "FILE.\n"
#~ "      --exclude=PAT     Exclude files that match PAT.\n"
#~ "      --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ msgstr ""
#~ "Produire un sommaire de l'utilisation de l'espace disque de chaque "
#~ "FICHIER,\n"
#~ "et récursivement dans les répertoires.\n"
#~ "\n"
#~ "  -a, --all                afficher le décompte pour tous les fichiers,\n"
#~ "                           pas seulement pour les répertoires\n"
#~ "      --block-size=TAILLE  utiliser la TAILLE de blocs\n"
#~ "  -b, --bytes              afficher la taille en octets\n"
#~ "  -c, --total              produire le grand total\n"
#~ "  -D, --dereference-args   ne pas tenir compte des CHEMINS lorsqu'il y a\n"
#~ "                           des liens symboliques\n"
#~ "  -h, --human-readable     afficher les tailles dans un format lisible "
#~ "par\n"
#~ "                           un humain (i.e. 1K 234M 2G)\n"
#~ "  -H, --si                 idem mais utiliser un multiple de 1000\n"
#~ "                           au lieu de 1024\n"
#~ "  -k, --kilobytes          utiliser des blocs de 1024 octets, et non pas\n"
#~ "                           de 512 octets malgré l'option POSIXLY_CORRECT\n"
#~ "  -l, --count-links        dénombrer les tailles aussi souvent qu'il y a\n"
#~ "                           de liens directs\n"
#~ "  -L, --dereference        ne pas tenir compte de tous les liens\n"
#~ "                           symboliques\n"
#~ "  -m, --megabytes          utiliser des blocs de 1024K-octets, et non "
#~ "pas\n"
#~ "                           de 512 octets malgré l'option POSIXLY_CORRECT\n"
#~ "  -S, --separate-dirs      ne pas inclure la taille des sous-répertoires\n"
#~ "  -s, --summarize          afficher seulement un total pour chaque type\n"
#~ "                           d'argument\n"
#~ "  -x, --one-file-system    escamoter les répertoires de différents\n"
#~ "  -X FICHIER,               \n"
#~ "      --exclude-from=FICHIER\n"
#~ "                           exclure les fichiers qui concordent avec\n"
#~ "                           le nom du FICHIER\n"
#~ "      --exclude=EXPRES     exclure les fichier qui concordent avec\n"
#~ "                           l'expression\n"
#~ "      --max-depth=N        afficher le total pour un répertoire (ou un\n"
#~ "                           fichier, avec l'option --all) seulement\n"
#~ "                           si N a moins de niveau dans la ligne de "
#~ "commande;\n"
#~ "                           --max-depth=0 est identique à --summurize\n"
#~ "                           systèmes de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "In the first two formats, copy SOURCE to DEST or multiple SOURCE(s) to\n"
#~ "the existing DIRECTORY, while setting permission modes and owner/group.\n"
#~ "In the third format, create all components of the given DIRECTORY(ies).\n"
#~ "\n"
#~ "      --backup[=CONTROL] make a backup of each existing destination file\n"
#~ "  -b                  like --backup but does not accept an argument\n"
#~ "  -c                  (ignored)\n"
#~ "  -d, --directory     treat all arguments as directory names; create all\n"
#~ "                        components of the specified directories\n"
#~ "  -D                  create all leading components of DEST except the "
#~ "last,\n"
#~ "                        then copy SOURCE to DEST;  useful in the 1st "
#~ "format\n"
#~ "  -g, --group=GROUP   set group ownership, instead of process' current "
#~ "group\n"
#~ "  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-"
#~ "xr-x\n"
#~ "  -o, --owner=OWNER   set ownership (super-user only)\n"
#~ "  -p, --preserve-timestamps   apply access/modification times of SOURCE "
#~ "files\n"
#~ "                        to corresponding destination files\n"
#~ "  -s, --strip         strip symbol tables, only for 1st and 2nd formats\n"
#~ "  -S, --suffix=SUFFIX override the usual backup suffix\n"
#~ "  -v, --verbose       print the name of each directory as it is created\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Dans les deux premiers formats, copier la SOURCE vers la DESTINATION ou "
#~ "des\n"
#~ "fichiers de plusieurs SOURCE(S) vers un RÉPERTOIRE existant, tout en "
#~ "initialisant\n"
#~ "les bits de protection et l'appartenance propriétaire/groupe.  Dans le\n"
#~ "3e format, créer tous les composants des RÉPERTOIRES spécifiés.\n"
#~ "\n"
#~ "      --backup[=CONTRÔLE]   archiver chaque fichier de destination\n"
#~ "  -b                        identique à --backup mais sans argument\n"
#~ "  -c                        (ignorée)\n"
#~ "  -d, --directory           créer les répertoires de tête,\n"
#~ "                            obligatoire dans le dans le 3e format\n"
#~ "  -D                        créer tous les composants de tête de la\n"
#~ "                            DESTINATION excepté le dernier\n"
#~ "                            ensuite copier la SOURCE vers la DESTINATION\n"
#~ "                            (pratique lorsque le 1er format est utlisé)\n"
#~ "  -g, --group=GROUPE        attribuer l'appartenance au GROUPE,\n"
#~ "                            plutôt qu'au groupe courant du processus\n"
#~ "  -m, --mode=MODE           initialiser les permissions d'accès au MODE\n"
#~ "                            (comme par chmod), au lieu de rw-r--r--\n"
#~ "  -o, --owner=PROPRIÉTAIRE  attribuer l'appartenance au PROPRIÉTAIRE\n"
#~ "                            (mode super-user seulement)\n"
#~ "  -p, --preserve-timestamps conserver les dates d'accès et de "
#~ "modification\n"
#~ "                            des fichiers SOURCES aux fichiers de la "
#~ "DESTINATION\n"
#~ "  -s, --strip               enlever les tables de symboles,\n"
#~ "                            valable pour les 1er et 2e formats seulement\n"
#~ "  -S, --suffix=SUFFIXE      écraser le SUFFIXE usuel d'archivage\n"
#~ "  -v, --verbose             afficher le nom de chaque répertoire créé\n"
#~ "      --help                afficher l'aide-mémoire\n"
#~ "      --version             afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "Create a link to the specified TARGET with optional LINK_NAME.\n"
#~ "If LINK_NAME is omitted, a link with the same basename as the TARGET is\n"
#~ "created in the current directory.  When using the second form with more\n"
#~ "than one TARGET, the last argument must be a directory;  create links\n"
#~ "in DIRECTORY to each TARGET.  Create hard links by default, symbolic\n"
#~ "links with --symbolic.  When creating hard links, each TARGET must "
#~ "exist.\n"
#~ "\n"
#~ "      --backup[=CONTROL]      make a backup of each existing destination "
#~ "file\n"
#~ "  -b                          like --backup but does not accept an "
#~ "argument\n"
#~ "  -d, -F, --directory         hard link directories (super-user only)\n"
#~ "  -f, --force                 remove existing destination files\n"
#~ "  -n, --no-dereference        treat destination that is a symlink to a\n"
#~ "                                directory as if it were a normal file\n"
#~ "  -i, --interactive           prompt whether to remove destinations\n"
#~ "  -s, --symbolic              make symbolic links instead of hard links\n"
#~ "  -S, --suffix=SUFFIX         override the usual backup suffix\n"
#~ "      --target-directory=DIRECTORY  specify the DIRECTORY in which to "
#~ "create\n"
#~ "                                the links\n"
#~ "  -v, --verbose               print name of each file before linking\n"
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Créer un lien vers la CIBLE spécifiée avec optionnellement un "
#~ "NOM_DE_LIEN.\n"
#~ "S'il y le NOM_DE_LIEN est omis, un lien ayant la même base comme CIBLE "
#~ "est\n"
#~ "créé dans le répertoire courant. Lors de l'utilisation de la seconde "
#~ "forme\n"
#~ "avec plus d'une CIBLE, le dernier argument doit être un répertoire;\n"
#~ "créer des liens dans le RÉPERTOIRE pour chaque CIBLE.  Créer des liens "
#~ "directs\n"
#~ "par défaut et des liens symboliques avec l'option --symbolic.  Lors de "
#~ "la\n"
#~ "création de liens directs, chaque CIBLE doit exister.\n"
#~ "\n"
#~ "      --backup[=CONTRÔLE]    archiver chaque fichier de destination\n"
#~ "  -b                         identique à --backup mais sans argument\n"
#~ "  -d, -F, --directory        créer un lien direct à un répertoire\n"
#~ "                             (super-user seulement)\n"
#~ "  -f, --force                détruire les destinations existantes,\n"
#~ "                             sans demander confirmation\n"
#~ "  -n, --no-dereference       avec --force, détruire la destination qui\n"
#~ "                             est un lien symbolique vers un répertoire \n"
#~ "  -i, --interactive          demander confirmation avant de détruire\n"
#~ "                             les destinations\n"
#~ "  -s, --symbolic             créer un lien symbolique au lieu d'un\n"
#~ "                             lien direct\n"
#~ "  -S, --suffix=SUFFIXE       écraser le suffixe d'archivage par le "
#~ "SUFFIXE\n"
#~ "      --target-directory=RÉPERTOIRE\n"
#~ "                             déplacer tous les fichiers SOURCE en "
#~ "arguments\n"
#~ "                             vers le RÉPERTOIRE\n"
#~ "  -v, --verbose              afficher le nom de chaque fichier avant de "
#~ "créer un lien\n"
#~ "      --help                 afficher l'aide-mémoire\n"
#~ "      --version              afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "List information about the FILEs (the current directory by default).\n"
#~ "Sort entries alphabetically if none of -cftuSUX nor --sort.\n"
#~ "\n"
#~ "  -a, --all                  do not hide entries starting with .\n"
#~ "  -A, --almost-all           do not list implied . and ..\n"
#~ "  -b, --escape               print octal escapes for nongraphic "
#~ "characters\n"
#~ "      --block-size=SIZE      use SIZE-byte blocks\n"
#~ "  -B, --ignore-backups       do not list implied entries ending with ~\n"
#~ "  -c                         with -lt: sort by, and show, ctime (time of "
#~ "last\n"
#~ "                               modification of file status information)\n"
#~ "                               with -l: show ctime and sort by name\n"
#~ "                               otherwise: sort by ctime\n"
#~ "  -C                         list entries by columns\n"
#~ "      --color[=WHEN]         control whether color is used to distinguish "
#~ "file\n"
#~ "                               types.  WHEN may be `never', `always', or "
#~ "`auto'\n"
#~ "  -d, --directory            list directory entries instead of contents\n"
#~ "  -D, --dired                generate output designed for Emacs' dired "
#~ "mode\n"
#~ "  -f                         do not sort, enable -aU, disable -lst\n"
#~ "  -F, --classify             append indicator (one of */=@|) to entries\n"
#~ "      --format=WORD          across -x, commas -m, horizontal -x, long -"
#~ "l,\n"
#~ "                               single-column -1, verbose -l, vertical -C\n"
#~ "      --full-time            like -l --time-style=full-iso\n"
#~ msgstr ""
#~ "Afficher les informations au sujet des FICHIERS (du répertoire\n"
#~ "courant par défaut). Trier les entrées alphabétiquement si aucune\n"
#~ "des options  -cftuSUX  ou  --sort n'est utilisée.\n"
#~ "\n"
#~ "  -a, --all                  afficher les noms cachés débutant par .\n"
#~ "  -A, --almost-all           ne pas inclure dans la liste . et ..\n"
#~ "  -b, --escape               afficher en octal les caractères\n"
#~ "                             non-graphiques\n"
#~ "                             en utilisant des séquences d'échappement\n"
#~ "      --block-size=TAILLE    utiliser la TAILLE de blocs\n"
#~ "  -B, --ignore-backups       ne pas inclure dans la liste,\n"
#~ "                             les entrées se terminant par ~\n"
#~ "  -c                         lister les fichiers triés selon leur date "
#~ "de\n"
#~ "                             modification; \n"
#~ "                             avec -lt:  trier par la deate de "
#~ "modification\n"
#~ "                                        et afficher la date de "
#~ "modification (ctime)\n"
#~ "                             avec -l:   trier par nom et afficher avec\n"
#~ "                                        avec la date de modification "
#~ "(ctime)\n"
#~ "                             autrement: trier par la date de modification "
#~ "(ctime)\n"
#~ "  -C                         afficher en colonnes\n"
#~ "      --color[=PARAM]        afficher les fichiers avec une couleur "
#~ "selon\n"
#~ "                             leur type à l'aide d'un des PARAMètres\n"
#~ "                             suivants: never, always ou auto\n"
#~ "  -d, --directory            lister les noms de répertoires plutôt\n"
#~ "                             que leur contenu\n"
#~ "  -D, --dired                générer une sortie adaptée pour le mode\n"
#~ "                             'dired' de Emacs\n"
#~ "  -f                         ne pas trier, autoriser -aU, interdire -lst\n"
#~ "  -F, --classify             ajouter un caractère (parmi */=@|) pour "
#~ "chaque entrée\n"
#~ "      --format=MODE          afficher selon le MODE suivant: -x croisé,\n"
#~ "                             -m avec virgules, -x horizontal, -l long,\n"
#~ "                             -1 en colonne simple, -l en mode bavard,\n"
#~ "                             -C vertical\n"
#~ "      --full-time            identique à -l --time-style=full-iso\n"

#~ msgid ""
#~ "  -g                         like -l, but do not list owner\n"
#~ "  -G, --no-group             inhibit display of group information\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "      --si                   likewise, but use powers of 1000 not 1024\n"
#~ "  -H, --dereference-command-line  follow symbolic links on the command "
#~ "line\n"
#~ "      --indicator-style=WORD append indicator with style WORD to entry "
#~ "names:\n"
#~ "                               none (default), classify (-F), file-type (-"
#~ "p)\n"
#~ "  -i, --inode                print index number of each file\n"
#~ "  -I, --ignore=PATTERN       do not list implied entries matching shell "
#~ "PATTERN\n"
#~ "  -k, --kilobytes            like --block-size=1024\n"
#~ "  -l                         use a long listing format\n"
#~ "  -L, --dereference          when showing file information for a "
#~ "symbolic\n"
#~ "                               link, show information for the file the "
#~ "link\n"
#~ "                               references rather than for the link "
#~ "itself\n"
#~ "  -m                         fill width with a comma separated list of "
#~ "entries\n"
#~ msgstr ""
#~ "  -g                         (ignorée)\n"
#~ "  -G, --no-group             inhiber l'affichage des informations de "
#~ "groupe\n"
#~ "  -h, --human-readable       afficher les tailles dans un format lisible "
#~ "par\n"
#~ "      --si                   un humain (i.e. 1K 234M 2G) en utilisant un "
#~ "multiple\n"
#~ "                             1000 et non pas de 1024\n"
#~ "  -H, --dereference-command-line\n"
#~ "                             suivre les liens symboliques de la ligne de "
#~ "commande\n"
#~ "      --indicator-style=CODE ajouter en suffixe l'indicateur selon le "
#~ "CODE:\n"
#~ "                             none (par défaut), classify (-F), file-type "
#~ "(-p)\n"
#~ "  -i, --inode                afficher le numéro d'index de chaque "
#~ "fichier\n"
#~ "  -I, --ignore=PATRON        ne pas inclure dans la liste les entrées\n"
#~ "                             concordant avec le PATRON de shell\n"
#~ "  -k, --kilobytes            identique à --block-size=1024\n"
#~ "  -l                         utiliser le format long d'affichage\n"
#~ "  -L, --dereference          afficher les entrées pointées par des\n"
#~ "                             liens symboliques, monter l'information "
#~ "pointée par le lien\n"
#~ "  -m                         remplir la largeur par une liste d'entrées\n"
#~ "                             séparée par des virgules\n"

#~ msgid ""
#~ "  -S                         sort by file size\n"
#~ "      --sort=WORD            extension -X, none -U, size -S, time -t,\n"
#~ "                               version -v\n"
#~ "                             status -c, time -t, atime -u, access -u, use "
#~ "-u\n"
#~ "      --time=WORD            show time as WORD instead of modification "
#~ "time:\n"
#~ "                               atime, access, use, ctime or status; use\n"
#~ "                               specified time as sort key if --sort=time\n"
#~ "      --time-style=WORD      show times using style WORD:\n"
#~ "                               full-iso, iso, locale, posix-iso\n"
#~ "  -t                         sort by modification time\n"
#~ "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
#~ "  -u                         with -lt: sort by, and show, access time\n"
#~ "                               with -l: show access time and sort by "
#~ "name\n"
#~ "                               otherwise: sort by access time\n"
#~ "  -U                         do not sort; list entries in directory "
#~ "order\n"
#~ "  -v                         sort by version\n"
#~ "  -w, --width=COLS           assume screen width instead of current "
#~ "value\n"
#~ "  -x                         list entries by lines instead of by columns\n"
#~ "  -X                         sort alphabetically by entry extension\n"
#~ "  -1                         list one file per line\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ "\n"
#~ "By default, color is not used to distinguish types of files.  That is\n"
#~ "equivalent to using --color=none.  Using the --color option without the\n"
#~ "optional WHEN argument is equivalent to using --color=always.  With\n"
#~ "--color=auto, color codes are output only if standard output is "
#~ "connected\n"
#~ "to a terminal (tty).\n"
#~ msgstr ""
#~ "  -S                         trier selon la taille des fichiers\n"
#~ "      --sort=CODE            trier selon le CODE suivant: -c pour ctime,\n"
#~ "                             -X pour extension, -U pour aucun,\n"
#~ "                             -S pour la taille, -t pour la date\n"
#~ "                             -v pour la version, -c pour le statut, \n"
#~ "                             -u pour la date d'accès, -u pour l'accès\n"
#~ "      --time=CODE            afficher les temps d'accès en mots au lieu "
#~ "de\n"
#~ "                             date de modification:\n"
#~ "                             atime, access, use, ctime ou status\n"
#~ "      --time-style=CODE      afficher les dates selon le CODE:\n"
#~ "                             full-iso, iso, locale, posix-iso\n"
#~ "  -t                         trier par la date de modification; avec -l:\n"
#~ "                             afficher 'mtime'\n"
#~ "  -T, --tabsize=TAILLE       utiliser la tabulation de la TAILLE\n"
#~ "                             pour chaque colonne au lieu de 8\n"
#~ "  -u                         trier selon la date du dernier accès; avec -"
#~ "l:\n"
#~ "                             afficher 'atime'\n"
#~ "  -U                         ne pas trier: afficher selon l'ordre\n"
#~ "                             original des entrées d'un répertoire\n"
#~ "  -v                         trier par version\n"
#~ "  -w, --width=LARGEUR        utiliser la LARGEUR d'écran au lieu\n"
#~ "                             des valeurs courantes\n"
#~ "  -x                         afficher les entrées par lignes plutôt que\n"
#~ "                             par colonnes\n"
#~ "  -X                         trier alphabétiquement par extension des\n"
#~ "                             entrées\n"
#~ "  -1                         afficher un fichier par ligne\n"
#~ "      --help                 afficher l'aide-mémoire\n"
#~ "      --version              afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Par défaut, la couleur n'est pas utilisée pour distinguer les différents "
#~ "types\n"
#~ "de fichiers. Cela est équivalent à l'utilisation de l'option --"
#~ "color=none.  \n"
#~ "L'utilisation de l'option --color sans l'argument WHEN est équivalent à\n"
#~ "l'utilisation de --colors=always.  Avec l'option --color=auto, les codes "
#~ "de\n"
#~ "couleur sont transmis vers la sortie standard si celle-ci est reliée à "
#~ "un \n"
#~ "terminal (tty).\n"

#, fuzzy
#~ msgid ""
#~ "Create named pipes (FIFOs) with the given NAMEs.\n"
#~ "\n"
#~ "  -m, --mode=MODE   set permission mode (as in chmod), not a=rw - umask\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
#~ "for even very expensive hardware probing to recover the data.\n"
#~ "\n"
#~ "  -f, --force    change permissions to allow writing if necessary\n"
#~ "  -n, --iterations=N  Overwrite N times instead of the default (%d)\n"
#~ "  -s, --size=N   shred this many bytes (suffixes like k, M, G accepted)\n"
#~ "  -u, --remove   truncate and remove file after overwriting\n"
#~ "  -v, --verbose  show progress\n"
#~ "  -x, --exact    do not round file sizes up to the next full block\n"
#~ "  -z, --zero     add a final overwrite with zeros to hide shredding\n"
#~ "  -              shred standard output\n"
#~ "      --help     display this help and exit\n"
#~ "      --version  print version information and exit\n"
#~ "\n"
#~ "Delete FILE(s) if --remove (-u) is specified.  The default is not to "
#~ "remove\n"
#~ "the files because it is common to operate on device files like /dev/hda,\n"
#~ "and those files usually should not be removed.  When operating on "
#~ "regular\n"
#~ "files, most people use the --remove option.\n"
#~ "\n"
#~ "CAUTION: Note that shred relies on a very important assumption:\n"
#~ "that the filesystem overwrites data in place.  This is the traditional\n"
#~ "way to do things, but many modern filesystem designs do not satisfy this\n"
#~ "assumption.  The following are examples of filesystems on which shred is\n"
#~ "not effective:\n"
#~ "\n"
#~ "* log-structured or journaled filesystems, such as those supplied with\n"
#~ "  AIX and Solaris (and JFS, ReiserFS, XFS, etc.)\n"
#~ "\n"
#~ "* filesystems that write redundant data and carry on even if some writes\n"
#~ "  fail, such as RAID-based filesystems\n"
#~ "\n"
#~ "* filesystems that make snapshots, such as Network Appliance's NFS "
#~ "server\n"
#~ "\n"
#~ "* filesystems that cache in temporary locations, such as NFS\n"
#~ "  version 3 clients\n"
#~ "\n"
#~ "* compressed filesystems\n"
#~ "\n"
#~ "In addition, file system backups and remote mirrors may contain copies\n"
#~ "of the file that cannot be removed, and that will allow a shredded file\n"
#~ "to be recovered later.\n"
#~ msgstr ""
#~ "Écraser un fichier de façon répétitive, afin de rendre difficile\n"
#~ "toute récupération des données par du matériel même coûteux.\n"
#~ "\n"
#~ "  -f, --force         modifier les permissions pour permettre\n"
#~ "                      l'écriture si nécessaire\n"
#~ "  -n, --iterations=N  écraser N fois au lieu du nombre par défaut %d\n"
#~ "  -s, --size=N        déchiqueter N octets (les suffixes k, M, G sont "
#~ "acceptés)\n"
#~ "  -u, --remove        tronquer et détruire le fichier après l'avoir "
#~ "écraser\n"
#~ "  -v, --verbose       afficher un indicateur de progrès\n"
#~ "  -x, --exact         ne pas arrondir la taille des fichiers\n"
#~ "                      jusqu'au prochain bloc complet\n"
#~ "  -z, --zero          ajouter une écriture finale avec des zéros\n"
#~ "                      pour camoufler le déchiquetage du fichier\n"
#~ "  -                   déchiqueter l'entrée standard \n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Détruire le FICHIER si --remove (-u) est spécifié. Le défaut est de ne "
#~ "pas détruire\n"
#~ "les fichiers parce qu'il est commun d'opérer sur le fichier du "
#~ "périphérique comme /dev/hda,\n"
#~ "et habituellement ces fichiers ne sont pas détruits.  Sur des fichier "
#~ "réguliers,\n"
#~ "la plupart des gens utilise l'option --remove.\n"
#~ "\n"
#~ "ATTENTION: noter que le déchiquetage s'appuie sur l'hypothèse que \n"
#~ "le système de fichiers écrasera les données en place. Cela est la "
#~ "manière\n"
#~ "traditionnelle de faire les choses, mais plusieurs design modernes de "
#~ "systèmes\n"
#~ "de fichiers ne se satisfont pas de cette hypothèse. Les exemples suivants "
#~ "de systèmes\n"
#~ "de fichiers sont ceux où le déchiquetage n'est pas effectif:\n"
#~ "\n"
#~ "* systèmes de fichiers à journalisation, comme ceux fournis avec\n"
#~ "  AIX et Solaris (et JFS, ReiserFS, XFS, etc.)\n"
#~ "\n"
#~ "* systèmes de fichiers avec écriture redondante et soutienne les "
#~ "écritures\n"
#~ "  même lorsqu'il y a erreur d'écriture\n"
#~ "  comme les systèmes de fichiers RAID\n"
#~ "\n"
#~ "* systèmes de fichiers qui prennent des instantanés, comme\n"
#~ "  le serveur NFS de Network Appliance\n"
#~ "\n"
#~ "* systèmes de fichiers qui utilisent des caches temporaires,\n"
#~ "  comme NFS la version 3 clientète\n"
#~ "\n"
#~ "* systèmes de fichiers compressés\n"

#, fuzzy
#~ msgid ""
#~ "Force changed blocks to disk, update the super block.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Update the access and modification times of each FILE to the current "
#~ "time.\n"
#~ "\n"
#~ "  -a                     change only the access time\n"
#~ "  -c, --no-create        do not create any files\n"
#~ "  -d, --date=STRING      parse STRING and use it instead of current time\n"
#~ "  -f                     (ignored)\n"
#~ "  -m                     change only the modification time\n"
#~ "  -r, --reference=FILE   use this file's times instead of current time\n"
#~ "  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current "
#~ "time\n"
#~ "  --time=WORD            set time given by WORD: access atime use (same "
#~ "as -a)\n"
#~ "                           modify mtime (same as -m)\n"
#~ "      --help             display this help and exit\n"
#~ "      --version          output version information and exit\n"
#~ "\n"
#~ "Note that the three time-date formats recognized for the -d and -t "
#~ "options\n"
#~ "and for the obsolescent argument are all different.\n"
#~ msgstr ""
#~ "Mettre à jour les dates d'accès et de modification de chaque FICHIER\n"
#~ "selon la date courante.\n"
#~ "\n"
#~ "  -a                   modifier seulement la date d'accès\n"
#~ "  -c, --no-create      ne créer aucun fichier\n"
#~ "  -d, --date=CHAÎNE    analyser la CHAÎNE et l'utiliser au lieu\n"
#~ "                       de la date courante\n"
#~ "  -f                   (ignorée)\n"
#~ "  -m                   modifier seulement la date de modification\n"
#~ "  -r, --file=FICHIER   utiliser la date du FICHIER comme référence\n"
#~ "                       au lieu de la date courante\n"
#~ "  -t DATE              utiliser la DATE selon le format:\n"
#~ "                        [[CC]AA]MMJJhhmm[.ss]\n"
#~ "                       comme tampon date-heure au lieu de la date "
#~ "courante\n"
#~ "      --time=CODE      -a pour 'atime', -m pour 'mtime', -m pour "
#~ "modifié,\n"
#~ "                       -a pour utilisé\n"
#~ "      --help           afficher l'aide-mémoire\n"
#~ "      --version        afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Noter que les 3 formats du tampon date-heure sont reconnus pour les\n"
#~ "options -d et -t et les arguments désuets sont tous différents.\n"

#~ msgid "Copyright (C) 2001 Free Software Foundation, Inc."
#~ msgstr "Copyright © 2001 Free Software Foundation, Inc."

#~ msgid ""
#~ "Warning: the meaning of `-P' will change in the future to conform to "
#~ "POSIX.\n"
#~ "Use `--parents' for the old meaning, and `--no-dereference' for the new "
#~ "one."
#~ msgstr ""
#~ "AVERTISSEMENT: le sens de `-P' changera pour se conformer à POSIX.\n"
#~ "Utiliser `--parents' pour le vieux sens et `--no-dereference' pour le "
#~ "nouveau."

#, fuzzy
#~ msgid "%a %b %d %H:%M:%S %Y"
#~ msgstr "%b %e %H:%M %Y"

#~ msgid ""
#~ "when creating character special files, major and minor device\n"
#~ "numbers must be specified"
#~ msgstr ""
#~ "Lors de la création d'un fichier de type caractère spécial, les numéros\n"
#~ "majeur et mineur de périphériques doivent être spécifiées."

#~ msgid "virtual memory exhausted"
#~ msgstr "Mémoire virtuelle épuisée"

#~ msgid "Memory exhausted"
#~ msgstr "Mémoire épuisée"

#~ msgid "group of %s changed to %s\n"
#~ msgstr "Le groupe d'appartenance de %s a été attribué à %s.\n"

#~ msgid "you are not a member of group `%s'"
#~ msgstr "Vous n'êtes pas membre du groupe `%s'."

#~ msgid "owner of %s changed to "
#~ msgstr "L'appartenance de %s a été attribué à "

#, fuzzy
#~ msgid "cannot remove old link to `%s'"
#~ msgstr "Ne peut exécuter « ioctl » sur « %s »"

#, fuzzy
#~ msgid "cannot make fifo `%s'"
#~ msgstr "Ne peut exécuter « ioctl » sur « %s »"

#~ msgid ""
#~ "Delete a file securely, first overwriting it to hide its contents.\n"
#~ "\n"
#~ "  -f, --force    change permissions to allow writing if necessary\n"
#~ "  -n, --iterations=N  Overwrite N times instead of the default (%d)\n"
#~ "  -s, --size=N   shred this many bytes (suffixes like k, M, G accepted)\n"
#~ "  -u, --remove   truncate and remove file after overwriting\n"
#~ "  -v, --verbose  show progress\n"
#~ "  -x, --exact    do not round file sizes up to the next full block\n"
#~ "  -z, --zero     add a final overwrite with zeros to hide shredding\n"
#~ "  -              shred standard output\n"
#~ "      --help     display this help and exit\n"
#~ "      --version  print version information and exit\n"
#~ "\n"
#~ "FIXME maybe add more discussion here?"
#~ msgstr ""
#~ "Détruire un fichier de façon sécuritaire, en l'écrasant pour cacher son "
#~ "contenu.\n"
#~ "\n"
#~ "  -f, --force         modifier les permissions pour permettre\n"
#~ "                      l'écriture si nécessaire\n"
#~ "  -n, --iterations=N  écraser N fois au lieu du nombre par défaut %d\n"
#~ "  -s, --size=N        déchiqueter N octets (les suffixes k, M, G sont "
#~ "acceptés)\n"
#~ "  -u, --remove        tronquer et détruire le fichier après l'avoir "
#~ "écraser\n"
#~ "  -v, --verbose       afficher un indicateur de progrès\n"
#~ "  -x, --exact         ne pas arrondir la taille des fichiers\n"
#~ "                      jusqu'au prochain bloc complet\n"
#~ "  -z, --zero          ajouter une écriture finale avec des zéros\n"
#~ "                      pour camoufler le déchiquetage du fichier\n"
#~ "  -                   déchiqueter l'entrée standard \n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "FIXME d'autres détails doivent être fournis par le mainteneur?"

#~ msgid "--version-control"
#~ msgstr "--version-control"

#~ msgid "create %s %s to %s"
#~ msgstr "Création de %s %s vers %s"

#~ msgid "hard link"
#~ msgstr "lien direct"

#~ msgid "link"
#~ msgstr "lien"

#, fuzzy
#~ msgid "current directory"
#~ msgstr "répertoire"

#, fuzzy
#~ msgid "starting directory"
#~ msgstr "répertoire"

#~ msgid "%s -> %s (backup)\n"
#~ msgstr "%s -> %s (archivage)\n"

#, fuzzy
#~ msgid ""
#~ "Usage: %s [OPTION]... TARGET [LINK_NAME]\n"
#~ "  or:  %s [OPTION]... TARGET... DIRECTORY\n"
#~ msgstr ""
#~ "Usage: %s [OPTION]... [ENTRÉE]...   (sans l'option -G)\n"
#~ "  ou:  %s -G [OPTION]... [ÉNTRÉE [SORTIE]]\n"

#, fuzzy
#~ msgid "Usage: %s [OPTION]... EXISTING_DIR NEW_DIR\n"
#~ msgstr "Usage: %s [OPTION]... ENSEMBLE1 [ENSEMBLE2]\n"

#, fuzzy
#~ msgid "cannot rename `.' or `..'"
#~ msgstr "Ne peut fixer le nom du poste (hostname) à « %s »"

#, fuzzy
#~ msgid "%s is closed"
#~ msgstr "L'entrée standard est fermée."

#, fuzzy
#~ msgid "Error seeking `%s'"
#~ msgstr "Erreur lors de la lecture %s"

#~ msgid "(Did you remember to open stdin read/write with \"<>file\"?)\n"
#~ msgstr ""
#~ "Rappelez-vous d'ouvrir l'entrée standard comme suit: \"<>FICHIER\"\n"

#~ msgid "%s: pass %lu/%lu (%s)...%lu/%lu K"
#~ msgstr "%s: pass %lu/%lu (%s)...%lu/%lu K"

#, fuzzy
#~ msgid "Error syncing `%s'"
#~ msgstr "Erreur lors de la lecture %s"

#, fuzzy
#~ msgid "Can't fstat file `%s'"
#~ msgstr "Création du fichier « %s »\n"

#~ msgid "`%s' is not a regular file: use -d to enable operations on devices"
#~ msgstr ""
#~ "`%s' n'est pas un fichier régulier: \n"
#~ "utiliser -d pour permettre les opérations sur périphériques"

#~ msgid "unable to allocate storage for %lu passes"
#~ msgstr "incapable d'allouer de l'espace de stockage pour %lu passes"

#, fuzzy
#~ msgid "%s: deleting"
#~ msgstr "%s: fichier trop long"

#, fuzzy
#~ msgid "%s: deleted"
#~ msgstr "%s: fichier tronqué"

#~ msgid "Unable to delete file `%s'"
#~ msgstr "Incapable de détruire le fichier `%s'"

#~ msgid "sparse type"
#~ msgstr "Type dispersé."

#~ msgid "time type"
#~ msgstr "Type de date"

#~ msgid "format type"
#~ msgstr "Type de format"

#~ msgid "colorization criterion"
#~ msgstr "Critère de coloration"

#~ msgid "indicator style"
#~ msgstr "indicateur de style"

#~ msgid "quoting style"
#~ msgstr "indicateur de style de guillemets"

#~ msgid "time selector"
#~ msgstr "Sélecteur de date."

#~ msgid ""
#~ "the option for counting 1MB blocks may not be used\n"
#~ "with the portable output format"
#~ msgstr ""
#~ "L'option pour compter les blocs de 1Mo ne peut être\n"
#~ "utilisée avec l'option de format de sortie portable."

#, fuzzy
#~ msgid "removing non-directory %s\n"
#~ msgstr "AVERTISSEMENT: ne peut changer pour le répertoire %s"

#, fuzzy
#~ msgid "remove directory `%s'%s? "
#~ msgstr "Ne peut créer le répertoire %s"

#~ msgid "%s: replace `%s', overriding mode %04o? "
#~ msgstr "%s: remplacer`%s', en outrepassant le mode %04o? "

#, fuzzy
#~ msgid "Usage: %s [OPTION]... GROUP FILE...\n"
#~ msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#~ msgid "cannot move `%s' across filesystems: Not a regular file"
#~ msgstr ""
#~ "`%s' ne peut être déplacé à travers des sytèmes de fichiers:\n"
#~ "parce qu'il n'est pas un fichier de type régulier."

#~ msgid "%s: remove %s`%s', overriding mode %04o? "
#~ msgstr "%s: détruire %s`%s', en outrepassant le mode %04o? "

#~ msgid "%s: descend directory `%s', overriding mode %04o? "
#~ msgstr "%s: aller dans le répertoire `%s', en outrepassant le mode %04o? "

#~ msgid "%s: remove directory `%s' (might be nonempty)? "
#~ msgstr "%s: détruire le répertoire «%s» (peut ne pas être vide)? "

#~ msgid "days"
#~ msgstr "jours"

#~ msgid "users"
#~ msgstr "usager"

#, fuzzy
#~ msgid ""
#~ "Run COMMAND with root directory set to NEWROOT.\n"
#~ "\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ "If no command is given, run ``${SHELL} -i'' (default: /bin/sh).\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "\n"
#~ "FORMAT controls the output.  The only valid option for the second form\n"
#~ "specifies Coordinated Universal Time.  Interpreted sequences are:\n"
#~ "\n"
#~ "  %%%%   a literal %%\n"
#~ "  %%a   locale's abbreviated weekday name (Sun..Sat)\n"
#~ "  %%A   locale's full weekday name, variable length (Sunday..Saturday)\n"
#~ "  %%b   locale's abbreviated month name (Jan..Dec)\n"
#~ "  %%B   locale's full month name, variable length (January..December)\n"
#~ "  %%c   locale's date and time (Sat Nov 04 12:02:33 EST 1989)\n"
#~ "  %%d   day of month (01..31)\n"
#~ "  %%D   date (mm/dd/yy)\n"
#~ "  %%e   day of month, blank padded ( 1..31)\n"
#~ "  %%h   same as %%b\n"
#~ "  %%H   hour (00..23)\n"
#~ "  %%I   hour (01..12)\n"
#~ "  %%j   day of year (001..366)\n"
#~ "  %%k   hour ( 0..23)\n"
#~ "  %%l   hour ( 1..12)\n"
#~ "  %%m   month (01..12)\n"
#~ "  %%M   minute (00..59)\n"
#~ "  %%n   a newline\n"
#~ "  %%p   locale's AM or PM\n"
#~ "  %%r   time, 12-hour (hh:mm:ss [AP]M)\n"
#~ "  %%s   seconds since `00:00:00 1970-01-01 UTC' (a GNU extension)\n"
#~ "  %%S   second (00..60)\n"
#~ "  %%t   a horizontal tab\n"
#~ "  %%T   time, 24-hour (hh:mm:ss)\n"
#~ "  %%U   week number of year with Sunday as first day of week (00..53)\n"
#~ "  %%V   week number of year with Monday as first day of week (01..53)\n"
#~ "  %%w   day of week (0..6);  0 represents Sunday\n"
#~ "  %%W   week number of year with Monday as first day of week (00..53)\n"
#~ "  %%x   locale's date representation (mm/dd/yy)\n"
#~ "  %%X   locale's time representation (%%H:%%M:%%S)\n"
#~ "  %%y   last two digits of year (00..99)\n"
#~ "  %%Y   year (1970...)\n"
#~ "  %%z   RFC-822 style numeric timezone (-0500) (a nonstandard extension)\n"
#~ "  %%Z   time zone (e.g., EDT), or nothing if no time zone is "
#~ "determinable\n"
#~ "\n"
#~ "By default, date pads numeric fields with zeroes.  GNU date recognizes\n"
#~ "the following modifiers between `%%' and a numeric directive.\n"
#~ "\n"
#~ "  `-' (hyphen) do not pad the field\n"
#~ "  `_' (underscore) pad the field with spaces\n"
#~ msgstr ""
#~ "\n"
#~ "FORMAT contrôle l'affichage.  Seule l'option valide de la seconde forme\n"
#~ "s'applique au système de temps UCT.  Les séquences interprétées sont:\n"
#~ "\n"
#~ "  %%%%   le caractère %%\n"
#~ "  %%a   les noms abrégés localisés des jours de la semaine (Dim..Sam)\n"
#~ "  %%A   les noms complets localisés des jours de la semaine\n"
#~ "        de longueurs variables (Dimanche..Samedi)\n"
#~ "  %%b   les noms abrégés localisés des mois (Jan..Déc)\n"
#~ "  %%B   les noms complets localisés des mois de longueurs variables\n"
#~ "        (Janvier..Décembre)\n"
#~ "  %%c   la date et l'heure localisées (Sam 04 Nov 12:02:33 EDT 1989)\n"
#~ "  %%d   jour du mois (01..31)\n"
#~ "  %%D   date (mm/jj/aa)\n"
#~ "  %%e   jour du mois, précédé d'un blanc ( 1..31)\n"
#~ "  %%h   identique à %%b\n"
#~ "  %%H   heure (00..23)\n"
#~ "  %%I   heure (01..12)\n"
#~ "  %%j   jour numérique de l'année (001..366)\n"
#~ "  %%k   heure ( 0..23)\n"
#~ "  %%l   heure ( 1..12)\n"
#~ "  %%m   mois (01..12)\n"
#~ "  %%M   minute (00..59)\n"
#~ "  %%n   un saut de ligne\n"
#~ "  %%p   localisé AM ou PM\n"
#~ "  %%r   heure, 12-heure (hh:mm:ss [AP]M)\n"
#~ "  %%s   secondes depuis 00:00:00, Jan 1, 1970 (une extension de GNU)\n"
#~ "  %%S   secondes (00..61)\n"
#~ "  %%t   un saut horizontal de tabulation\n"
#~ "  %%T   heure, 24-heure (hh:mm:ss)\n"
#~ "  %%U   numéro de la semaine dans l'année débutant par Dimanche\n"
#~ "        comme premier jour de la semaine (00..53)\n"
#~ "  %%V   numéro de la semaine dans l'année débutant par Lundi\n"
#~ "        comme premier jour de la semaine (01..52)\n"
#~ "  %%w   jour de la semaine (0..6);  0 représente Dimanche\n"
#~ "  %%W   numéro de la samaine dans l'année débutant par Lundi\n"
#~ "        comme premier jour de la semaine (00..53)\n"
#~ "  %%x   représentation localisée de la date (mm/jj/aa)\n"
#~ "  %%X   représentation localisée de l'heure (%%H:%%M:%%S)\n"
#~ "  %%y   les deux derniers chiffres de l'année (00..99)\n"
#~ "  %%Y   année (1970...)\n"
#~ "  %%z   fuseau horaire en format numérique selon le RFC-822 (-0500)\n"
#~ "        (une extension non-standard)\n"
#~ "  %%Z   fuseau horaire (i.e. EDT), nul si aucun fuseau horaire\n"
#~ "        ne peut être déterminé\n"
#~ "\n"
#~ "Par défaut, les champs numériques de date sont complétés par des zéros.\n"
#~ "GNU reconnaît les modificateurs suivants entre « %% » et une directive "
#~ "numérique.\n"
#~ "\n"
#~ "  « - » (tiret) ne pas compléter le champ\n"
#~ "  « _ » (souligné) compléter le champ par des blancs\n"

#~ msgid ""
#~ "Echo the STRING(s) to standard output.\n"
#~ "\n"
#~ "  -n              do not output the trailing newline\n"
#~ "  -e              enable interpretation of the backslash-escaped "
#~ "characters\n"
#~ "                    listed below\n"
#~ "  -E              disable interpretation of those sequences in STRINGs\n"
#~ "      --help      display this help and exit (should be alone)\n"
#~ "      --version   output version information and exit (should be alone)\n"
#~ "\n"
#~ "Without -E, the following sequences are recognized and interpolated:\n"
#~ "\n"
#~ "  \\NNN   the character whose ASCII code is NNN (octal)\n"
#~ "  \\\\     backslash\n"
#~ "  \\a     alert (BEL)\n"
#~ "  \\b     backspace\n"
#~ "  \\c     suppress trailing newline\n"
#~ "  \\f     form feed\n"
#~ "  \\n     new line\n"
#~ "  \\r     carriage return\n"
#~ "  \\t     horizontal tab\n"
#~ "  \\v     vertical tab\n"
#~ msgstr ""
#~ "Faire l'écho de CHAÎNE(S) vers la sortie standard.\n"
#~ "\n"
#~ "  -n             ne pas afficher le saut de ligne de fin\n"
#~ "  -e             (inutilisée)\n"
#~ "  -E             inhiber l'interpolation de certaines séquences de la "
#~ "CHAÎNE\n"
#~ "      --help     afficher l'aide-mémoire\n"
#~ "      --version  afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Sans -E, les séquences suivantes sont reconnues et interpolées:\n"
#~ "\n"
#~ "  \\NNN   le caractère dont le code ASCII est NNN (en octal)\n"
#~ "  \\\\     barre oblique inverse\n"
#~ "  \\a     bip sonore d'alerte\n"
#~ "  \\b     retour arrière\n"
#~ "  \\c     supprimer le saut de ligne de fin\n"
#~ "  \\f     saut de page\n"
#~ "  \\n     saut de ligne\n"
#~ "  \\r     retour de chariot\n"
#~ "  \\t     tabulation horizontale\n"
#~ "  \\v     tabulation verticale\n"

#~ msgid ""
#~ "Print the value of EXPRESSION to standard output.  A blank line below\n"
#~ "separates increasing precedence groups.  EXPRESSION may be:\n"
#~ "\n"
#~ "  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
#~ "\n"
#~ "  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
#~ "\n"
#~ "  ARG1 < ARG2       ARG1 is less than ARG2\n"
#~ "  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
#~ "  ARG1 = ARG2       ARG1 is equal to ARG2\n"
#~ "  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
#~ "  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
#~ "  ARG1 > ARG2       ARG1 is greater than ARG2\n"
#~ "\n"
#~ "  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
#~ "  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
#~ "\n"
#~ "  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
#~ "  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
#~ "  ARG1 %% ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
#~ "\n"
#~ "  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
#~ "\n"
#~ "  match STRING REGEXP        same as STRING : REGEXP\n"
#~ "  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
#~ "  index STRING CHARS         index in STRING where any CHARS is found, or "
#~ "0\n"
#~ "  length STRING              length of STRING\n"
#~ "  quote TOKEN                interpret TOKEN as a string, even if it is "
#~ "a\n"
#~ "                               keyword like `match' or an operator like "
#~ "`/'\n"
#~ "\n"
#~ "  ( EXPRESSION )             value of EXPRESSION\n"
#~ msgstr ""
#~ "Afficher la valeur de l'EXPRESSION vers la sortie standard.  Une ligne "
#~ "blanche\n"
#~ "sépare la précédence croissante des groupes d'expressions.\n"
#~ "L'EXPRESSION peut être:\n"
#~ "\n"
#~ "  PARAM1 | PARAM2       PARAM1 s'il est nul ou 0, autrement PARAM2\n"
#~ "\n"
#~ "  PARAM1 & PARAM2       PARAM1 si aucun des paramètres est nul ou 0,\n"
#~ "                        autrement 0\n"
#~ "\n"
#~ "  PARAM1 < PARAM2       PARAM1 si plus petit que PARAM2\n"
#~ "  PARAM1 <= PARAM2      PARAM1 si plus petit ou égal à PARAM2\n"
#~ "  PARAM1 = PARAM2       PARAM1 si égal à PARAM2\n"
#~ "  PARAM1 != PARAM2      PARAM1 si inégal à PARAM2\n"
#~ "  PARAM1 >= PARAM2      PARAM1 si plus grand ou égal à PARAM2\n"
#~ "  PARAM1 > PARAM2       PARAM1 si plus grand que PARAM2\n"
#~ "\n"
#~ "  PARAM1 + PARAM2       somme arithmétique de PARAM1 et PARAM2\n"
#~ "  PARAM1 - PARAM2       différence arithmétique de PARAM1 et PARAM2\n"
#~ "\n"
#~ "  PARAM1 * PARAM2       produit arithmétique de PARAM1 et PARAM2\n"
#~ "  PARAM1 / PARAM2       quotient arithmétique de PARAM1 divisé par "
#~ "PARAM2\n"
#~ "  PARAM1 %% PARAM2       reste arithmétique PARAM1 divisé par PARAM2\n"
#~ "\n"
#~ "  CHAÎNE: EXPREG   patron d'ancrage de concordance de l'EXPREG dans la "
#~ "CHAÎNE\n"
#~ "\n"
#~ "  match CHAÎNE EXPREG      identique à CHAÎNE: EXPREG\n"
#~ "  substr CHAÎNE POS LONG   sous-chaîne de CHAÎNE débutant à la POSition\n"
#~ "                           (comptée à partir de 1) et ayant une LONGueur\n"
#~ "  index CHAÎNE CAR         valeur de la position du CARactère retrouvé\n"
#~ "                           dans la CHAÎNE, sinon 0\n"
#~ "  length CHAÎNE            longueur de la CHAÎNE\n"
#~ "  quote JETON              interpréter le JETON comme une chaîne, même si "
#~ "c'est\n"
#~ "                           un mot clé comme « match » ou un opérateur "
#~ "comme « / »\n"
#~ "\n"
#~ "  ( EXPRESSION )           valeur de l'EXPRESSION\n"

#~ msgid ""
#~ "\n"
#~ "  -l              do long format output\n"
#~ "  -b              omit the user's home directory and shell in long "
#~ "format\n"
#~ "  -h              omit the user's project file in long format\n"
#~ "  -p              omit the user's plan file in long format\n"
#~ "  -s              do short format output, this is the default\n"
#~ "  -f              omit the line of column headings in short format\n"
#~ "  -w              omit the user's full name in short format\n"
#~ "  -i              omit the user's full name and remote host in short "
#~ "format\n"
#~ "  -q              omit the user's full name, remote host and idle time\n"
#~ "                  in short format\n"
#~ "      --help      display this help and exit\n"
#~ "      --version   output version information and exit\n"
#~ "\n"
#~ "A lightweight `finger' program;  print user information.\n"
#~ "The utmp file will be %s.\n"
#~ msgstr ""
#~ "\n"
#~ "  -l              afficher en format long\n"
#~ "  -b              omettre le répertoire d'attache de l'usager\n"
#~ "                  et son shell en format long\n"
#~ "  -h              omettre le fichier de projet de l'usager en\n"
#~ "                  format long\n"
#~ "  -p              omettre le fichier de plan de l'usager en\n"
#~ "                  format long\n"
#~ "  -s              afficher en format court (par défaut)\n"
#~ "  -f              omettre la ligne de l'en-tête des colonnes\n"
#~ "                  en format court\n"
#~ "  -w              omettre le nom complet de l'usager en format court\n"
#~ "  -i              omettre le nom complet de l'usager et le nom de l'hôte\n"
#~ "                  en format court\n"
#~ "  -q              omettre le nom complet de l'usager, le nom de l'hôte\n"
#~ "                  et le temps d'inactivité en format court\n"
#~ "      --help      afficher l'aide-mémoire\n"
#~ "      --version   afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Une version allégée du programme « finger »; afficher les informations "
#~ "d'un usager.\n"
#~ "Le fichier utmp sera %s.\n"

#~ msgid ""
#~ "Print ARGUMENT(s) according to FORMAT.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ "\n"
#~ "FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
#~ "\n"
#~ "  \\\"      double quote\n"
#~ "  \\0NNN   character with octal value NNN (0 to 3 digits)\n"
#~ "  \\\\      backslash\n"
#~ "  \\a      alert (BEL)\n"
#~ "  \\b      backspace\n"
#~ "  \\c      produce no further output\n"
#~ "  \\f      form feed\n"
#~ "  \\n      new line\n"
#~ "  \\r      carriage return\n"
#~ "  \\t      horizontal tab\n"
#~ "  \\v      vertical tab\n"
#~ "  \\xNNN   byte with hexadecimal value NNN (1 to 3 digits)\n"
#~ "\n"
#~ "  \\uNNNN  character with hexadecimal value NNNN (4 digits)\n"
#~ "  \\UNNNNNNNN  character with hexadecimal value NNNNNNNN (8 digits)\n"
#~ "  %%%%      a single %%\n"
#~ "  %%b      ARGUMENT as a string with `\\' escapes interpreted\n"
#~ "\n"
#~ "and all C format specifications ending with one of diouxXfeEgGcs, with\n"
#~ "ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
#~ msgstr ""
#~ "Afficher PARAMÈTRE(s) selon le FORMAT.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Le FORMAT contrôle la sortie comme la fonction printf() en C.\n"
#~ "Les séquences interprétées sont:\n"
#~ "\n"
#~ "  \\\"      guillemets\n"
#~ "  \\0NNN   caractère ayant la valeur octale NNN (0 à 3 chiffres)\n"
#~ "  \\\\      barre oblique inverse\n"
#~ "  \\a      bip sonore d'alerte\n"
#~ "  \\b      retour arrière\n"
#~ "  \\c      ne pas afficher d'autres informations sur la sortie\n"
#~ "  \\f      saut de page\n"
#~ "  \\n      saut de ligne\n"
#~ "  \\r      retour de chariot\n"
#~ "  \\t      tabulation horizontale\n"
#~ "  \\v      tabulation verticale\n"
#~ "  \\xNNN   caractère ayant la valeur hexadécimale NNN (1 à 3 chiffres)\n"
#~ "  \\UNNNNNNNN  caractère ayant la valeur hexadécimal NNNNNNNN (8 "
#~ "chiffres)\n"
#~ "  %%%%      le caractère %%\n"
#~ "  %%b      PARAMÈTRES comme une chaîne avec « \\ » d'échappement "
#~ "interprétés\n"
#~ "\n"
#~ "ainsi que toutes les spécifications de format en C se terminant par une "
#~ "des\n"
#~ "options suivantes diouxXfeEgGcs, avec un PARAMÈTRE\n"
#~ "converti au premier type approprié.\n"
#~ "Les largeurs variables de champ sont supportées.\n"

#, fuzzy
#~ msgid ""
#~ "Print the full filename of the current working directory.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "\n"
#~ "Special characters:\n"
#~ "* dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
#~ "  eof CHAR      CHAR will send an end of file (terminate the input)\n"
#~ "  eol CHAR      CHAR will end the line\n"
#~ "* eol2 CHAR     alternate CHAR for ending the line\n"
#~ "  erase CHAR    CHAR will erase the last character typed\n"
#~ "  intr CHAR     CHAR will send an interrupt signal\n"
#~ "  kill CHAR     CHAR will erase the current line\n"
#~ "* lnext CHAR    CHAR will enter the next character quoted\n"
#~ "  quit CHAR     CHAR will send a quit signal\n"
#~ "* rprnt CHAR    CHAR will redraw the current line\n"
#~ "  start CHAR    CHAR will restart the output after stopping it\n"
#~ "  stop CHAR     CHAR will stop the output\n"
#~ "  susp CHAR     CHAR will send a terminal stop signal\n"
#~ "* swtch CHAR    CHAR will switch to a different shell layer\n"
#~ "* werase CHAR   CHAR will erase the last word typed\n"
#~ msgstr ""
#~ "\n"
#~ "Caractères spéciaux:\n"
#~ "* dsusp CAR     CAR émettra un signal d'arrêt de terminal une\n"
#~ "                    fois le tampon d'entrée vidé\n"
#~ "  eof CAR       CAR transmettra une fin de fichier\n"
#~ "                    (pour stopper l'ingestion à l'entrée)\n"
#~ "  eol CAR       CAR terminera la ligne\n"
#~ "* eol2 CAR      CAR servira de caractère alternatif de fin de ligne\n"
#~ "  erase CAR     CAR servira de touche d'effacement sur le dernier\n"
#~ "                    caractère entrée\n"
#~ "  intr CAR      CAR transmettra un signal d'interruption\n"
#~ "  kill CAR      CAR effacera la ligne courante\n"
#~ "* lnext CAR     CAR entrera le prochain caractère entre guillemets\n"
#~ "  quit CAR      CAR transmettra un signal de fin\n"
#~ "* rprnt CAR     CAR servira à ré-afficher la dernière ligne\n"
#~ "  start CAR     CAR permettra la poursuite de l'affichage de\n"
#~ "                    sortie après avoir été stoppé\n"
#~ "  stop CAR      CAR stoppera l'affichage de sortie\n"
#~ "  susp CAR      CAR transmettra un signal d'arrêt de terminal\n"
#~ "* swtch CAR     CAR permettra de passer à une couche différente de shell\n"
#~ "* werase CAR    CAR effacera le dernier mot tapé\n"

#~ msgid ""
#~ "\n"
#~ "Special settings:\n"
#~ "  N             set the input and output speeds to N bauds\n"
#~ "* cols N        tell the kernel that the terminal has N columns\n"
#~ "* columns N     same as cols N\n"
#~ "  ispeed N      set the input speed to N\n"
#~ "* line N        use line discipline N\n"
#~ "  min N         with -icanon, set N characters minimum for a completed "
#~ "read\n"
#~ "  ospeed N      set the output speed to N\n"
#~ "* rows N        tell the kernel that the terminal has N rows\n"
#~ "* size          print the number of rows and columns according to the "
#~ "kernel\n"
#~ "  speed         print the terminal speed\n"
#~ "  time N        with -icanon, set read timeout of N tenths of a second\n"
#~ msgstr ""
#~ "\n"
#~ "Configurations spéciales:\n"
#~ "  N             initialiser les vitesses d'entrée et de sortie à N bauds\n"
#~ "* cols N        indiquer au kernel que le terminal a N colonnes\n"
#~ "* columns N     identique à cols N\n"
#~ "  ispeed N      initialiser la vitesse d'entrée à N\n"
#~ "* line N        utiliser le conditionnement propre de la ligne N\n"
#~ "  min N         avec -icanon, initialiser à N le nombre de caractères\n"
#~ "                nécessaires pour obtenir une lecture complète\n"
#~ "  ospeed N      initialiser la vitesse de sortie à N\n"
#~ "* rows N        indiquer au kernel que le terminal a N lignes\n"
#~ "* size          afficher le nombre de lignes et de colonnes\n"
#~ "                selon les paramètres du kernel\n"
#~ "  speed         afficher la vitesse du terminal\n"
#~ "  time N        avec -icanon, initialiser le délai\n"
#~ "                d'inactivité de lecture à N dizièmes de seconde\n"

#~ msgid ""
#~ "\n"
#~ "Input settings:\n"
#~ "  [-]brkint     breaks cause an interrupt signal\n"
#~ "  [-]icrnl      translate carriage return to newline\n"
#~ "  [-]ignbrk     ignore break characters\n"
#~ "  [-]igncr      ignore carriage return\n"
#~ "  [-]ignpar     ignore characters with parity errors\n"
#~ "* [-]imaxbel    beep and do not flush a full input buffer on a character\n"
#~ "  [-]inlcr      translate newline to carriage return\n"
#~ "  [-]inpck      enable input parity checking\n"
#~ "  [-]istrip     clear high (8th) bit of input characters\n"
#~ "* [-]iuclc      translate uppercase characters to lowercase\n"
#~ "* [-]ixany      let any character restart output, not only start "
#~ "character\n"
#~ "  [-]ixoff      enable sending of start/stop characters\n"
#~ "  [-]ixon       enable XON/XOFF flow control\n"
#~ "  [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
#~ "  [-]tandem     same as [-]ixoff\n"
#~ msgstr ""
#~ "\n"
#~ "Configurations d'entrée:\n"
#~ "  [-]brkint     le « break » provoque un signal d'interruption\n"
#~ "  [-]icrnl      traduire le retour de chariot en saut de ligne\n"
#~ "  [-]ignbrk     ignorer le caractère break\n"
#~ "  [-]igncr      ignorer le retour de chariot\n"
#~ "  [-]ignpar     ignorer les caractères ayant des erreurs de parité\n"
#~ "* [-]imaxbel    indiquer par un bip sonore et ne pas vider le tampon\n"
#~ "                d'entrée lors de l'arrivée d'un caractère\n"
#~ "  [-]inlcr      traduire le saut de ligne en retour de chariot\n"
#~ "  [-]inpck      autoriser la vérification de la parité à l'entrée\n"
#~ "  [-]istrip     mettre à zéro le bit du haut (8e) d'un caractère de "
#~ "l'entrée\n"
#~ "* [-]iuclc      traduire les majuscles en minuscules\n"
#~ "* [-]ixany      permettre à n'importe quel caractère de relancer "
#~ "l'affichage\n"
#~ "                sur la sortie, pas uniquement le caractère de "
#~ "redémarrage\n"
#~ "  [-]ixoff      autoriser l'envoie d'un caractère d'arrêt/départ\n"
#~ "  [-]ixon       autoriser le contrôle de flux XON/XOFF\n"
#~ "  [-]parmrk     indiquer les erreur de parité par une séquence\n"
#~ "                de caractères (255-0)\n"
#~ "  [-]tandem     identique à [-]ixoff\n"

#~ msgid ""
#~ "\n"
#~ "Local settings:\n"
#~ "  [-]crterase   echo erase characters as backspace-space-backspace\n"
#~ "* crtkill       kill all line by obeying the echoprt and echoe settings\n"
#~ "* -crtkill      kill all line by obeying the echoctl and echok settings\n"
#~ "* [-]ctlecho    echo control characters in hat notation (`^c')\n"
#~ "  [-]echo       echo input characters\n"
#~ "* [-]echoctl    same as [-]ctlecho\n"
#~ "  [-]echoe      same as [-]crterase\n"
#~ "  [-]echok      echo a newline after a kill character\n"
#~ "* [-]echoke     same as [-]crtkill\n"
#~ "  [-]echonl     echo newline even if not echoing other characters\n"
#~ "* [-]echoprt    echo erased characters backward, between `\\' and '/'\n"
#~ "  [-]icanon     enable erase, kill, werase, and rprnt special characters\n"
#~ "  [-]iexten     enable non-POSIX special characters\n"
#~ "  [-]isig       enable interrupt, quit, and suspend special characters\n"
#~ "  [-]noflsh     disable flushing after interrupt and quit special "
#~ "characters\n"
#~ "* [-]prterase   same as [-]echoprt\n"
#~ "* [-]tostop     stop background jobs that try to write to the terminal\n"
#~ "* [-]xcase      with icanon, escape with `\\' for uppercase characters\n"
#~ msgstr ""
#~ "\n"
#~ "Configurations locales:\n"
#~ "  [-]crterase   faire l'écho du caractère « erase » selon la séquence\n"
#~ "                retour arrière-espace-retour arrière\n"
#~ "* crtkill       annuler les ligne respectant la configuration\n"
#~ "                « echoprt » et « echoe »\n"
#~ "* -crtkill      annuler les lignes respectant la configuration\n"
#~ "                « echoctl » et « echok »\n"
#~ "* [-]ctlecho    faire l'écho des caractères de contrôle par une notation\n"
#~ "                en chapeau (« ^c »)\n"
#~ "  [-]echo       faire l'écho des caractères à l'entrée\n"
#~ "* [-]echoctl    identique à [-]ctlecho\n"
#~ "  [-]echoe      identique à [-]crterase\n"
#~ "  [-]echok      faire l'écho d'un saut de ligne après un caractère "
#~ "d'annulation\n"
#~ "* [-]echoke     identique à [-]crtkill\n"
#~ "  [-]echonl     faire l'écho d'un saut de ligne même s'il n'y pas\n"
#~ "                d'écho des autres caractères\n"
#~ "* [-]echoprt    faire l'écho des caractères d'effacement par retour "
#~ "arrière,\n"
#~ "                entre « \\ » et « / »\n"
#~ "  [-]icanon     autoriser les caractères spéciaux\n"
#~ "                « erase », « kill », « werase », et « rprnt »\n"
#~ "  [-]iexten     autoriser les caractères spéciaux non-POSIX\n"
#~ "  [-]isig       autoriser les caractères spéciaux\n"
#~ "                « interrupt », « quit », et « suspend »\n"
#~ "  [-]noflsh     inhiber la vidange après réception des caractères\n"
#~ "                « interrupt » et « quit »\n"
#~ "* [-]prterase   identique à [-]echoprt\n"
#~ "* [-]tostop     stopper les tâches d'arrière plan qui essaient d'écrire\n"
#~ "                sur le terminal\n"
#~ "* [-]xcase      avec « icanon », faire l'échappement avec « \\ »\n"
#~ "                pour les majuscules\n"

#~ msgid ""
#~ "\n"
#~ "Combination settings:\n"
#~ "* [-]LCASE      same as [-]lcase\n"
#~ "  cbreak        same as -icanon\n"
#~ "  -cbreak       same as icanon\n"
#~ "  cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
#~ "                icanon, eof and eol characters to their default values\n"
#~ "  -cooked       same as raw\n"
#~ "  crt           same as echoe echoctl echoke\n"
#~ "  dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                kill ^u\n"
#~ "* [-]decctlq    same as [-]ixany\n"
#~ "  ek            erase and kill characters to their default values\n"
#~ "  evenp         same as parenb -parodd cs7\n"
#~ "  -evenp        same as -parenb cs8\n"
#~ "* [-]lcase      same as xcase iuclc olcuc\n"
#~ "  litout        same as -parenb -istrip -opost cs8\n"
#~ "  -litout       same as parenb istrip opost cs7\n"
#~ "  nl            same as -icrnl -onlcr\n"
#~ "  -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
#~ "  oddp          same as parenb parodd cs7\n"
#~ "  -oddp         same as -parenb cs8\n"
#~ "  [-]parity     same as [-]evenp\n"
#~ "  pass8         same as -parenb -istrip cs8\n"
#~ "  -pass8        same as parenb istrip cs7\n"
#~ "  raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
#~ "                -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
#~ "                -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
#~ "  -raw          same as cooked\n"
#~ "  sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
#~ "                -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
#~ "                -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
#~ "                isig icanon iexten echo echoe echok -echonl -noflsh\n"
#~ "                -xcase -tostop -echoprt echoctl echoke, all special\n"
#~ "                characters to their default values.\n"
#~ msgstr ""
#~ "\n"
#~ "Configuration par combinaison:\n"
#~ "* [-]LCASE      identique à [-]lcase\n"
#~ "  cbreak        identique à -icanon\n"
#~ "  -cbreak       identique à icanon\n"
#~ "  cooked        identique à brkint ignpar istrip icrnl ixon opost isig\n"
#~ "                icanon, eof et eol selon leur valeur par défaut\n"
#~ "  -cooked       identique à raw\n"
#~ "  crt           identique à echoe echoctl echoke\n"
#~ "  dec           identique à echoe echoctl echoke -ixany intr ^c erase "
#~ "0177\n"
#~ "                kill ^u\n"
#~ "* [-]decctlq    identique à [-]ixany\n"
#~ "  ek            réinitialiser les caractères erase et kill à leur valeur\n"
#~ "                par défaut\n"
#~ "  evenp         identique à parenb -parodd cs7\n"
#~ "  -evenp        identique à -parenb cs8\n"
#~ "* [-]lcase      identique à xcase iuclc olcuc\n"
#~ "  litout        identique à -parenb -istrip -opost cs8\n"
#~ "  -litout       identique à parenb istrip opost cs7\n"
#~ "  nl            identique à -icrnl -onlcr\n"
#~ "  -nl           identique à icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
#~ "  oddp          identique à parenb parodd cs7\n"
#~ "  -oddp         identique à -parenb cs8\n"
#~ "  [-]parity     identique à [-]evenp\n"
#~ "  pass8         identique à -parenb -istrip cs8\n"
#~ "  -pass8        identique à parenb istrip cs7\n"
#~ "  raw           identique à -ignbrk -brkint -ignpar -parmrk -inpck -"
#~ "istrip\n"
#~ "                -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
#~ "                -imaxbel -opost -isig -icanon -xcase min 1 fois 0\n"
#~ "  -raw          identique à cooked\n"
#~ "  sane          identique à cread -ignbrk brkint -inlcr -igncr icrnl\n"
#~ "                -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
#~ "                -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
#~ "                isig icanon iexten echo echoe echok -echonl -noflsh\n"
#~ "                -xcase -tostop -echoprt echoctl echoke, et tous les "
#~ "caractères\n"
#~ "                spéciaux à leur valeur par défaut.\n"

#, fuzzy
#~ msgid ""
#~ "Exit with the status determined by EXPRESSION.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ "\n"
#~ "EXPRESSION is true or false and sets exit status.  It is one of:\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "\n"
#~ "  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode "
#~ "numbers\n"
#~ "  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
#~ "  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
#~ "\n"
#~ "  -b FILE     FILE exists and is block special\n"
#~ "  -c FILE     FILE exists and is character special\n"
#~ "  -d FILE     FILE exists and is a directory\n"
#~ "  -e FILE     FILE exists\n"
#~ "  -f FILE     FILE exists and is a regular file\n"
#~ "  -g FILE     FILE exists and is set-group-ID\n"
#~ "  -G FILE     FILE exists and is owned by the effective group ID\n"
#~ "  -k FILE     FILE exists and has its sticky bit set\n"
#~ "  -L FILE     FILE exists and is a symbolic link\n"
#~ "  -O FILE     FILE exists and is owned by the effective user ID\n"
#~ "  -p FILE     FILE exists and is a named pipe\n"
#~ "  -r FILE     FILE exists and is readable\n"
#~ "  -s FILE     FILE exists and has a size greater than zero\n"
#~ "  -S FILE     FILE exists and is a socket\n"
#~ "  -t [FD]     file descriptor FD (stdout by default) is opened on a "
#~ "terminal\n"
#~ "  -u FILE     FILE exists and its set-user-ID bit is set\n"
#~ "  -w FILE     FILE exists and is writable\n"
#~ "  -x FILE     FILE exists and is executable\n"
#~ msgstr ""
#~ "\n"
#~ "  FICHIER1 -ef FICHIER2   FICHIER1 et FICHIER2 ont les mêmes numéros\n"
#~ "                          de périphérique et d'inode\n"
#~ "  FICHIER1 -nt FICHIER2   FICHIER1 est plus récent (date de "
#~ "modification)\n"
#~ "                          que FICHIER2\n"
#~ "  FICHIER1 -ot FICHIER2   FICHIER1 est plus vieux que FICHIER2\n"
#~ "\n"
#~ "  -b FICHIER     FICHIER existe et est de type à blocage spécial\n"
#~ "  -c FICHIER     FICHIER existe et est de type caractère spécial\n"
#~ "  -d FICHIER     FICHIER existe et est un répertoire\n"
#~ "  -e FICHIER     FICHIER existe\n"
#~ "  -f FICHIER     FICHIER existe et est de type régulier\n"
#~ "  -g FICHIER     FICHIER existe et le bit « set-group-ID », est "
#~ "initialisé\n"
#~ "  -G FICHIER     FICHIER existe et appartient au groupe effectif ID\n"
#~ "  -k FICHIER     FICHIER existe et le bit « sticky » est initialisé\n"
#~ "  -L FICHIER     FICHIER existe et est un lien symbolique\n"
#~ "  -O FICHIER     FICHIER existe et appartient à l'usager effectif ID\n"
#~ "  -p FICHIER     FICHIER existe et est un relais nommé (named pipe)\n"
#~ "  -r FICHIER     FICHIER existe et est lisible\n"
#~ "  -s FICHIER     FICHIER existe et a une taille non nulle\n"
#~ "  -S FICHIER     FICHIER existe et est de type « socket »\n"
#~ "  -t [DF]        descripteur de fichier DF (sortie standard par défaut)\n"
#~ "                 est ouvert sur le terminal\n"
#~ "  -u FICHIER     FICHIER existe et le bit « set-user-ID », est "
#~ "initialisé\n"
#~ "  -w FICHIER     FICHIER existe et l'écriture y est permise\n"
#~ "  -x FICHIER     FICHIER existe et exécutable\n"

#~ msgid ""
#~ "Print certain system information.  With no OPTION, same as -s.\n"
#~ "\n"
#~ "  -a, --all        print all information\n"
#~ "  -m, --machine    print the machine (hardware) type\n"
#~ "  -n, --nodename   print the machine's network node hostname\n"
#~ "  -r, --release    print the operating system release\n"
#~ "  -s, --sysname    print the operating system name\n"
#~ "  -p, --processor  print the host processor type\n"
#~ "  -v               print the operating system version\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ msgstr ""
#~ "Afficher certaines informations identifiant le système.\n"
#~ "Sans OPTION, identique à -s.\n"
#~ "\n"
#~ "  -a, --all        afficher toutes les informations\n"
#~ "  -m, --machine    afficher le type de configuration matérielle\n"
#~ "  -n, --nodename   afficher le nom du noeud réseau du poste (hostname)\n"
#~ "  -r, --release    afficher la révision de la version du\n"
#~ "                   système d'exploitation\n"
#~ "  -s, --sysname    afficher le nom du système d'exploitation\n"
#~ "  -p, --processor  afficher le type de processeur\n"
#~ "  -v               afficher la version du système d'exploitation\n"
#~ "      --help       afficher l'aide-mémoire\n"
#~ "      --version    afficher le nom et la version du logiciel\n"

#~ msgid "cannot get processor type"
#~ msgstr "Ne peut trouver le type de processeur."

#~ msgid "USER"
#~ msgstr "USAGER"

#~ msgid "MESG "
#~ msgstr "MESG "

#~ msgid "LOGIN-TIME   "
#~ msgstr "SESSION      "

#~ msgid "FROM\n"
#~ msgstr "DE\n"

#~ msgid ""
#~ "\n"
#~ "  -H, --heading     print line of column headings\n"
#~ "  -i, -u, --idle    add user idle time as HOURS:MINUTES, . or old\n"
#~ "  -l, --lookup      attempt to canonicalize hostnames via DNS\n"
#~ "  -m                only hostname and user associated with stdin\n"
#~ "  -q, --count       all login names and number of users logged on\n"
#~ "  -s                (ignored)\n"
#~ "  -T, -w, --mesg    add user's message status as +, - or ?\n"
#~ "      --message     same as -T\n"
#~ "      --writable    same as -T\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "If FILE is not specified, use %s.  %s as FILE is common.\n"
#~ "If ARG1 ARG2 given, -m presumed: `am i' or `mom likes' are usual.\n"
#~ msgstr ""
#~ "\n"
#~ "  -H, --heading     afficher les en-têtes de colonnes\n"
#~ "  -i, -u, --idle    ajouter le temps d'inactivité de l'usager en\n"
#~ "                    selon le format HEURE:MINUTES, . ou « old »\n"
#~ "  -l, --lookup      utiliser la forme canonique des noms des hôtes\n"
#~ "                    via le DNS\n"
#~ "  -m                seulement du poste (hostname) et\n"
#~ "                    de l'usager associé à « stdin »\n"
#~ "  -q, --count       afficher tous les comptes actifs et le nombre "
#~ "d'usagers\n"
#~ "                    présents sur le système\n"
#~ "  -s                (ignorée)\n"
#~ "  -T, -w, --mesg    ajouter le statut du message usager avec +, - ou ?\n"
#~ "      --message     identique à -T\n"
#~ "      --writeable   identique à -T\n"
#~ "      --help        afficher l'aide-mémoire\n"
#~ "      --version     afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Si FICHIER n'est pas spécifié, utiliser %s.  %s comme FICHIER\n"
#~ "est d'usage courant.  Si PARAM1 et PARAM2 sont fournis, -m est assumé:\n"
#~ "« am i » ou « mom likes » sont d'usage courant.\n"

#~ msgid "<undef>"
#~ msgstr "<indéfini>"

#~ msgid "Usage: %s [-v]\n"
#~ msgstr "Usage: %s [-v]\n"

#, fuzzy
#~ msgid "Usage: %s [OPTION]... [VARIABLE]...\n"
#~ msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#, fuzzy
#~ msgid "Usage: %s [OPTION]... NUMBER[SUFFIX]\n"
#~ msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#~ msgid ""
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"

#~ msgid ""
#~ "\n"
#~ "SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
#~ "If -VALUE is used as first OPTION, read -c VALUE when one of\n"
#~ "multipliers bkm follows concatenated, else read -n VALUE.\n"
#~ msgstr ""
#~ "\n"
#~ "N peut être suivi d'un suffixe multiplicateur:\n"
#~ "b pour 512, k pour 1K, m pour 1 Meg.\n"
#~ "Si -VALEUR est utilisé comme première OPTION, lire -c VALEUR lorsqu'un "
#~ "des\n"
#~ "multiples bkm suivent concaténée(s), sinon lire -n VALEUR.\n"

#~ msgid ""
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolete\n"
#~ msgstr ""
#~ "  +POS1 [-POS2]             débuter avec la clé de position POS1, et "
#~ "terminer\n"
#~ "                            avant POS2 (origine à 0)\n"
#~ "                            AVERTISSEMENT: cette option est obsolète\n"

#~ msgid ""
#~ "  -b, --bytes=SIZE        put SIZE bytes per output file\n"
#~ "  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output "
#~ "file\n"
#~ "  -l, --lines=NUMBER      put NUMBER lines per output file\n"
#~ "  -NUMBER                 same as -l NUMBER\n"
#~ "      --verbose           print a diagnostic to standard error just\n"
#~ "                            before each output file is opened\n"
#~ msgstr ""
#~ "  -b, --bytes=N           écrire N octets par fichier de sortie\n"
#~ "  -C, --line-bytes=N      écrire au plus N octets par ligne\n"
#~ "                          par fichier de sortie\n"
#~ "  -l, --lines=N           écrire N lignes par fichier de sortie\n"
#~ "  -NOMBRE                 identique à -l NOMBRE\n"
#~ "      --verbose           produire un diagnostic sur stderr\n"

#~ msgid ""
#~ "A first OPTION of -VALUE\n"
#~ "is treated like -n VALUE unless VALUE has one of the [bkm] suffix\n"
#~ "multipliers, in which case it is treated like -c VALUE.\n"
#~ msgstr ""
#~ "Une première OPTION de -VALEUR\n"
#~ "est traitée comme -n VALEUR à moins que VALEUR soit suivie d'un suffixe\n"
#~ "multiplicatif [bkm], laquelle dans ce cas est traitée comme -c VALEUR.\n"

#~ msgid ""
#~ "A first option of +VALUE is treated like -+VALUE, but this usage is "
#~ "obsolete\n"
#~ "and support for it will be withdrawn.\n"
#~ "\n"
#~ msgstr ""
#~ "Une première option de +VALEUR est traitée comme -+VALEUR, mais cet usage "
#~ "obsolète\n"
#~ "et son support sera abandonné.\n"
#~ "\n"

#~ msgid "warning: `tail %s' is obsolete; use -n or -c instead"
#~ msgstr "AVERTISSEMENT: `tail %s' est obsolète; utiliser -n ou -c à la place"

#~ msgid "  +N                    same as -s N (obsolete; will be withdrawn)\n"
#~ msgstr ""
#~ "  +N                    identique à -s N (obsolète; sera abandonné)\n"

#~ msgid "\n"
#~ msgstr "\n"

#~ msgid ""
#~ "sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
#~ "for sizeof(double) or L for sizeof(long double).\n"
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
#~ msgstr ""
#~ "sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float), "
#~ "D\n"
#~ "pour sizeof(double) ou L pour sizeof(long double).\n"
#~ "\n"
#~ "BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour "
#~ "aucun.\n"
#~ "OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un "
#~ "multiple de 512\n"

#~ msgid ""
#~ "with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix "
#~ "to\n"
#~ "any type adds a display of printable characters to the end of each line\n"
#~ "of output.  -s without a number implies 3.  -w without a number implies "
#~ "32.\n"
#~ "By default, od uses -A o -t d2 -w 16.\n"
#~ msgstr ""
#~ "avec le suffixe b, de 1024 avec k et de 1048576 avec m. L'ajout du "
#~ "suffixe z à\n"
#~ "n'imporete quel type ajoute l'affichage de caractères imprimables à la "
#~ "fin de chaque ligne\n"
#~ "de sortie. -s non suivi d un nombre implique 3,  32 pour -w.\n"
#~ "Par défaut, od utilise -A o -t d2 -w 16.\n"

#~ msgid ""
#~ "Convert tabs in each FILE to spaces, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -i, --initial       do not convert TABs after non whitespace\n"
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
#~ msgstr ""
#~ "Convertir les tabulations de chaque FICHIER par des blancs d'espacement,\n"
#~ "en écrivant sur la sortie standard.\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -i, --initial       ne pas convertir les tabulations après des non "
#~ "blancs\n"
#~ "  -t, --tabs=N        utiliser N caractères de tabulations, et non 8\n"

#~ msgid ""
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
#~ "                      de tabulation\n"
#~ "                      séparées par des virgules\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#~ msgid ""
#~ "Wrap input lines in each FILE (standard input by default), writing to\n"
#~ "standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --bytes         count bytes rather than columns\n"
#~ "  -s, --spaces        break at spaces\n"
#~ "  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Limiter la longueur de chaque ligne de chaque FICHIER (entrée standard "
#~ "par\n"
#~ "défaut) et forcer le bouclage en écrivant sur la sortie standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -b, --bytes         compter les octets au lieu des colonnes\n"
#~ "  -s, --spaces        briser la ligne sur des blancs\n"
#~ "  -w, --width=N       utiliser N colonnes au lieu de 80\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ msgstr ""
#~ "  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
#~ "                                  sur chaque page logique\n"
#~ "  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
#~ "                                  numéroter les lignes\n"
#~ "      --help                      afficher l'aide-mémoire\n"
#~ "      --version                   afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
#~ "CC se compose de deux caractères délimiteurs pour séparer les pages "
#~ "logiques\n"
#~ "un deuxième caractère manquant implique que:\n"
#~ "taper \\\\ pour  \\.  STYLE est une des options parmi:\n"

#~ msgid ""
#~ "Write lines consisting of the sequentially corresponding lines from\n"
#~ "each FILE, separated by TABs, to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
#~ "  -s, --serial            paste one file at a time instead of in "
#~ "parallel\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Coller séquentiellement les lignes correspondantes de chaque\n"
#~ "FICHIER, séparé par des tabulations, vers la sortie standard.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -d, --delimiters=LISTE  utiliser les caractères de la LISTE au lieu\n"
#~ "                          de tabulations\n"
#~ "  -s, --serial            copier un fichier à la fois au lieu de\n"
#~ "                          le faire en parallèle\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "  -NUMBER                 same as -l NUMBER\n"
#~ "      --verbose           print a diagnostic to standard error just\n"
#~ "                            before each output file is opened\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
#~ msgstr ""
#~ "  -NOMBRE                 identique à -l NOMBRE\n"
#~ "      --verbose           produire un diagnostic sur stderr\n"
#~ "                          avant que chaque fichier de sortie ne soit "
#~ "ouvert \n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "La TAILLE peut être suivie d'un suffixe multiplicateur:\n"
#~ "b pour 512, k pour 1K, m pour 1 Meg.\n"

#~ msgid ""
#~ "Write each FILE to standard output, last line first.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --before             attach the separator before instead of after\n"
#~ msgstr ""
#~ "Écrire chaque FICHIER sur la sortie standard, la dernière ligne en "
#~ "premier.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -b, --before           placer le séparateur avant plutôt qu'après\n"

#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                           inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                           inaccessible later -- useful only with -f\n"
#~ msgstr ""
#~ "Imprimer les dernières %d lignes de chaque FICHIER sur la sortie "
#~ "standard.\n"
#~ "Avec plus d'un FICHIER, précéder chacun par une en-tête contenant le nom "
#~ "du\n"
#~ "fichier. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "\n"
#~ "      --retry              continuer de tenter d'ouvrir le fichier même "
#~ "s'il\n"
#~ "                           est inaccessible lorsque tail démarre ou s'il "
#~ "devient\n"
#~ "                           inaccessible plus tard -- utile seulement avec "
#~ "-f\n"

#~ msgid ""
#~ "Convert spaces in each FILE to tabs, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -a, --all           convert all whitespace, instead of initial "
#~ "whitespace\n"
#~ msgstr ""
#~ "Convertir les blancs d'espacement de chaque FICHIER par des tabulations,\n"
#~ "lors de l'écriture sur la sortie standard.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -a, --all           convertir tous les espaces blancs,\n"
#~ "                      au lieu du blanc d'espacement initial\n"

#~ msgid ""
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=N        utiliser N caractères de tabulation au lieu de 8\n"
#~ "  -t, --tabs=LISTE    utiliser la LISTE séparée de virgules comme "
#~ "positions\n"
#~ "                      explicite des tabulations\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -c, --count           prefix lines by the number of occurrences\n"
#~ "  -d, --repeated        only print duplicate lines\n"
#~ msgstr ""
#~ "Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
#~ "(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
#~ "(ou vers la sortie standard).\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -c, --count           préfixer les lignes par le nombre d'occurences\n"
#~ "  -d, --repeated        afficher seulement les lignes ayant des "
#~ "duplicatats\n"

#~ msgid ""
#~ "Output pieces of FILE separated by PATTERN(s) to files `xx01', "
#~ "`xx02', ...,\n"
#~ "and output byte counts of each piece to standard output.\n"
#~ "\n"
#~ "  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
#~ "  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
#~ "  -k, --keep-files           do not remove output files on errors\n"
#~ "  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
#~ "  -s, --quiet, --silent      do not print counts of output file sizes\n"
#~ "  -z, --elide-empty-files    remove empty output files\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ "\n"
#~ "Read standard input if FILE is -.  Each PATTERN may be:\n"
#~ "\n"
#~ "  INTEGER            copy up to but not including specified line number\n"
#~ "  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
#~ "  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
#~ "  {INTEGER}          repeat the previous pattern specified number of "
#~ "times\n"
#~ "  {*}                repeat the previous pattern as many times as "
#~ "possible\n"
#~ "\n"
#~ "A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
#~ msgstr ""
#~ "Afficher les segments d'un FICHIER séparées par PATRON(s) vers\n"
#~ "les fichiers `xx01', `xx02', ..., ainsi que le nombre\n"
#~ "d'octets de chaque segment vers la sortie standard.\n"
#~ "\n"
#~ "  -b, --suffix-format=FORMAT utiliser sprintf FORMAT au lieu de %%d\n"
#~ "  -f, --prefix=PRÉFIXE       utiliser le PRÉFIXE au lieu de `xx'\n"
#~ "  -k, --keep-files           ne pas détruire les fichiers \n"
#~ "                             lorsqu'il y erreur\n"
#~ "  -n, --digits=NOMBRE        utiliser NOMBRE de chiffres au lieu de 2\n"
#~ "  -s, --quiet, --silent      ne pas afficher la taille des fichiers\n"
#~ "                             de sortie\n"
#~ "  -z, --elide-empty-files    détruire les fichiers de sortie vides\n"
#~ "      --help                 afficher l'aide-mémoire\n"
#~ "      --version              afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Lire de l'entrée standard si le FICHIER est -.  Chaque PATRON peut être:\n"
#~ "\n"
#~ "  ENTIER             copier jusqu'à mais sans inclure le nombre "
#~ "spécifiée\n"
#~ "                     de lignes\n"
#~ "  /REGEXP/[SAUT]     copier jusqu'à la détection d'une ligne identique\n"
#~ "                     mais sans l'inclure\n"
#~ "  %%REGEXP%%[SAUT]     escamoter jusqu'à, mais sans inclure une\n"
#~ "                     ligne identique\n"
#~ "  {ENTIER}           répéter le patron précédent un nombre de fois\n"
#~ "  {*}                répéter le patron précédent le plus souvent "
#~ "possible\n"
#~ "\n"
#~ "Une ligne de SAUT a besoin d'un `+' ou `-' suivi d'un entier positif.\n"

#~ msgid ""
#~ "Print selected parts of lines from each FILE to standard output.\n"
#~ "\n"
#~ "  -b, --bytes=LIST        output only these bytes\n"
#~ "  -c, --characters=LIST   output only these characters\n"
#~ "  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
#~ "  -f, --fields=LIST       output only these fields;  also print any line\n"
#~ "                            that contains no delimiter character, unless\n"
#~ "                            the -s option is specified\n"
#~ "  -n                      (ignored)\n"
#~ "  -s, --only-delimited    do not print lines not containing delimiters\n"
#~ "      --output-delimiter=STRING  use STRING as the output delimiter\n"
#~ "                            the default is to use the input delimiter\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
#~ "range, or many ranges separated by commas.  Each range is one of:\n"
#~ "\n"
#~ "  N     N'th byte, character or field, counted from 1\n"
#~ "  N-    from N'th byte, character or field, to end of line\n"
#~ "  N-M   from N'th to M'th (included) byte, character or field\n"
#~ "  -M    from first to M'th (included) byte, character or field\n"
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ msgstr ""
#~ "Afficher des parties de lignes de chaque FICHIER vers la sortie "
#~ "standard.\n"
#~ "\n"
#~ "  -b, --bytes=LISTE       afficher seulement la LISTE des octets\n"
#~ "  -c, --characters=LISTE  afficher seulement la LISTE des caractères\n"
#~ "  -d, --delimiter=DÉLIM   utiliser le DÉLIMiteur au lieu d'une "
#~ "tabulation\n"
#~ "                          comme délimiteur de champs\n"
#~ "  -f, --fields=LISTE      afficher seulement la LISTE des champs\n"
#~ "  -n                      (ignoré)\n"
#~ "  -s, --only-delimited    ne pas afficher les lignes ne\n"
#~ "                          contenant pas de délimiteurs\n"
#~ "      --output-delimiter=CHAÎNE\n"
#~ "                          utiliser la CHAÎNE comme délimiteur de sortie\n"
#~ "                          par défaut le délimiteur de l'entrée est "
#~ "utilisée\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Utiliser une seule des options -b, -c ou -f.  Chaque LISTE se compose "
#~ "d'une\n"
#~ "intervalle, ou de plusieurs séparées par des virgules.  Chaque "
#~ "intervalle\n"
#~ "se compose de:\n"
#~ "\n"
#~ "  N     Nième octet, caractère ou champ, compté à partir de 1\n"
#~ "  N-    du Nième octet, caractère ou champ, jusqu'à la fin de la ligne\n"
#~ "  N-M   du Nième au Mième (inclus) octet, caractère ou champ\n"
#~ "  -M    du premier au Mième (inclus) octet, caractère ou champ\n"
#~ "\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#~ msgid ""
#~ "For each pair of input lines with identical join fields, write a line to\n"
#~ "standard output.  The default join field is the first, delimited\n"
#~ "by whitespace.  When FILE1 or FILE2 (not both) is -, read standard "
#~ "input.\n"
#~ "\n"
#~ "  -a SIDE           print unpairable lines coming from file SIDE\n"
#~ "  -e EMPTY          replace missing input fields with EMPTY\n"
#~ "  -i, --ignore-case ignore differences in case when comparing fields\n"
#~ "  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
#~ "  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
#~ "  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
#~ "  -o FORMAT         obey FORMAT while constructing output line\n"
#~ "  -t CHAR           use CHAR as input and output field separator\n"
#~ "  -v SIDE           like -a SIDE, but suppress joined output lines\n"
#~ "  -1 FIELD          join on this FIELD of file 1\n"
#~ "  -2 FIELD          join on this FIELD of file 2\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
#~ "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
#~ "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
#~ "each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
#~ "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
#~ "separated by CHAR.\n"
#~ msgstr ""
#~ "Pour chaque paire de lignes en entrée ayant un champ de fusion "
#~ "identique,\n"
#~ "écrire une ligne sur la sortie standard.\n"
#~ "Le champ de fusion est le premier, délimité par un blanc.\n"
#~ "Si FICHIER1 ou FICHIER2 (pas les 2) est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -a COTÉ           afficher les lignes non repérables venant du \n"
#~ "                    fichier COTÉ\n"
#~ "  -e VIDE           remplacer les champs d'entrée manquants par VIDE\n"
#~ "  -i, --ignore-case ignorer la casse des caractères lors de la\n"
#~ "                    comparaison des champs\n"
#~ "  -j CHAMP          option désuète équivalente à `-1 CHAMP -2 CHAMP'\n"
#~ "  -j1 CHAMP         option désuète équivalente à `-1 CHAMP'\n"
#~ "  -j2 CHAMP         option désuète équivalente à `-2 CHAMP'\n"
#~ "  -o FORMAT         respecter le FORMAT lors de la construction\n"
#~ "                    de sortie\n"
#~ "  -t CAR            utiliser CAR comme délimiteur de champs à l'entrée\n"
#~ "                    et à la sortie\n"
#~ "  -v COTÉ           comme -a COTÉ, mais supprimer les lignes\n"
#~ "                    de sortie fusionnées\n"
#~ "  -1 CHAMP          fusionner sur le champs CHAMP du fichier 1\n"
#~ "  -2 CHAMP          fusionner sur le champs CHAMP du fichier 2\n"
#~ "     --help         afficher l'aide-mémoire\n"
#~ "     --version      afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "À moins que -t CAR ne soit donné, les blancs de tête séparant\n"
#~ "les champs sont ignorés sinon les champs sont séparés par CAR.\n"
#~ "Chaque CHAMP est un champ compté numériquement à partir de 1.\n"
#~ "FORMAT est une spécification contenant une ou plusieurs virgules ou "
#~ "blancs\n"
#~ "chacune étant `COTÉ.CHAMP' ou `0'.  Par défaut FORMAT affiche des\n"
#~ "champs fusionnés,\n"
#~ "les champs restants de FICHIER1 ou FICHIER2 sont tous séparés par CAR.\n"

#~ msgid ""
#~ "Usage: %s [OPTION] [FILE]...\n"
#~ "  or:  %s [OPTION] --check [FILE]\n"
#~ "Print or check %s (%d-bit) checksums.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "  -b, --binary            read files in binary mode (default on DOS/"
#~ "Windows)\n"
#~ "  -c, --check             check %s sums against given list\n"
#~ "  -t, --text              read files in text mode (default)\n"
#~ "\n"
#~ "The following two options are useful only when verifying checksums:\n"
#~ "      --status            don't output anything, status code shows "
#~ "success\n"
#~ "  -w, --warn              warn about improperly formated checksum lines\n"
#~ "\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "The sums are computed as described in %s.  When checking, the input\n"
#~ "should be a former output of this program.  The default mode is to print\n"
#~ "a line with checksum, a character indicating type (`*' for binary, ` ' "
#~ "for\n"
#~ "text), and name for each FILE.\n"
#~ msgstr ""
#~ "Usage: %s [OPTION] [FICHIER]...\n"
#~ "  ou:  %s [OPTION] --check [FICHIER]\n"
#~ "Afficher ou vérifier les sommes de contrôle %s (%d-bits).\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -b, --binary            lire les fichiers en mode binaire \n"
#~ "                          (par défaut sous DOS/WIndows)\n"
#~ "  -c, --check             vérifier les sommes %s par rapport à la liste\n"
#~ "  -t, --text              lire les fichiers en mode texte (par défaut)\n"
#~ "\n"
#~ "Les deux options suivantes sont utiles seulement lors de la vérification\n"
#~ "des sommes de contrôle:\n"
#~ "      --status            ne rien afficher, sauf le constat\n"
#~ "                          de fin d'exécution\n"
#~ "  -w, --warn              avertir si les lignes de contrôle MD5\n"
#~ "                          sont mal formatées\n"
#~ "\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Les sommes sont calculées selon la description de %s.  Lors de la "
#~ "vérification,\n"
#~ "l'entrée devrait être formellement une sortie de ce programme.  Le mode "
#~ "par défaut\n"
#~ "est d'afficher la ligne avec la somme de contrôle, un caractère "
#~ "indiquant\n"
#~ "le type (`*' pour binaire, ` ' pour texte) et un nom pour chaque "
#~ "FICHIER.\n"

#~ msgid ""
#~ "Write each FILE to standard output, with line numbers added.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
#~ "  -d, --section-delimiter=CC      use CC for separating logical pages\n"
#~ "  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
#~ "  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
#~ "  -i, --page-increment=NUMBER     line number increment at each line\n"
#~ "  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
#~ "one\n"
#~ "  -n, --number-format=FORMAT      insert line numbers according to "
#~ "FORMAT\n"
#~ "  -p, --no-renumber               do not reset line numbers at logical "
#~ "pages\n"
#~ "  -s, --number-separator=STRING   add STRING after (possible) line "
#~ "number\n"
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ "\n"
#~ "  a         number all lines\n"
#~ "  t         number only nonempty lines\n"
#~ "  n         number no lines\n"
#~ "  pREGEXP   number only lines that contain a match for REGEXP\n"
#~ "\n"
#~ "FORMAT is one of:\n"
#~ "\n"
#~ "  ln   left justified, no leading zeros\n"
#~ "  rn   right justified, no leading zeros\n"
#~ "  rz   right justified, leading zeros\n"
#~ "\n"
#~ msgstr ""
#~ "Afficher chaque FICHIER sur la sortie standard, avec numéros de ligne.\n"
#~ "Sans FICHIER, ou FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -b, --body-numbering=STYLE      utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "  -d, --section-delimiter=CC      utiliser CC pour séparer les pages\n"
#~ "                                  logiques\n"
#~ "  -f, --footer-numbering=STYLE    utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "                                  de bas de page\n"
#~ "  -h, --header-numbering=STYLE    utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "                                  d'en-tête\n"
#~ "  -i, --page-increment=N          incrémenter de N de lignes à chaque "
#~ "ligne\n"
#~ "  -l, --join-blank-lines=N        regrouper N de lignes vides\n"
#~ "                                  en une seule ligne\n"
#~ "  -n, --number-format=FORMAT      insérer un numéro de ligne selon "
#~ "FORMAT\n"
#~ "  -p, --no-renumber               ne pas réinitialiser le nombre de "
#~ "lignes\n"
#~ "                                  aux pages logiques\n"
#~ "  -s, --number-separator=CHAÎNE   ajouter la CHAÎNE après (si possible)\n"
#~ "                                  le numéro de ligne\n"
#~ "  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
#~ "                                  sur chaque page logique\n"
#~ "  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
#~ "                                  numéroter les lignes\n"
#~ "      --help                      afficher l'aide-mémoire\n"
#~ "      --version                   afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
#~ "CC se compose de deux caractères délimiteurs pour séparer les pages "
#~ "logiques\n"
#~ "un deuxième caractère manquant implique que:\n"
#~ "taper \\\\ pour  \\.  STYLE est une des options parmi:\n"
#~ "\n"
#~ "  a         numéroter toutes les lignes\n"
#~ "  t         numéroter seulement les lignes non vides\n"
#~ "  n         numéroter n lignes\n"
#~ "  pEXPREG   numéroter seulement les lignes ayant une concordance à "
#~ "EXPREG\n"
#~ "\n"
#~ "FORMAT doit être choisi parmi:\n"
#~ "\n"
#~ "  ln   justifié à gauche, sans zéro de préfixe\n"
#~ "  rn   justifié à droite, sans zéro de préfixe\n"
#~ "  rz   justifié à droite, avec zéros de préfixe\n"
#~ "\n"

#~ msgid ""
#~ "Write an unambiguous representation, octal bytes by default, of FILE\n"
#~ "to standard output.  With no FILE, or when FILE is -, read standard "
#~ "input.\n"
#~ "\n"
#~ "  -A, --address-radix=RADIX   decide how file offsets are printed\n"
#~ "  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n"
#~ "  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n"
#~ "  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
#~ "chars\n"
#~ "  -t, --format=TYPE           select output format or formats\n"
#~ "  -v, --output-duplicates     do not use * to mark line suppression\n"
#~ "  -w, --width[=BYTES]         output BYTES bytes per output line\n"
#~ "      --traditional           accept arguments in pre-POSIX form\n"
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ "\n"
#~ "Pre-POSIX format specifications may be intermixed, they accumulate:\n"
#~ "  -a   same as -t a,  select named characters\n"
#~ "  -b   same as -t oC, select octal bytes\n"
#~ "  -c   same as -t c,  select ASCII characters or backslash escapes\n"
#~ "  -d   same as -t u2, select unsigned decimal shorts\n"
#~ "  -f   same as -t fF, select floats\n"
#~ "  -h   same as -t x2, select hexadecimal shorts\n"
#~ "  -i   same as -t d2, select decimal shorts\n"
#~ "  -l   same as -t d4, select decimal longs\n"
#~ "  -o   same as -t o2, select octal shorts\n"
#~ "  -x   same as -t x2, select hexadecimal shorts\n"
#~ msgstr ""
#~ "Afficher le contenu du FICHIER selon une représentation non ambiguë\n"
#~ "par un affichage des octets en octal par défaut sur la sortie standard.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -A, --address-radix=BASE    afficher les octets selon un adressage\n"
#~ "                              relatif dans la BASE sélectionnée\n"
#~ "  -j, --skip-bytes=N          escamoter les N premiers octets de chaque\n"
#~ "                              fichier\n"
#~ "  -N, --read-bytes=N          limiter à N le nombre d'octets lus par\n"
#~ "                              fichier\n"
#~ "  -s, --strings[=N]           afficher la chaîne d'au moins N caractères\n"
#~ "                              graphiques\n"
#~ "  -t, --format=TYPE           sélectionner les formats de sortie\n"
#~ "  -v, --output-duplicates     ne pas utiliser * pour marquer la\n"
#~ "                              suppression de ligne\n"
#~ "  -w, --width[=N]             afficher N octets par ligne de sortie\n"
#~ "      --traditional           accepter les arguments de la forme pré-"
#~ "POSIX\n"
#~ "      --help                  afficher l'aide-mémore et quitter\n"
#~ "      --version               afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Les spécifications de format pré-POSIX peuvent être entremêlées,\n"
#~ "ils sont alors cumulées:\n"
#~ "  -a   identique à -t a,    identifier les caractères\n"
#~ "  -b   identique à -t oC,   identifier les octets en octal\n"
#~ "  -c   identique à -t c,    identifier les caractères ASCII ou\n"
#~ "                            la barre oblique inverse\n"
#~ "  -d   identique à -t u2,   identifier en entier court non signé\n"
#~ "  -f   identique à -t fF,   identifier en nombre flottant\n"
#~ "  -h   identique à -t x2,   identifier en hexadécimal court\n"
#~ "  -i   identique à -t d2,   identifier en décimal court\n"
#~ "  -l   identique à -t d4,   identifier en décimal long\n"
#~ "  -o   identique à -t o2,   identifier en octal court\n"
#~ "  -x   identique à -t x2,   identifier en hexadécimal court\n"

#~ msgid ""
#~ "\n"
#~ "For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
#~ "is the pseudo-address at first byte printed, incremented when dump is\n"
#~ "progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
#~ "hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
#~ "\n"
#~ "TYPE is made up of one or more of these specifications:\n"
#~ "\n"
#~ "  a          named character\n"
#~ "  c          ASCII character or backslash escape\n"
#~ "  d[SIZE]    signed decimal, SIZE bytes per integer\n"
#~ "  f[SIZE]    floating point, SIZE bytes per integer\n"
#~ "  o[SIZE]    octal, SIZE bytes per integer\n"
#~ "  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
#~ "  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
#~ "\n"
#~ "SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
#~ "sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
#~ "sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
#~ "for sizeof(double) or L for sizeof(long double).\n"
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
#~ "with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix "
#~ "to\n"
#~ "any type adds a display of printable characters to the end of each line\n"
#~ "of output.  -s without a number implies 3.  -w without a number implies "
#~ "32.\n"
#~ "By default, od uses -A o -t d2 -w 16.\n"
#~ msgstr ""
#~ "\n"
#~ "Pour respecter une vieille syntaxe (deuxième format d'appel), SAUT\n"
#~ "signifie -j SAUT.  ÉTIQUETTE est une pseudo adresse du premier octet "
#~ "imprimé\n"
#~ "incrémentée lorsque la vidange s'effectue.  Pour le SAUT et l'ÉTIQUETTE, "
#~ "un\n"
#~ "préfixe 0x ou 0X indique un format hexadécimal,  les suffixes peuvent\n"
#~ "être . pour l'octal et b pour un multiple de 512 octets.\n"
#~ "\n"
#~ "Le TYPE est composé d'une ou plusieurs spécifications suivantes:\n"
#~ "\n"
#~ "  a          identification des caractères\n"
#~ "  c          caractère ASCII ou barre oblique inverse\n"
#~ "  d[N]       décimal signé, N octets par entier\n"
#~ "  f[N]       point flottant, N octets par entier\n"
#~ "  o[N]       octal, N octets par entier\n"
#~ "  u[N]       décimal non signé N octets par entier\n"
#~ "  x[N]       hexadécimal, N octets par entier\n"
#~ "\n"
#~ "N est un nombre.  Le TYPE est soit d, o, u ou x, N peut être aussi C "
#~ "pour\n"
#~ "sizeof(char), S pour sizeof(short), I pour sizeof(int) ou L pour\n"
#~ "sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float), "
#~ "D\n"
#~ "pour sizeof(double) ou L pour sizeof(long double).\n"
#~ "\n"
#~ "BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour "
#~ "aucun.\n"
#~ "OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un "
#~ "multiple de\n"
#~ "512 avec le suffixe b, de 1024 avec k et de 1048576 avec m.\n"
#~ "-s non suivi d un nombre implique 3,  32 pour -w.\n"
#~ "Par défaut, od utilise -A o -t d2 -w 16.\n"

#~ msgid ""
#~ "Paginate or columnate FILE(s) for printing.\n"
#~ "\n"
#~ "  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
#~ "                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
#~ "  -COLUMN, --columns=COLUMN\n"
#~ "                    produce COLUMN-column output and print columns down,\n"
#~ "                    unless -a is used. Balance number of lines in the\n"
#~ "                    columns on each page.\n"
#~ "  -a, --across      print columns across rather than down, used together\n"
#~ "                    with -COLUMN\n"
#~ "  -c, --show-control-chars\n"
#~ "                    use hat notation (^G) and octal backslash notation\n"
#~ "  -d, --double-space\n"
#~ "                    double space the output\n"
#~ "  -D, --date-format=FORMAT\n"
#~ "                    use FORMAT for the header date\n"
#~ "  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
#~ "                    expand input CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -F, -f, --form-feed\n"
#~ "                    use form feeds instead of newlines to separate pages\n"
#~ "                    (by a 3-line page header with -F or a 5-line header\n"
#~ "                    and trailer without -F)\n"
#~ msgstr ""
#~ "Paginer ou mettre en colonne les FICHIERS pour impression.\n"
#~ "\n"
#~ "  +PREMIÈRE_PAGE[:DERNIÈRE_PAGE], \n"
#~ "      --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE]\n"
#~ "                       débuter [stopper] l'impression à la PREMIÈRE_PAGE\n"
#~ "                       ou à la DERNIÈRE_PAGE\n"
#~ "  -COLUMN\n"
#~ "      --columns=COLUMN\n"
#~ "                       produire une sortie en COLONNES et imprimer les\n"
#~ "                       les colonnes vers le bas à moins que -a ne soit\n"
#~ "                       utilisé.  Équilibrer le nombre de lignes de "
#~ "chaque\n"
#~ "                       colonne sur chaque page.\n"
#~ "  -a, --across         imprimer les colonnes horizontalement au lieu de\n"
#~ "                       verticalement, utilisé ensemble avec -COLUMN\n"
#~ "  -c, --show-control-chars\n"
#~ "                       utiliser une notation par chapeau (^G) et octale\n"
#~ "                       avec barre oblique inverse\n"
#~ "  -d, --double-space\n"
#~ "                       produire une sortie avec double espacement\n"
#~ "  -e[CAR[LARGEUR]], --expand-tabs[=CAR[LARGEUR]]\n"
#~ "                       faire l'expansion des CARactères (ou de "
#~ "tabulation)\n"
#~ "                       selon la LARGEUR de tabulation (par défaut 8)\n"
#~ "  -F, -f,\n"
#~ "      --form-feed\n"
#~ "                       utiliser des sauts de page au lieu des sauts de \n"
#~ "                       lignes pour séparer les pages (3 lignes par en-"
#~ "tête\n"
#~ "                       avec -f ou 5 lignes par en-tête et bas de page "
#~ "sans -f) \n"

#~ msgid ""
#~ "  -h HEADER, --header=HEADER\n"
#~ "                    use a centered HEADER instead of filename in page "
#~ "header,\n"
#~ "                    -h \"\" prints a blank line, don't use -h\"\"\n"
#~ "  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
#~ "                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -J, --join-lines  merge full lines, turns off -W line truncation, no "
#~ "column\n"
#~ "                    alignment, -S[STRING] sets separators\n"
#~ "  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
#~ "                    set the page length to PAGE_LENGTH (66) lines\n"
#~ "                    (default number of lines of text 56, and with -F 63)\n"
#~ "  -m, --merge       print all files in parallel, one in each column,\n"
#~ "                    truncate lines, but join lines of full length with -"
#~ "J\n"
#~ "  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
#~ "                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
#~ "                    default counting starts with 1st line of input file\n"
#~ "  -N NUMBER, --first-line-number=NUMBER\n"
#~ "                    start counting with NUMBER at 1st line of first\n"
#~ "                    page printed (see +FIRST_PAGE)\n"
#~ "  -o MARGIN, --indent=MARGIN\n"
#~ "                    offset each line with MARGIN (zero) spaces, do not\n"
#~ "                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
#~ "  -r, --no-file-warnings\n"
#~ "                    omit warning when a file cannot be opened\n"
#~ msgstr ""
#~ "  -h EN-TÊTE, --header=EN-TÊTE\n"
#~ "                       centrer l'EN-TÊTE au lieu du nom de fichier dans\n"
#~ "                       l'en-tête de la page, avec de longues en-têtes\n"
#~ "                       une troncation du côté gauche peut survenir\n"
#~ "                        -h \\\"\\\" imprime une ligne blanche.\n"
#~ "                       Ne pas utiliser:  -h\\\"\\\"\\n\"\n"
#~ "  -i, --output-tabs[=CAR[LARGEUR]]\n"
#~ "                       remplacer les blancs par des CARactères (ou\n"
#~ "                       de tabulation) selon la LARGEUR de tabulation (8)\n"
#~ "  -J, --join-lines\n"
#~ "                       faire la fusion des lignes pleines, inhiber la \n"
#~ "                       troncation des lignes -w, sans alignement des\n"
#~ "                       colonnes -s[CHAÎNE] initialise les séparateurs\n"
#~ "  -l LONGUEUR_DE_PAGE, --length LONGUEUR_DE_PAGE\n"
#~ "                       utiliser LONGUEUR_DE_PAGE au lieu de 66 lignes\n"
#~ "                       (par défaut de lignes est de 56 pour un texte,\n"
#~ "                       avec -f de 63)\n"
#~ "  -m, --merge          imprimer tous les fichiers en parallèle un par\n"
#~ "                       colonne, tronque les lignes, mais joint les\n"
#~ "                       lignes de pleine longueur avec -j\n"
#~ "  -n, --number-lines[=SÉP[CHIFFRES]]\n"
#~ "                       numéroter les lignes, par des CHIFFRES (5), suivi "
#~ "de\n"
#~ "                       SÉParateurs (TAB) par défaut le compteur débute\n"
#~ "                       avec la première ligne du fichier d'entrée\n"
#~ "  -N, --first-line-number=VALEUR\n"
#~ "                       débuter le compteur avec la VALEUR avec la 1ère "
#~ "ligne\n"
#~ "                       de la 1ère page imprimée (voir +PREMIÈRE_PAGE)\n"
#~ "  -o, --indent=MARGE\n"
#~ "                       débuter l'impression de chaque ligne après une\n"
#~ "                       MARGE d'espacement  (n'affecte pas -w)\n"
#~ "  -r, --no-file-warnings\n"
#~ "                       inhiber les avertissements lorsqu'un fichier\n"
#~ "                       ne peut être ouvert\n"

#~ msgid ""
#~ "  -s[CHAR],--separator[=CHAR]\n"
#~ "                    separate columns by a single character, default for "
#~ "CHAR\n"
#~ "                    is the <TAB> character without -w and 'no char' with -"
#~ "w\n"
#~ "                    -s[CHAR] turns off line truncation of all 3 column\n"
#~ "                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
#~ "  -S[STRING], --sep-string[=STRING]\n"
#~ "                    separate columns by an optional STRING, don't use\n"
#~ "                    -S \"STRING\", -S only: No separator used (same as -S"
#~ "\"\"),\n"
#~ "                    without -S: Default separator <TAB> with -J and "
#~ "<space>\n"
#~ "                    otherwise (same as -S\" \"), no effect on column "
#~ "options\n"
#~ "  -t, --omit-header omit page headers and trailers\n"
#~ "  -T, --omit-pagination\n"
#~ "                    omit page headers and trailers, eliminate any "
#~ "pagination\n"
#~ "                    by form feeds set in input files\n"
#~ "  -v, --show-nonprinting\n"
#~ "                    use octal backslash notation\n"
#~ "  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters for\n"
#~ "                    multiple text-column output only, -s[char] turns off "
#~ "(72)\n"
#~ "  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters always,\n"
#~ "                    truncate lines, except -J option is set, no "
#~ "interference\n"
#~ "                    with -S or -s\n"
#~ "  --help            display this help and exit\n"
#~ "  --version         output version information and exit\n"
#~ "\n"
#~ "-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
#~ "FILE is -, read standard input.\n"
#~ msgstr ""
#~ "  -s, --separator[=CHAÎNE]\n"
#~ "                       séparer les colonnes à l'aide d'une CHAÎNE "
#~ "optionnelle\n"
#~ "                       optionnelle, ne pas utiliser -s \\\"CHAÎNE\\\"\n"
#~ "                       sans -s utilise le séparateur (par défaut un "
#~ "blanc)\n"
#~ "                       identique à -s\\\" \\\"; -s seulement: aucun \n"
#~ "                       séparateur n'est utilisé, identique à  -s\\\"\\\"\n"
#~ "  -S[CHAÎNE],\n"
#~ "      --sep-string[=CHAÎNE]\n"
#~ "                       séparer les colonnes à l'aide d'une chaîne "
#~ "optionnelle\n"
#~ "                       ne pas utiliser -S \"CHAÎNE\", -S seulement: "
#~ "SANS \n"
#~ "                       utiliser de séparateur (identique à -S\"\"),\n"
#~ "                       sans -S: séparateur par défaut <TAB> avec -J et "
#~ "<space>\n"
#~ "                       autrement (identique as -S\" \"), sans effet sur "
#~ "les options\n"
#~ "                       des colonnes\n"
#~ "  -t, --omit-header\n"
#~ "                      inhiber l'en-tête et le bas de page\n"
#~ "  -T, --omit-pagination\n"
#~ "                       inhiber l'en-tête et le bas de page, éliminer\n"
#~ "                       les agencements de page par saut de page indiqués\n"
#~ "                       dans les fichiers d'entrée\n"
#~ "  -v, --show-nonprinting\n"
#~ "                       utiliser la notation octale avec barre oblique\n"
#~ "                       inverse\n"
#~ "  -w LARGEUR_DE_PAGE,\n"
#~ "      --width=LARGEUR_DE_PAGE\n"
#~ "                       utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\\n"
#~ "\"\n"
#~ "                       tronquer les lignes (voir aussi l'option -j)\n"
#~ "  -W LARGEUR_DE_PAGE,\n"
#~ "       --page-width=LARGEUR_DE_PAGE\n"
#~ "                       toujours utiliser une LARGEUR_DE_PAGE de 72 "
#~ "caractères,\n"
#~ "                       tronquer les lignes, sauf lorsque l'option -J est "
#~ "utilisée\n"
#~ "                       sans interférence avec -S ou -s\n"
#~ "      --help           afficher l'aide-mémore et quitter\n"
#~ "      --version        afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "L'option -T est implicite lorsque -l N est utilisée et avec -f quand nn "
#~ "<= 10\n"
#~ "ou <= 3. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"

#~ msgid ""
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "\n"
#~ "  -A, --auto-reference           output automatically generated "
#~ "references\n"
#~ "  -C, --copyright                display Copyright and copying "
#~ "conditions\n"
#~ "  -G, --traditional              behave more like System V `ptx'\n"
#~ "  -F, --flag-truncation=STRING   use STRING for flagging line "
#~ "truncations\n"
#~ "  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
#~ "  -O, --format=roff              generate output as roff directives\n"
#~ "  -R, --right-side-refs          put references at right, not counted in -"
#~ "w\n"
#~ "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
#~ "  -T, --format=tex               generate output as TeX directives\n"
#~ "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
#~ "  -b, --break-file=FILE          word break characters in this FILE\n"
#~ "  -f, --ignore-case              fold lower case to upper case for "
#~ "sorting\n"
#~ "  -g, --gap-size=NUMBER          gap size in columns between output "
#~ "fields\n"
#~ "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
#~ "  -o, --only-file=FILE           read only word list from this FILE\n"
#~ "  -r, --references               first field of each line is a reference\n"
#~ "  -t, --typeset-mode               - not implemented -\n"
#~ "  -w, --width=NUMBER             output width in columns, reference "
#~ "excluded\n"
#~ "      --help                     display this help and exit\n"
#~ "      --version                  output version information and exit\n"
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
#~ msgstr ""
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "\n"
#~ "  -A, --auto-reference           générer des références automatiquement\n"
#~ "  -C, --copyright                afficher les Droits d'auteur et les "
#~ "conditions\n"
#~ "                                 de recopie\n"
#~ "  -G, --traditional              faire fonctionner `ptx' comme en System "
#~ "V\n"
#~ "  -F, --flag-truncation=CHAÎNE   utiliser la CHAÎNE pour indiquer la "
#~ "troncation\n"
#~ "                                 des lignes\n"
#~ "  -M, --macro-name=CHAÎNE        nom de la macro à utiliser au lieu de "
#~ "`xx'\n"
#~ "  -O, --format=roff              générer la sortie comme des directives "
#~ "roff\n"
#~ "  -R, --right-side-refs          placer les références à droite, sans "
#~ "décompte -w\n"
#~ "  -S, --sentence-regexp=REGEXP   pour la fin des lignes ou des phrases\n"
#~ "  -T, --format=tex               générer la sortie comme des directives "
#~ "TeX\n"
#~ "  -W, --word-regexp=REGEXP       utiliser REGEXP pour établir la "
#~ "concordance avec chaque mot\n"
#~ "  -b, --break-file=FICHIER       utiliser les coupures de mots de ce "
#~ "FICHIER\n"
#~ "  -f, --ignore-case              ramener les minuscules en majuscules "
#~ "pour le trie\n"
#~ "  -g, --gap-size=N               espacer de N blancs les colonnes entre "
#~ "les champs\n"
#~ "  -i, --ignore-file=FICHIER      lire la liste des mots à ignorer de ce "
#~ "FICHIER\n"
#~ "  -o, --only-file=FICHIER        lire la liste des mots uniquement de ce "
#~ "FICHIER\n"
#~ "  -r, --references               donner la référence du 1er champ de "
#~ "chaque ligne\n"
#~ "  -t, --typeset-mode               - option non implanté -\n"
#~ "  -w, --width=N                  largeur des colonnes, références "
#~ "exclues\n"
#~ "      --help                     afficher l'aide-mémoire\n"
#~ "      --version                  afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard. -F "
#~ "par défaut.\n"

#~ msgid ""
#~ "Other options:\n"
#~ "\n"
#~ "  -c, --check               check whether input is sorted; do not sort\n"
#~ "  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin "
#~ "1)\n"
#~ "  -m, --merge               merge already sorted files; do not sort\n"
#~ "  -o, --output=FILE         write result to FILE instead of standard "
#~ "output\n"
#~ "  -s, --stable              stabilize sort by disabling last-resort "
#~ "comparison\n"
#~ "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
#~ "  -t, --field-separator=SEP use SEP instead of non- to whitespace "
#~ "transition\n"
#~ "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %"
#~ "s\n"
#~ "                              multiple options specify multiple "
#~ "directories\n"
#~ "  -u, --unique              with -c: check for strict ordering\n"
#~ "                              otherwise: output only the first of an "
#~ "equal run\n"
#~ "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolescent\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Autres options:\n"
#~ "\n"
#~ "  -c, --check               vérifier si l'entrée est triée; ne pas trier\n"
#~ "  -k, --key=POS1[,POS2]     débuter avec la clé à la POS1, terminer à POS "
#~ "2 (origine 1)\n"
#~ "  -m, --merge               faire la fusion des fichiers déjà triés; ne "
#~ "pas trier\n"
#~ "  -o, --output=FICHIER      écrire le résultat au FICHIER au lieu de la "
#~ "sortie standard\n"
#~ "  -s, --stable              stabiliser le tri en inhibant la comparaison "
#~ "de dernier recours\n"
#~ "  -S, --buffer-size=TAILLE  utiliser la TAILLE pour le tampon mémoire "
#~ "principal\n"
#~ "  -t, --field-separator=SEP utiliser le SÉParateur au lieu de non- par "
#~ "les transitions d'espace blancs\n"
#~ "  -T, --temporary-directory=RÉP utiliser le RÉP pour les fichiers "
#~ "temporaires, pas $TMPDIR ou %s\n"
#~ "                            options multiples pour spécifier de multiples "
#~ "répertoires\n"
#~ "  -u, --unique              avec -c: vérifier l'ordonnancement strict\n"
#~ "                            autrement: afficher les premiers d'une passe "
#~ "équivalente\n"
#~ "  -z, --zero-terminated     terminer les lignes avec l'octet 0, pas par "
#~ "le retour de chariot\n"
#~ "  +POS1 [-POS2]             débuter avec la clé à POS1, terminer  avant "
#~ "POS2 (origin 0)\n"
#~ "                            AVERTISSEMENT: cette option est désuète\n"
#~ "      --help                afficher l'aide-mémoire\n"
#~ "      --version             afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                             inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                             inaccessible later -- useful only with -f\n"
#~ "  -c, --bytes=N            output the last N bytes\n"
#~ "  -f, --follow[={name|descriptor}] output appended data as the file "
#~ "grows;\n"
#~ "                             -f, --follow, and --follow=descriptor are\n"
#~ "                             equivalent\n"
#~ "  -n, --lines=N            output the last N lines, instead of the last %"
#~ "d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           with --follow=name, reopen a FILE which has "
#~ "not\n"
#~ "                             changed size after N (default %d) "
#~ "iterations\n"
#~ "                             to see if it has been unlinked or renamed\n"
#~ "                             (this is the usual case of rotated log "
#~ "files)\n"
#~ "      --pid=PID            with -f, terminate after process ID, PID dies\n"
#~ "  -q, --quiet, --silent    never output headers giving file names\n"
#~ "  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
#~ "                             (default 1) seconds\n"
#~ "  -v, --verbose            always output headers giving file names\n"
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Imprimer les dernières %d lignes de chaque FICHIER sur la sortie "
#~ "standard.\n"
#~ "Avec plus d'un FICHIER, précéder chacun par une en-tête contenant le nom "
#~ "du\n"
#~ "fichier. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"
#~ "\n"
#~ "      --retry              continuer de tenter d'ouvrir le fichier même "
#~ "s'il\n"
#~ "                           est inaccessible lorsque tail démarre ou s'il "
#~ "devient\n"
#~ "                           inaccessible plus tard -- utile seulement avec "
#~ "-f\n"
#~ "  -c, --bytes=N            afficher les N derniers octets \n"
#~ "  -f, --follow[={nom|descripteur}]\n"
#~ "                           afficher les dernières données ajoutées tant\n"
#~ "                           que le fichier s'accroît; -f, --follow, et\n"
#~ "                           --follow=descripteur sont équivalents\n"
#~ "  -n, --lines=N            afficher les dernières N lignes, au lieu des %"
#~ "d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           voir la documentation de texinfo\n"
#~ "                           (le défaut est %d)\n"
#~ "      --pid=PID            avec -f, terminer après le processus ID, PID "
#~ "est arrêté\n"
#~ "  -q, --quiet, --silent    ne jamais afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "  -s, --sleep-interval=S   avec -f, attendre S secondes entre les "
#~ "itérations\n"
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Si le premier caractère de N (le nombre d octets ou lignes) est un `+',\n"
#~ "afficher à partir du Nième item depuis le début de chaque fichier,\n"
#~ "autrement, afficher les derniers N items dans le fichier.\n"
#~ "N peut comporter un suffixe de multiple:\n"
#~ "b pour 512, k pour 1024, m pour 1048576 (1 Meg).  Une première OPTION "
#~ "avec\n"
#~ "-VALEUR ou +VALEUR est traitée comme -n VALEUR ou -n + VALEUR\n"
#~ "à moins que VALEUR ait un suffixe multiplicateur [bkm],\n"
#~ "dans ce cas il est traité comme -c VALEUR ou -c +VALEUR.\n"
#~ "Option à décrire par le mainteneur: option non décrite en original.\n"
#~ "\n"
#~ "Avec l'option --follow (-f), tail utilise par défaut le descripteur de "
#~ "fichier\n"
#~ "qui permet de suivre l'évolution du fichier ciblé. Ce comportement n'est "
#~ "pas\n"
#~ "désirable lorsqu'on désire suivre l'évolution d'un fichier à l'aide de "
#~ "son\n"
#~ "nom (lors de la rotation des journaux). Utiliser --follow=nom dans ce "
#~ "cas.\n"
#~ "Cela forcera tail à suivre l'évolution du fichier en l'ouvrant "
#~ "périodiquement\n"
#~ "afin de vérifier s'il a été détruit ou recréé par un autre programme.\n"
#~ "\n"

#~ msgid ""
#~ "If the first character of N (the number of bytes or lines) is a `+',\n"
#~ "print beginning with the Nth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last N items in the file.  N may have a multiplier suffix:\n"
#~ "b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
#~ "or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
#~ "the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
#~ "or -c +VALUE.  Warning: a first option of +VALUE is obsolescent, and "
#~ "support\n"
#~ "for it will be withdrawn.\n"
#~ "\n"
#~ "With --follow (-f), tail defaults to following the file descriptor, "
#~ "which\n"
#~ "means that even if a tail'ed file is renamed, tail will continue to "
#~ "track\n"
#~ "its end.  This default behavior is not desirable when you really want to\n"
#~ "track the actual name of the file, not the file descriptor (e.g., log\n"
#~ "rotation).  Use --follow=name in that case.  That causes tail to track "
#~ "the\n"
#~ "named file by reopening it periodically to see if it has been removed "
#~ "and\n"
#~ "recreated by some other program.\n"
#~ "\n"
#~ msgstr ""
#~ "Si le premier caractère de N (le nombre d'octets ou de lignes) est `+',\n"
#~ "afficher le Nième item depuis le début de chaque fichier, autrement,\n"
#~ "afficher les derniers N items du fichier.  N peut avoir un suffixe "
#~ "multiplicateur:\n"
#~ "b pour 512, k pour 1024, m pour 1048576 (1 Meg).  Une 1è OPTION ayant -"
#~ "VALEUR\n"
#~ "ou +VALEUR est traitée comme -n VALEUR ou -n +VALEUR à moins que VALEUR "
#~ "ait un des\n"
#~ "suffixes multiplicateurs suivants [bkm], dans ce cas il est traité comme -"
#~ "c VALEUR\n"
#~ "ou -c +VALEUR.  AVERTISSEMENT: une 1ère option ayant la forme +VALEUR est "
#~ "désuète,\n"
#~ "dont le support ne sera plus disponible.\n"
#~ "\n"
#~ "Avec --follow (-f), suivre par défaut le descripteur de fichier, lequel\n"
#~ "signifie que même si le fichier est renommé alors qu'il est suivi à "
#~ "l'aide d'un `tail'\n"
#~ "le suivi sera poursuivi. Ce comportement par défaut n'est pas "
#~ "souhaitable\n"
#~ "lorsqu'on désire suivre un fichier à l'aide de son nom, pas le "
#~ "descripteur de fichier\n"
#~ "(i.e., rotation de journal).  Utiliser --follow=nom dans ce cas.  Cela "
#~ "amène `tail'\n"
#~ "à suivre le fichier en le réouvrant de façon périodique afin de voir s'il "
#~ "a été\n"
#~ "renommé ou détruit par un autre programme.\n"
#~ "\n"

#~ msgid ""
#~ "\n"
#~ "SETs are specified as strings of characters.  Most represent themselves.\n"
#~ "Interpreted sequences are:\n"
#~ "\n"
#~ "  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
#~ "  \\\\              backslash\n"
#~ "  \\a              audible BEL\n"
#~ "  \\b              backspace\n"
#~ "  \\f              form feed\n"
#~ "  \\n              new line\n"
#~ "  \\r              return\n"
#~ "  \\t              horizontal tab\n"
#~ "  \\v              vertical tab\n"
#~ "  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
#~ "  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
#~ "  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
#~ "  [:alnum:]       all letters and digits\n"
#~ "  [:alpha:]       all letters\n"
#~ "  [:blank:]       all horizontal whitespace\n"
#~ "  [:cntrl:]       all control characters\n"
#~ "  [:digit:]       all digits\n"
#~ "  [:graph:]       all printable characters, not including space\n"
#~ "  [:lower:]       all lower case letters\n"
#~ "  [:print:]       all printable characters, including space\n"
#~ "  [:punct:]       all punctuation characters\n"
#~ "  [:space:]       all horizontal or vertical whitespace\n"
#~ "  [:upper:]       all upper case letters\n"
#~ "  [:xdigit:]      all hexadecimal digits\n"
#~ "  [=CHAR=]        all characters which are equivalent to CHAR\n"
#~ msgstr ""
#~ "\n"
#~ "Les ENSEMBLES sont spécifiés comme des chaînes de caractères.\n"
#~ "La plupart se représente eux-mêmes.\n"
#~ "Les séquences d'interprétation sont:\n"
#~ "\n"
#~ "  \\NNN            caractère ayant la valeur octale NNN (1 à 3 chiffres "
#~ "octaux)\n"
#~ "  \\\\              barre oblique inverse\n"
#~ "  \\a              cloche sonore \n"
#~ "  \\b              caractère d'effacement\n"
#~ "  \\f              saut de page \n"
#~ "  \\n              saut de ligne \n"
#~ "  \\r              retour\n"
#~ "  \\t              saut horizontal\n"
#~ "  \\v              saut vertical \n"
#~ "  CAR1-CAR2       tous les caractères de CAR1 à CAR2 en ordre croissant\n"
#~ "  [CAR*]          dans ENS2, copie de CAR jusqu'à longueur de ENS1\n"
#~ "  [CAR*RÉP]       RÉPéter copies de CAR, RÉPéter en octal si débute par "
#~ "0\n"
#~ "  [:alnum:]       toutes les lettres et les chiffres\n"
#~ "  [:alpha:]       toutes les lettres\n"
#~ "  [:blank:]       tous les blancs horizontaux\n"
#~ "  [:cntrl:]       tous les caractères de contrôle\n"
#~ "  [:digit:]       tous les chiffres\n"
#~ "  [:graph:]       tous les caractères imprimables, sans inclure les "
#~ "blancs\n"
#~ "  [:lower:]       tous les lettres minuscules\n"
#~ "  [:print:]       tous les caractères imprimables, incluant les blancs\n"
#~ "  [:punct:]       tous les caractères de ponctuation\n"
#~ "  [:space:]       tous les sauts verticaux ou horizontaux\n"
#~ "  [:upper:]       toutes les lettres majuscules\n"
#~ "  [:xdigit:]      tous les chiffres hexadécimaux\n"
#~ "  [=CAR=]         tous les caractères équivalents à CAR\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ "  -c, --count           prefix lines by the number of occurrences\n"
#~ "  -d, --repeated        only print duplicate lines\n"
#~ "  -D, --all-repeated    print all duplicate lines\n"
#~ "  -f, --skip-fields=N   avoid comparing the first N fields\n"
#~ "  -i, --ignore-case     ignore differences in case when comparing\n"
#~ "  -s, --skip-chars=N    avoid comparing the first N characters\n"
#~ "  -u, --unique          only print unique lines\n"
#~ "  -w, --check-chars=N   compare no more than N characters in lines\n"
#~ "  -N                    same as -f N\n"
#~ "  +N                    same as -s N (obsolescent; will be withdrawn)\n"
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ "\n"
#~ "A field is a run of whitespace, then non-whitespace characters.\n"
#~ "Fields are skipped before chars.\n"
#~ msgstr ""
#~ "Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
#~ "(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
#~ "(ou vers la sortie standard).\n"
#~ "\n"
#~ "  -c, --count           préfixer les lignes par le nombre d'occurences\n"
#~ "  -d, --repeated        afficher seulement les lignes ayant des "
#~ "duplicatats\n"
#~ "  -D, --all-repeated    afficher toutes les lignes qui ont des "
#~ "duplicatats\n"
#~ "  -f, --skip-fields=N   éviter de comparer les N premiers champs\n"
#~ "  -i, --ignore-case     ignorer les différences de la casse\n"
#~ "  -s, --skip-chars=N    éviter de comparer les N premiers caractères\n"
#~ "  -u, --unique          afficher seulement les lignes uniques\n"
#~ "  -w, --check-chars=N   ne pas comparer plus de N caractères des lignes\n"
#~ "  -N                    identique à -f N\n"
#~ "  +N                    identique à -s N\n"
#~ "      --help            afficher l'aide-mémoire\n"
#~ "      --version         afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Un champ est une suite de blancs, suivi de caractères non-blancs.\n"
#~ "Les champs sont escamotés avant les caractères.\n"

#~ msgid ""
#~ "specified number of bytes `%s' is larger than the maximum\n"
#~ "representable value of type `long'"
#~ msgstr ""
#~ "Le nombre d'octets spécifiés `%s' est plus grand que la valeur\n"
#~ "maximale représentable du type `long'"

#~ msgid "%s%*s%s%*sPage"
#~ msgstr "%s%*s%s%*sPage"

#~ msgid ""
#~ "Write sorted concatenation of all FILE(s) to standard output.\n"
#~ "\n"
#~ "  +POS1 [-POS2]    start a key at POS1, end it *before* POS2 "
#~ "(obsolescent)\n"
#~ "\t\t     field numbers and character offsets are numbered\n"
#~ "                     starting with zero (contrast with the -k option)\n"
#~ "  -b               ignore leading blanks in sort fields or keys\n"
#~ "  -c               check if given files already sorted, do not sort\n"
#~ "  -d               consider only [a-zA-Z0-9 ] characters in keys\n"
#~ "  -f               fold lower case to upper case characters in keys\n"
#~ "  -g               compare according to general numerical value, imply -"
#~ "b\n"
#~ "  -i               consider only [\\040-\\0176] characters in keys\n"
#~ "  -k POS1[,POS2]   start a key at POS1, end it *at* POS2\n"
#~ "\t\t     field numbers and character offsets are numbered\n"
#~ "                     starting with one (contrast with zero-based +POS "
#~ "form)\n"
#~ "  -m               merge already sorted files, do not sort\n"
#~ "  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n"
#~ "  -n               compare according to string numerical value, imply -b\n"
#~ "  -o FILE          write result on FILE instead of standard output\n"
#~ "  -r               reverse the result of comparisons\n"
#~ "  -s               stabilize sort by disabling last resort comparison\n"
#~ "  -t SEP           use SEParator instead of non- to whitespace "
#~ "transition\n"
#~ "  -T DIRECTORY     use DIRECTORY for temporary files, not $TMPDIR or %s\n"
#~ "  -u               with -c, check for strict ordering;\n"
#~ "                   with -m, only output the first of an equal sequence\n"
#~ "  -z               end lines with 0 byte, not newline, for find -print0\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Écrire la concaténation triée de tous les FICHIERS sur la sortie "
#~ "standard.\n"
#~ "\n"
#~ "  +POS1 [-POS2]    débuter avec la clé de position POS1, et terminer\n"
#~ "                   *à* POS2 (forme désuète), les numéros de champs \n"
#~ "                   et la position relative des caractères sont numérotés\n"
#~ "  -b               ignorer les blancs de tête dans les champs\n"
#~ "                   ou les clés triés\n"
#~ "  -c               vérifier si un fichier soumis a déjà été trié,\n"
#~ "                   si oui ne pas trier\n"
#~ "  -d               considérer seulement les caractères [a-zA-Z0-9 ]\n"
#~ "                   comme clés\n"
#~ "  -f               considérer les minuscules comme des majuscules\n"
#~ "                   comme clés\n"
#~ "  -g               comparer selon la valeur numérique générale, implique -"
#~ "b\n"
#~ "  -i               considérer seulement les caractères [\\040-\\0176]\n"
#~ "                   comme clés\n"
#~ "  -k POS1[,POS2]   identique à +POS1 [-POS2], mais toutes les positions\n"
#~ "                   comptées à partir de 1, les numéros de champs \n"
#~ "                   et la position relative des caractères sont numérotés\n"
#~ "  -m               fusionner les fichiers triés, ne pas trier \n"
#~ "  -M               comparer selon (inconnu) < `JAN' < ... < `DÉC',\n"
#~ "                   implique -b\n"
#~ "  -n               comparer selon la valeur numérique de la chaîne,\n"
#~ "                   implique -b\n"
#~ "  -o FICHIER       produire le résultat dans le FICHIER au lieu de la\n"
#~ "                   sortie standard\n"
#~ "  -r               inverser le résultat des comparaisons\n"
#~ "  -s               stabiliser le trie en inhibant la dernière "
#~ "comparaison\n"
#~ "  -t SÉP           utiliser le SÉParateur au lieu de la transition\n"
#~ "                   non blanc\n"
#~ "                   à blanc\n"
#~ "  -T RÉPERTOIRE    utiliser le RÉPERTOIRE temporaire, non pas $TMPDIR\n"
#~ "                   ou %s\n"
#~ "  -u               avec -c, vérifier l'ordonnancement strict\n"
#~ "                   avec -m, afficher seulement la première séquence\n"
#~ "                   identique\n"
#~ "  -z               terminer les lignes avec un octet de valeur 0,\n"
#~ "                   pour la commande find find -print0\n"
#~ "      --help       afficher l'aide-mémoire\n"
#~ "      --version    afficher le nom et la version du logiciel\n"

#~ msgid "flushing file"
#~ msgstr "Fichier rejeté"

#~ msgid ""
#~ "when using the old-style +POS and -POS key specifiers,\n"
#~ "the +POS specifier must come first"
#~ msgstr ""
#~ "lorsque les options +POS et -POS de la vieille syntaxe\n"
#~ "sont utilisées, l'option +POS doit être spécifiée en premier"

#~ msgid "option `-k' requires an argument"
#~ msgstr "L'option `-k' requiert un argument."

#~ msgid "starting field spec has `.' but lacks following character offset"
#~ msgstr ""
#~ "La spécification du champ de départ contient `.' mais n'est pas suivi\n"
#~ "de caractères de saut."

#~ msgid ""
#~ "starting field character offset argument to the `-k' option\n"
#~ "must be positive"
#~ msgstr ""
#~ "Le caractère du champ de départ du argument de saut de l'option `-k'\n"
#~ "doit être positif."

#~ msgid "field specification has `,' but lacks following field spec"
#~ msgstr ""
#~ "La spécification du champ contient `,'\n"
#~ "mais n'est pas suivi de champs de spécification."

#~ msgid "ending field number argument to the `-k' option must be positive"
#~ msgstr ""
#~ "Le numéro du champ de terminaison de l'option `-k' doit être positif."

#~ msgid "ending field spec has `.' but lacks following character offset"
#~ msgstr ""
#~ "La spécification du champ de terminaison contient `.' mais n'est pas "
#~ "suivi\n"
#~ "de caractères de saut."

#~ msgid "option `-o' requires an argument"
#~ msgstr "L'option `-o' requiert un argument."

#~ msgid "option `-t' requires an argument"
#~ msgstr "L'option `-t' requiert un argument."

#~ msgid "option `-T' requires an argument"
#~ msgstr "L'option `-T' requiert un argument."

#~ msgid "%s: unrecognized option `-%c'\n"
#~ msgstr "%s: option non reconnue `-%c'\n"

#~ msgid "could not find loop"
#~ msgstr "ne peut trouver une boucle"

#~ msgid "%s: cannot follow end of non-regular file"
#~ msgstr "%s: ne peut suivre jusqu'à la fin d'un fichier non régulier."

#~ msgid ""
#~ "\n"
#~ "Report bugs to <textutils-bugs@gnu.org>."
#~ msgstr ""
#~ "\n"
#~ "Rapporter toutes anomalies à <textutils-bug@gnu.org>."

#~ msgid "`-w PAGE_WIDTH' invalid column number: `%s'"
#~ msgstr "`-w PAGE_WIDTH' contient un nombre de colonnes invalide: `%s'."

#~ msgid "`%s' has reappeared"
#~ msgstr "`%s' est réapparu"

#~ msgid ""
#~ "\n"
#~ "Report bugs to textutils-bugs@gnu.org"
#~ msgstr ""
#~ "\n"
#~ "Rapporter toutes anomalies à textutils-bug@gnu.org."

#~ msgid "%s: `%s' is so large that it is not representable"
#~ msgstr "%s, `%s' est trop grande qu'elle n'est pas représentable."

#~ msgid "`+' requires a numeric argument"
#~ msgstr "`+' requiert un argument numérique."

#~ msgid "%s: extra characters in the argument to the `-%c' option: `%s'\n"
#~ msgstr ""
#~ "%s: caractères superflus dans les arguments de l'option `-%c': `%s'\n"

#~ msgid ""
#~ "Paginate or columnate FILE(s) for printing.\n"
#~ "\n"
#~ "  +PAGE             begin printing with page PAGE\n"
#~ "  -COLUMN           produce COLUMN-column output and print columns down\n"
#~ "  -a                print columns across rather than down\n"
#~ "  -b                balance columns on the last page\n"
#~ "  -c                use hat notation (^G) and octal backslash notation\n"
#~ "  -d                double space the output\n"
#~ "  -e[CHAR[WIDTH]]   expand input CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -f, -F            simulate formfeed with newlines on output\n"
#~ "  -h HEADER         use HEADER instead of filename in page headers\n"
#~ "  -i[CHAR[WIDTH]]   replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -l PAGE_LENGTH    set the page length to PAGE_LENGTH (66) lines\n"
#~ "  -m                print all files in parallel, one in each column\n"
#~ "  -n[SEP[DIGITS]]   number lines, use DIGITS (5) digits, then SEP (TAB)\n"
#~ "  -o MARGIN         offset each line with MARGIN spaces (do not affect -"
#~ "w)\n"
#~ "  -r                inhibit warning when a file cannot be opened\n"
#~ "  -s[SEP]           separate columns by character SEP (TAB)\n"
#~ "  -t                inhibit 5-line page headers and trailers\n"
#~ "  -v                use octal backslash notation\n"
#~ "  -w PAGE_WIDTH     set page width to PAGE_WIDTH (72) columns\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "-t implied by -l N when N < 10.  Without -s, columns are separated by\n"
#~ "spaces.  With no FILE, or when FILE is -, read standard input.\n"
#~ msgstr ""
#~ "Paginer ou mettre en colonne des FICHIERS pour impression.\n"
#~ "\n"
#~ "  +N                   débuter l'impression à la page N\n"
#~ "  -COLONNE             produire un format de N colonnes et imprimer\n"
#~ "  -F, -f               simuler les sauts de pages avec des sauts de "
#~ "lignes\n"
#~ "  -a                   imprimer les colonnes en mode croisé plutôt que\n"
#~ "                       vers le bas\n"
#~ "  -b                   équilibrer les colonnes sur la dernière page\n"
#~ "  -c                   utiliser une notation par chapeau (^G) et octale\n"
#~ "                       avec barre oblique inverse\n"
#~ "  -d                   faire une sortie avec double espacement\n"
#~ "  -e[CAR[LARGEUR]]     dilater les CARactères (ou tabulation) selon la\n"
#~ "                       LARGEUR de tabulation (par défaut 8)\n"
#~ "  -h EN_TÊTE           afficher l'EN_TÊTE au lieu du nom de fichier\n"
#~ "  -i[CAR[LARGEUR]]     remplacer les blancs par des CARactères (ou\n"
#~ "                       tabulation) selon la LARGEUR de tabulation (8)\n"
#~ "  -l LONGUEUR_DE_PAGE  utiliser LONGUEUR_DE_PAGE au lieu de 66 "
#~ "lignes                        (par défaut)\n"
#~ "  -m                   imprimer tous les fichiers en parallèle\n"
#~ "                       un par colonne\n"
#~ "  -n[SÉP[CHIFFRES]]    numéroter les lignes, par des CHIFFRES (5), suivi "
#~ "de\n"
#~ "                       SÉParateurs (TAB)\n"
#~ "  -o MARGE             effectuer le saut de chaque ligne selon la "
#~ "MARGE                        d'espace (n'affecte pas -w)\n"
#~ "  -r                   inhiber les avertissements lorsqu'un fichier\n"
#~ "                       ne peut être ouvert\n"
#~ "  -s[SÉP]              séparer les colonnes par le SÉParateur (ou TAB)\n"
#~ "  -t                   inhiber les 5 lignes d'en-tête et de bas de page \n"
#~ "  -v                   utiliser la notation octale avec barre oblique\n"
#~ "                       inverse\n"
#~ "  -w LARGEUR_DE_PAGE   utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\n"
#~ "                       (défaut)\n"
#~ "      --help           afficher l'aide-mémoire\n"
#~ "      --version        afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "L'option -t est implicite lorsque -l N est utilisé et quand N < 10.\n"
#~ "Sans -s, les colonnes sont séparées par des blancs.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
